{"version":3,"sources":["node_modules/browser-pack/_prelude.js","dist/lib/gridDistance.js","dist/lib/sortedFood.js","dist/lib/weight.js","dist/web.js","node_modules/heap/index.js","node_modules/heap/lib/heap.js","node_modules/pathfinding/index.js","node_modules/pathfinding/src/PathFinding.js","node_modules/pathfinding/src/core/DiagonalMovement.js","node_modules/pathfinding/src/core/Grid.js","node_modules/pathfinding/src/core/Heuristic.js","node_modules/pathfinding/src/core/Node.js","node_modules/pathfinding/src/core/Util.js","node_modules/pathfinding/src/finders/AStarFinder.js","node_modules/pathfinding/src/finders/BestFirstFinder.js","node_modules/pathfinding/src/finders/BiAStarFinder.js","node_modules/pathfinding/src/finders/BiBestFirstFinder.js","node_modules/pathfinding/src/finders/BiBreadthFirstFinder.js","node_modules/pathfinding/src/finders/BiDijkstraFinder.js","node_modules/pathfinding/src/finders/BreadthFirstFinder.js","node_modules/pathfinding/src/finders/DijkstraFinder.js","node_modules/pathfinding/src/finders/IDAStarFinder.js","node_modules/pathfinding/src/finders/JPFAlwaysMoveDiagonally.js","node_modules/pathfinding/src/finders/JPFMoveDiagonallyIfAtMostOneObstacle.js","node_modules/pathfinding/src/finders/JPFMoveDiagonallyIfNoObstacles.js","node_modules/pathfinding/src/finders/JPFNeverMoveDiagonally.js","node_modules/pathfinding/src/finders/JumpPointFinder.js","node_modules/pathfinding/src/finders/JumpPointFinderBase.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjKA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjXA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"bundle.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction gridDistance(x1, y1, x2, y2) {\n    return Math.abs(x1 - x2) + Math.abs(y1 - y2);\n}\nexports.gridDistance = gridDistance;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst gridDistance_1 = require(\"./gridDistance\");\nfunction sortedFood(data) {\n    const sorted = {\n        food: null,\n        distance: 100000,\n    };\n    if (!data.board.food.length) {\n        return null;\n    }\n    const result = [];\n    for (const food of data.board.food) {\n        result.push({\n            food: food,\n            distance: gridDistance_1.gridDistance(data.you.body[0].x, data.you.body[0].y, food.x, food.y),\n        });\n    }\n    result.sort((a, b) => {\n        return a.distance - b.distance;\n    });\n    return result;\n}\nexports.sortedFood = sortedFood;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst gridDistance_1 = require(\"./gridDistance\");\nfunction weight(data, x, y) {\n    for (const snake of data.board.snakes) {\n        const body = snake.body;\n        // const body = snake.body.filter((p1, i, a) => a.findIndex(p2 => p1.x == p2.x && p1.y == p2.y) === i);\n        for (const [p, part] of body.entries()) {\n            // Is part of snake?\n            if (part.x == x && part.y == y) {\n                // Is end of snake?\n                if (p != body.length - 1) {\n                    return 0;\n                }\n            }\n        }\n    }\n    for (const snake of data.board.snakes) {\n        const body = snake.body;\n        for (const [p, part] of body.entries()) {\n            // Is near head?\n            if (snake.id != data.you.id && p == 0) {\n                const distance = gridDistance_1.gridDistance(x, y, part.x, part.y);\n                if (distance < 4) {\n                    return distance * 10;\n                }\n            }\n        }\n    }\n    return 50;\n}\nexports.weight = weight;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst weight_1 = require(\"./lib/weight\");\nconst sortedFood_1 = require(\"./lib/sortedFood\");\nconst PF = require('pathfinding');\n// const colors = ['#2ecc71', '#3498db', '#9b59b6', '#f1c40f', '#e67e22', '#e74c3c', '#95a5a6', '#34495e'];\nconst grid = $('.grid');\nconst getCol = (x, y) => {\n    return grid.find('.row').eq(y).find('.col').eq(x);\n};\nconst BLOCKED = 1;\nconst FREE = 0;\nconst pf = new PF.AStarFinder({\n    allowDiagonal: false,\n    useCost: true,\n});\nconst drawBoard = (data) => {\n    grid.html('');\n    const matrix = [];\n    const costs = [];\n    for (var y = 0; y < data.board.height; y++) {\n        matrix[y] = [];\n        costs[y] = [];\n        const row = $('<div>').addClass('row').appendTo(grid);\n        for (var x = 0; x < data.board.width; x++) {\n            const w = weight_1.weight(data, x, y);\n            matrix[y][x] = w > 0 ? FREE : BLOCKED;\n            costs[y][x] = 100 - w;\n            const col = $('<div>').addClass('col').css({\n                backgroundColor: `rgba(0, 0, 0, ${(100 - w) / 100})`,\n            }).appendTo(row);\n            $('<div>').addClass('weight').html(x + '/' + y + '<br/>w:' + w + '<br/>' + (matrix[y][x] == FREE ? 'FREE' : 'BLOCKED') + '<br/>c:' + costs[y][x]).css({\n                color: w < 60 ? 'white' : 'black',\n            }).appendTo(col);\n        }\n    }\n    for (const food of data.board.food) {\n        const col = getCol(food.x, food.y);\n        $('<div>').addClass('food').appendTo(col);\n    }\n    for (const snake of data.board.snakes) {\n        const color = snake.id == data.you.id ? '#2ecc71' : '#e74c3c';\n        for (const [p, part] of snake.body.entries()) {\n            const col = getCol(part.x, part.y);\n            $('<div>').addClass('snake').css({\n                backgroundColor: color,\n                borderRadius: p == 0 ? 100 : 0,\n            }).text(' ').appendTo(col);\n        }\n    }\n    const sorted = sortedFood_1.sortedFood(data);\n    if (!sorted.length) {\n        return;\n    }\n    closest: for (const closest of sorted) {\n        const pfGrid = new PF.Grid(data.board.width, data.board.height, matrix, costs);\n        const path = pf.findPath(data.you.body[0].x, data.you.body[0].y, closest.food.x, closest.food.y, pfGrid.clone());\n        for (let i = 0; i < path.length; i++) {\n            const p = path[i];\n            if (i == 0) {\n                continue;\n            }\n            const col = getCol(p[0], p[1]);\n            $('<div>').addClass('path').appendTo(col);\n        }\n        for (let i = 0; i < path.length; i++) {\n            const p = path[i];\n            if (i === 0) {\n                continue;\n            }\n            if (p[0] == data.you.body[0].x - 1 && p[1] == data.you.body[0].y) {\n                // Left\n                console.log('moveTowardsFoodPf', p, 'left');\n                break closest;\n            }\n            else if (p[0] == data.you.body[0].x + 1 && p[1] == data.you.body[0].y) {\n                // Right\n                console.log('moveTowardsFoodPf', p, 'right');\n                break closest;\n            }\n            else if (p[0] == data.you.body[0].x && p[1] == data.you.body[0].y - 1) {\n                // Up\n                console.log('moveTowardsFoodPf', p, 'up');\n                break closest;\n            }\n            else if (p[0] == data.you.body[0].x && p[1] == data.you.body[0].y + 1) {\n                // Down\n                console.log('moveTowardsFoodPf', p, 'down');\n                break closest;\n            }\n            else {\n                console.log('moveTowardsFoodPf', p, 'no path');\n            }\n        }\n    }\n    // hasWayOut(data, path);\n};\nconst hasWayOut = (data, path) => {\n    const matrix = [];\n    const costs = [];\n    for (var y = 0; y < data.board.height; y++) {\n        matrix[y] = [];\n        costs[y] = [];\n        for (var x = 0; x < data.board.width; x++) {\n            const w = weight_1.weight(data, x, y);\n            matrix[y][x] = w > 0 ? FREE : BLOCKED;\n            costs[y][x] = 100 - w;\n        }\n    }\n    for (const [i, p] of path.entries()) {\n        matrix[p[1]][p[0]] = BLOCKED;\n    }\n    const pfGrid = new PF.Grid(data.board.width, data.board.height, matrix, costs);\n    for (const food of data.board.food) {\n        const wayOutPath = pf.findPath(data.you.body[0].x, data.you.body[0].y, food.x, food.y, pfGrid.clone());\n        console.log(wayOutPath);\n    }\n};\nlet game = null;\nconst loadGame = (gameFile, turn = null) => {\n    $('.moves').html('');\n    $.getJSON('../games/' + gameFile).done((response) => {\n        game = response;\n        if (turn) {\n            drawBoard(game.moves[turn]);\n        }\n        else {\n            drawBoard(game.start);\n        }\n        for (const move of game.moves) {\n            if (!move || !move.turn) {\n                continue;\n            }\n            $('<div>').addClass('move').data('turn', move.turn).text('Move ' + move.turn).appendTo('.moves');\n        }\n    }).fail((xhr, textStatus, errorThrown) => {\n        $('.log').text(textStatus + ': ' + errorThrown);\n        console.error(textStatus, errorThrown);\n    });\n};\n$('.game').click(function () {\n    const gameFile = $(this).data('game');\n    loadGame(gameFile);\n});\nconst urlParams = new URLSearchParams(window.location.search);\nconst queryGame = urlParams.get('game');\nconst queryTurn = urlParams.get('turn');\nif (queryGame) {\n    loadGame(queryGame, queryTurn);\n}\nelse {\n    $('.game:last').click();\n}\n$('.moves').on('click', '.move', function () {\n    const turn = $(this).data('turn');\n    drawBoard(game.moves[turn]);\n    const newUrl = window.location.protocol + \"//\" + window.location.host + window.location.pathname + '?game=' + game.moves[turn].you.id + '&turn=' + turn;\n    window.history.pushState({\n        path: newUrl,\n    }, '', newUrl);\n});\n","module.exports = require('./lib/heap');\n","// Generated by CoffeeScript 1.8.0\n(function() {\n  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n\n  floor = Math.floor, min = Math.min;\n\n\n  /*\n  Default comparison function to be used\n   */\n\n  defaultCmp = function(x, y) {\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    return 0;\n  };\n\n\n  /*\n  Insert item x in list a, and keep it sorted assuming a is sorted.\n  \n  If x is already in a, insert it to the right of the rightmost x.\n  \n  Optional args lo (default 0) and hi (default a.length) bound the slice\n  of a to be searched.\n   */\n\n  insort = function(a, x, lo, hi, cmp) {\n    var mid;\n    if (lo == null) {\n      lo = 0;\n    }\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (lo < 0) {\n      throw new Error('lo must be non-negative');\n    }\n    if (hi == null) {\n      hi = a.length;\n    }\n    while (lo < hi) {\n      mid = floor((lo + hi) / 2);\n      if (cmp(x, a[mid]) < 0) {\n        hi = mid;\n      } else {\n        lo = mid + 1;\n      }\n    }\n    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);\n  };\n\n\n  /*\n  Push item onto heap, maintaining the heap invariant.\n   */\n\n  heappush = function(array, item, cmp) {\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    array.push(item);\n    return _siftdown(array, 0, array.length - 1, cmp);\n  };\n\n\n  /*\n  Pop the smallest item off the heap, maintaining the heap invariant.\n   */\n\n  heappop = function(array, cmp) {\n    var lastelt, returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    lastelt = array.pop();\n    if (array.length) {\n      returnitem = array[0];\n      array[0] = lastelt;\n      _siftup(array, 0, cmp);\n    } else {\n      returnitem = lastelt;\n    }\n    return returnitem;\n  };\n\n\n  /*\n  Pop and return the current smallest value, and add the new item.\n  \n  This is more efficient than heappop() followed by heappush(), and can be\n  more appropriate when using a fixed size heap. Note that the value\n  returned may be larger than item! That constrains reasonable use of\n  this routine unless written as part of a conditional replacement:\n      if item > array[0]\n        item = heapreplace(array, item)\n   */\n\n  heapreplace = function(array, item, cmp) {\n    var returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    returnitem = array[0];\n    array[0] = item;\n    _siftup(array, 0, cmp);\n    return returnitem;\n  };\n\n\n  /*\n  Fast version of a heappush followed by a heappop.\n   */\n\n  heappushpop = function(array, item, cmp) {\n    var _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (array.length && cmp(array[0], item) < 0) {\n      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];\n      _siftup(array, 0, cmp);\n    }\n    return item;\n  };\n\n\n  /*\n  Transform list into a heap, in-place, in O(array.length) time.\n   */\n\n  heapify = function(array, cmp) {\n    var i, _i, _j, _len, _ref, _ref1, _results, _results1;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    _ref1 = (function() {\n      _results1 = [];\n      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }\n      return _results1;\n    }).apply(this).reverse();\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      i = _ref1[_i];\n      _results.push(_siftup(array, i, cmp));\n    }\n    return _results;\n  };\n\n\n  /*\n  Update the position of the given item in the heap.\n  This function should be called every time the item is being modified.\n   */\n\n  updateItem = function(array, item, cmp) {\n    var pos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    pos = array.indexOf(item);\n    if (pos === -1) {\n      return;\n    }\n    _siftdown(array, 0, pos, cmp);\n    return _siftup(array, pos, cmp);\n  };\n\n\n  /*\n  Find the n largest elements in a dataset.\n   */\n\n  nlargest = function(array, n, cmp) {\n    var elem, result, _i, _len, _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    result = array.slice(0, n);\n    if (!result.length) {\n      return result;\n    }\n    heapify(result, cmp);\n    _ref = array.slice(n);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      elem = _ref[_i];\n      heappushpop(result, elem, cmp);\n    }\n    return result.sort(cmp).reverse();\n  };\n\n\n  /*\n  Find the n smallest elements in a dataset.\n   */\n\n  nsmallest = function(array, n, cmp) {\n    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (n * 10 <= array.length) {\n      result = array.slice(0, n).sort(cmp);\n      if (!result.length) {\n        return result;\n      }\n      los = result[result.length - 1];\n      _ref = array.slice(n);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        elem = _ref[_i];\n        if (cmp(elem, los) < 0) {\n          insort(result, elem, 0, null, cmp);\n          result.pop();\n          los = result[result.length - 1];\n        }\n      }\n      return result;\n    }\n    heapify(array, cmp);\n    _results = [];\n    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n      _results.push(heappop(array, cmp));\n    }\n    return _results;\n  };\n\n  _siftdown = function(array, startpos, pos, cmp) {\n    var newitem, parent, parentpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    newitem = array[pos];\n    while (pos > startpos) {\n      parentpos = (pos - 1) >> 1;\n      parent = array[parentpos];\n      if (cmp(newitem, parent) < 0) {\n        array[pos] = parent;\n        pos = parentpos;\n        continue;\n      }\n      break;\n    }\n    return array[pos] = newitem;\n  };\n\n  _siftup = function(array, pos, cmp) {\n    var childpos, endpos, newitem, rightpos, startpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    endpos = array.length;\n    startpos = pos;\n    newitem = array[pos];\n    childpos = 2 * pos + 1;\n    while (childpos < endpos) {\n      rightpos = childpos + 1;\n      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n        childpos = rightpos;\n      }\n      array[pos] = array[childpos];\n      pos = childpos;\n      childpos = 2 * pos + 1;\n    }\n    array[pos] = newitem;\n    return _siftdown(array, startpos, pos, cmp);\n  };\n\n  Heap = (function() {\n    Heap.push = heappush;\n\n    Heap.pop = heappop;\n\n    Heap.replace = heapreplace;\n\n    Heap.pushpop = heappushpop;\n\n    Heap.heapify = heapify;\n\n    Heap.updateItem = updateItem;\n\n    Heap.nlargest = nlargest;\n\n    Heap.nsmallest = nsmallest;\n\n    function Heap(cmp) {\n      this.cmp = cmp != null ? cmp : defaultCmp;\n      this.nodes = [];\n    }\n\n    Heap.prototype.push = function(x) {\n      return heappush(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pop = function() {\n      return heappop(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.peek = function() {\n      return this.nodes[0];\n    };\n\n    Heap.prototype.contains = function(x) {\n      return this.nodes.indexOf(x) !== -1;\n    };\n\n    Heap.prototype.replace = function(x) {\n      return heapreplace(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pushpop = function(x) {\n      return heappushpop(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.heapify = function() {\n      return heapify(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.updateItem = function(x) {\n      return updateItem(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.clear = function() {\n      return this.nodes = [];\n    };\n\n    Heap.prototype.empty = function() {\n      return this.nodes.length === 0;\n    };\n\n    Heap.prototype.size = function() {\n      return this.nodes.length;\n    };\n\n    Heap.prototype.clone = function() {\n      var heap;\n      heap = new Heap();\n      heap.nodes = this.nodes.slice(0);\n      return heap;\n    };\n\n    Heap.prototype.toArray = function() {\n      return this.nodes.slice(0);\n    };\n\n    Heap.prototype.insert = Heap.prototype.push;\n\n    Heap.prototype.top = Heap.prototype.peek;\n\n    Heap.prototype.front = Heap.prototype.peek;\n\n    Heap.prototype.has = Heap.prototype.contains;\n\n    Heap.prototype.copy = Heap.prototype.clone;\n\n    return Heap;\n\n  })();\n\n  if (typeof module !== \"undefined\" && module !== null ? module.exports : void 0) {\n    module.exports = Heap;\n  } else {\n    window.Heap = Heap;\n  }\n\n}).call(this);\n","module.exports = require('./src/PathFinding');\n","module.exports = {\n    'Heap'                      : require('heap'),\n    'Node'                      : require('./core/Node'),\n    'Grid'                      : require('./core/Grid'),\n    'Util'                      : require('./core/Util'),\n\t'DiagonalMovement'          : require('./core/DiagonalMovement'),\n    'Heuristic'                 : require('./core/Heuristic'),\n    'AStarFinder'               : require('./finders/AStarFinder'),\n    'BestFirstFinder'           : require('./finders/BestFirstFinder'),\n    'BreadthFirstFinder'        : require('./finders/BreadthFirstFinder'),\n    'DijkstraFinder'            : require('./finders/DijkstraFinder'),\n    'BiAStarFinder'             : require('./finders/BiAStarFinder'),\n    'BiBestFirstFinder'         : require('./finders/BiBestFirstFinder'),\n    'BiBreadthFirstFinder'      : require('./finders/BiBreadthFirstFinder'),\n    'BiDijkstraFinder'          : require('./finders/BiDijkstraFinder'),\n    'IDAStarFinder'             : require('./finders/IDAStarFinder'),\n    'JumpPointFinder'           : require('./finders/JumpPointFinder'),\n};\n","var DiagonalMovement = {\n    Always: 1,\n    Never: 2,\n    IfAtMostOneObstacle: 3,\n    OnlyWhenNoObstacles: 4\n};\n\nmodule.exports = DiagonalMovement;","var Node = require('./Node');\nvar DiagonalMovement = require('./DiagonalMovement');\n\n/**\n * The Grid class, which serves as the encapsulation of the layout of the nodes.\n * @constructor\n * @param {number|Array.<Array.<(number|boolean)>>} width_or_matrix Number of columns of the grid, or matrix\n * @param {number} height Number of rows of the grid.\n * @param {Array.<Array.<(number|boolean)>>} [matrix] - A 0-1 matrix\n *     representing the walkable status of the nodes(0 or false for walkable).\n *     If the matrix is not supplied, all the nodes will be walkable. \n * @param {Array.<Array.<(number)>>} [costs] - A matrix\n *     representing the cost of walking the node.\n *     If the costs is not supplied, all the nodes will cost 0.  */\nfunction Grid(width_or_matrix, height, matrix, costs) {\n    var width;\n\n    if (typeof width_or_matrix !== 'object') {\n        width = width_or_matrix;\n    } else {\n        height = width_or_matrix.length;\n        width = width_or_matrix[0].length;\n        matrix = width_or_matrix;\n    }\n\n    /**\n     * The number of columns of the grid.\n     * @type number\n     */\n    this.width = width;\n    /**\n     * The number of rows of the grid.\n     * @type number\n     */\n    this.height = height;\n\n    /**\n     * A 2D array of nodes.\n     */\n    this.nodes = this._buildNodes(width, height, matrix, costs);\n}\n\n/**\n * Build and return the nodes.\n * @private\n * @param {number} width\n * @param {number} height\n * @param {Array.<Array.<number|boolean>>} [matrix] - A 0-1 matrix representing\n *     the walkable status of the nodes.\n * @param {Array.<Array.<number>>} [costs] - A matrix representing\n *     the costs to walk the nodes.\n * @see Grid\n */\nGrid.prototype._buildNodes = function(width, height, matrix, costs) {\n    var i, j,\n        nodes = new Array(height),\n        row;\n\n    for (i = 0; i < height; ++i) {\n        nodes[i] = new Array(width);\n        for (j = 0; j < width; ++j) {\n            nodes[i][j] = new Node(j, i);\n        }\n    }\n\n    if (matrix === undefined) {\n        return nodes;\n    }\n\n    if (matrix.length !== height || matrix[0].length !== width) {\n        throw new Error('Matrix size does not fit');\n    }\n\n    if (costs !== undefined && (costs.length !== height || costs[0].length !== width)) {\n        throw new Error('Costs size does not fit');\n    }\n\n    for (i = 0; i < height; ++i) {\n        for (j = 0; j < width; ++j) {\n            if (matrix[i][j]) {\n                // 0, false, null will be walkable\n                // while others will be un-walkable\n                nodes[i][j].walkable = false;\n            }\n            if (costs !== undefined) {\n                nodes[i][j].cost=costs[i][j];\n            }\n        }\n    }\n\n    return nodes;\n};\n\n\nGrid.prototype.getNodeAt = function(x, y) {\n    return this.nodes[y][x];\n};\n\n\n/**\n * Determine whether the node at the given position is walkable.\n * (Also returns false if the position is outside the grid.)\n * @param {number} x - The x coordinate of the node.\n * @param {number} y - The y coordinate of the node.\n * @return {boolean} - The walkability of the node.\n */\nGrid.prototype.isWalkableAt = function(x, y) {\n    return this.isInside(x, y) && this.nodes[y][x].walkable;\n};\n\n\n/**\n * Get cost to walk the node at the given position.\n * (Also returns false if the position is outside the grid.)\n * @param {number} x - The x coordinate of the node.\n * @param {number} y - The y coordinate of the node.\n * @return {number} - Cost to walk node.\n */\nGrid.prototype.getCostAt = function(x, y) {\n    if (!this.isInside(x, y)) return false;\n    return this.nodes[y][x].cost;\n};\n\n\n/**\n * Determine whether the position is inside the grid.\n * XXX: `grid.isInside(x, y)` is wierd to read.\n * It should be `(x, y) is inside grid`, but I failed to find a better\n * name for this method.\n * @param {number} x\n * @param {number} y\n * @return {boolean}\n */\nGrid.prototype.isInside = function(x, y) {\n    return (x >= 0 && x < this.width) && (y >= 0 && y < this.height);\n};\n\n\n/**\n * Set whether the node on the given position is walkable.\n * NOTE: throws exception if the coordinate is not inside the grid.\n * @param {number} x - The x coordinate of the node.\n * @param {number} y - The y coordinate of the node.\n * @param {boolean} walkable - Whether the position is walkable.\n */\nGrid.prototype.setWalkableAt = function(x, y, walkable) {\n    this.nodes[y][x].walkable = walkable;\n};\n\n\n/**\n * Set cost of the node on the given position\n * NOTE: throws exception if the coordinate is not inside the grid.\n * @param {number} x - The x coordinate of the node.\n * @param {number} y - The y coordinate of the node.\n * @param {number} cost - Cost to walk the node.\n */\nGrid.prototype.setCostAt = function(x, y, cost) {\n    this.nodes[y][x].cost = cost;\n};\n\n\n/**\n * Get the neighbors of the given node.\n *\n *     offsets      diagonalOffsets:\n *  +---+---+---+    +---+---+---+\n *  |   | 0 |   |    | 0 |   | 1 |\n *  +---+---+---+    +---+---+---+\n *  | 3 |   | 1 |    |   |   |   |\n *  +---+---+---+    +---+---+---+\n *  |   | 2 |   |    | 3 |   | 2 |\n *  +---+---+---+    +---+---+---+\n *\n *  When allowDiagonal is true, if offsets[i] is valid, then\n *  diagonalOffsets[i] and\n *  diagonalOffsets[(i + 1) % 4] is valid.\n * @param {Node} node\n * @param {DiagonalMovement} diagonalMovement\n */\nGrid.prototype.getNeighbors = function(node, diagonalMovement) {\n    var x = node.x,\n        y = node.y,\n        neighbors = [],\n        s0 = false, d0 = false,\n        s1 = false, d1 = false,\n        s2 = false, d2 = false,\n        s3 = false, d3 = false,\n        nodes = this.nodes;\n\n    // ↑\n    if (this.isWalkableAt(x, y - 1)) {\n        neighbors.push(nodes[y - 1][x]);\n        s0 = true;\n    }\n    // →\n    if (this.isWalkableAt(x + 1, y)) {\n        neighbors.push(nodes[y][x + 1]);\n        s1 = true;\n    }\n    // ↓\n    if (this.isWalkableAt(x, y + 1)) {\n        neighbors.push(nodes[y + 1][x]);\n        s2 = true;\n    }\n    // ←\n    if (this.isWalkableAt(x - 1, y)) {\n        neighbors.push(nodes[y][x - 1]);\n        s3 = true;\n    }\n\n    if (diagonalMovement === DiagonalMovement.Never) {\n        return neighbors;\n    }\n\n    if (diagonalMovement === DiagonalMovement.OnlyWhenNoObstacles) {\n        d0 = s3 && s0;\n        d1 = s0 && s1;\n        d2 = s1 && s2;\n        d3 = s2 && s3;\n    } else if (diagonalMovement === DiagonalMovement.IfAtMostOneObstacle) {\n        d0 = s3 || s0;\n        d1 = s0 || s1;\n        d2 = s1 || s2;\n        d3 = s2 || s3;\n    } else if (diagonalMovement === DiagonalMovement.Always) {\n        d0 = true;\n        d1 = true;\n        d2 = true;\n        d3 = true;\n    } else {\n        throw new Error('Incorrect value of diagonalMovement');\n    }\n\n    // ↖\n    if (d0 && this.isWalkableAt(x - 1, y - 1)) {\n        neighbors.push(nodes[y - 1][x - 1]);\n    }\n    // ↗\n    if (d1 && this.isWalkableAt(x + 1, y - 1)) {\n        neighbors.push(nodes[y - 1][x + 1]);\n    }\n    // ↘\n    if (d2 && this.isWalkableAt(x + 1, y + 1)) {\n        neighbors.push(nodes[y + 1][x + 1]);\n    }\n    // ↙\n    if (d3 && this.isWalkableAt(x - 1, y + 1)) {\n        neighbors.push(nodes[y + 1][x - 1]);\n    }\n\n    return neighbors;\n};\n\n\n/**\n * Get a clone of this grid.\n * @return {Grid} Cloned grid.\n */\nGrid.prototype.clone = function() {\n    var i, j,\n\n        width = this.width,\n        height = this.height,\n        thisNodes = this.nodes,\n\n        newGrid = new Grid(width, height),\n        newNodes = new Array(height),\n        row;\n\n    for (i = 0; i < height; ++i) {\n        newNodes[i] = new Array(width);\n        for (j = 0; j < width; ++j) {\n            newNodes[i][j] = new Node(j, i, thisNodes[i][j].walkable, thisNodes[i][j].cost);\n        }\n    }\n\n    newGrid.nodes = newNodes;\n\n    return newGrid;\n};\n\nmodule.exports = Grid;\n","/**\n * @namespace PF.Heuristic\n * @description A collection of heuristic functions.\n */\nmodule.exports = {\n\n  /**\n   * Manhattan distance.\n   * @param {number} dx - Difference in x.\n   * @param {number} dy - Difference in y.\n   * @return {number} dx + dy\n   */\n  manhattan: function(dx, dy) {\n      return dx + dy;\n  },\n\n  /**\n   * Euclidean distance.\n   * @param {number} dx - Difference in x.\n   * @param {number} dy - Difference in y.\n   * @return {number} sqrt(dx * dx + dy * dy)\n   */\n  euclidean: function(dx, dy) {\n      return Math.sqrt(dx * dx + dy * dy);\n  },\n\n  /**\n   * Octile distance.\n   * @param {number} dx - Difference in x.\n   * @param {number} dy - Difference in y.\n   * @return {number} sqrt(dx * dx + dy * dy) for grids\n   */\n  octile: function(dx, dy) {\n      var F = Math.SQRT2 - 1;\n      return (dx < dy) ? F * dx + dy : F * dy + dx;\n  },\n\n  /**\n   * Chebyshev distance.\n   * @param {number} dx - Difference in x.\n   * @param {number} dy - Difference in y.\n   * @return {number} max(dx, dy)\n   */\n  chebyshev: function(dx, dy) {\n      return Math.max(dx, dy);\n  }\n\n};\n","/**\n * A node in grid. \n * This class holds some basic information about a node and custom \n * attributes may be added, depending on the algorithms' needs.\n * @constructor\n * @param {number} x - The x coordinate of the node on the grid.\n * @param {number} y - The y coordinate of the node on the grid.\n * @param {boolean} [walkable] - Whether this node is walkable.\n * @param {number} [cost] - node cost used by finders that allow non-uniform node costs\n */\nfunction Node(x, y, walkable, cost) {\n    /**\n     * The x coordinate of the node on the grid.\n     * @type number\n     */\n    this.x = x;\n    /**\n     * The y coordinate of the node on the grid.\n     * @type number\n     */\n    this.y = y;\n    /**\n     * Whether this node can be walked through.\n     * @type boolean\n     */\n    this.walkable = (walkable === undefined ? true : walkable);\n    /**\n     * Cost to walk this node if its walkable\n     * @type number\n     */\n    this.cost = (cost === undefined) ? 0 : cost;\n}\n\nmodule.exports = Node;\n","/**\n * Backtrace according to the parent records and return the path.\n * (including both start and end nodes)\n * @param {Node} node End node\n * @return {Array.<Array.<number>>} the path\n */\nfunction backtrace(node) {\n    var path = [[node.x, node.y]];\n    while (node.parent) {\n        node = node.parent;\n        path.push([node.x, node.y]);\n    }\n    return path.reverse();\n}\nexports.backtrace = backtrace;\n\n/**\n * Backtrace from start and end node, and return the path.\n * (including both start and end nodes)\n * @param {Node}\n * @param {Node}\n */\nfunction biBacktrace(nodeA, nodeB) {\n    var pathA = backtrace(nodeA),\n        pathB = backtrace(nodeB);\n    return pathA.concat(pathB.reverse());\n}\nexports.biBacktrace = biBacktrace;\n\n/**\n * Compute the length of the path.\n * @param {Array.<Array.<number>>} path The path\n * @return {number} The length of the path\n */\nfunction pathLength(path) {\n    var i, sum = 0, a, b, dx, dy;\n    for (i = 1; i < path.length; ++i) {\n        a = path[i - 1];\n        b = path[i];\n        dx = a[0] - b[0];\n        dy = a[1] - b[1];\n        sum += Math.sqrt(dx * dx + dy * dy);\n    }\n    return sum;\n}\nexports.pathLength = pathLength;\n\n\n/**\n * Given the start and end coordinates, return all the coordinates lying\n * on the line formed by these coordinates, based on Bresenham's algorithm.\n * http://en.wikipedia.org/wiki/Bresenham's_line_algorithm#Simplification\n * @param {number} x0 Start x coordinate\n * @param {number} y0 Start y coordinate\n * @param {number} x1 End x coordinate\n * @param {number} y1 End y coordinate\n * @return {Array.<Array.<number>>} The coordinates on the line\n */\nfunction interpolate(x0, y0, x1, y1) {\n    var abs = Math.abs,\n        line = [],\n        sx, sy, dx, dy, err, e2;\n\n    dx = abs(x1 - x0);\n    dy = abs(y1 - y0);\n\n    sx = (x0 < x1) ? 1 : -1;\n    sy = (y0 < y1) ? 1 : -1;\n\n    err = dx - dy;\n\n    while (true) {\n        line.push([x0, y0]);\n\n        if (x0 === x1 && y0 === y1) {\n            break;\n        }\n        \n        e2 = 2 * err;\n        if (e2 > -dy) {\n            err = err - dy;\n            x0 = x0 + sx;\n        }\n        if (e2 < dx) {\n            err = err + dx;\n            y0 = y0 + sy;\n        }\n    }\n\n    return line;\n}\nexports.interpolate = interpolate;\n\n\n/**\n * Given a compressed path, return a new path that has all the segments\n * in it interpolated.\n * @param {Array.<Array.<number>>} path The path\n * @return {Array.<Array.<number>>} expanded path\n */\nfunction expandPath(path) {\n    var expanded = [],\n        len = path.length,\n        coord0, coord1,\n        interpolated,\n        interpolatedLen,\n        i, j;\n\n    if (len < 2) {\n        return expanded;\n    }\n\n    for (i = 0; i < len - 1; ++i) {\n        coord0 = path[i];\n        coord1 = path[i + 1];\n\n        interpolated = interpolate(coord0[0], coord0[1], coord1[0], coord1[1]);\n        interpolatedLen = interpolated.length;\n        for (j = 0; j < interpolatedLen - 1; ++j) {\n            expanded.push(interpolated[j]);\n        }\n    }\n    expanded.push(path[len - 1]);\n\n    return expanded;\n}\nexports.expandPath = expandPath;\n\n\n/**\n * Smoothen the give path.\n * The original path will not be modified; a new path will be returned.\n * @param {PF.Grid} grid\n * @param {Array.<Array.<number>>} path The path\n */\nfunction smoothenPath(grid, path) {\n    var len = path.length,\n        x0 = path[0][0],        // path start x\n        y0 = path[0][1],        // path start y\n        x1 = path[len - 1][0],  // path end x\n        y1 = path[len - 1][1],  // path end y\n        sx, sy,                 // current start coordinate\n        ex, ey,                 // current end coordinate\n        newPath,\n        i, j, coord, line, testCoord, blocked;\n\n    sx = x0;\n    sy = y0;\n    newPath = [[sx, sy]];\n\n    for (i = 2; i < len; ++i) {\n        coord = path[i];\n        ex = coord[0];\n        ey = coord[1];\n        line = interpolate(sx, sy, ex, ey);\n\n        blocked = false;\n        for (j = 1; j < line.length; ++j) {\n            testCoord = line[j];\n\n            if (!grid.isWalkableAt(testCoord[0], testCoord[1])) {\n                blocked = true;\n                break;\n            }\n        }\n        if (blocked) {\n            lastValidCoord = path[i - 1];\n            newPath.push(lastValidCoord);\n            sx = lastValidCoord[0];\n            sy = lastValidCoord[1];\n        }\n    }\n    newPath.push([x1, y1]);\n\n    return newPath;\n}\nexports.smoothenPath = smoothenPath;\n\n\n/**\n * Compress a path, remove redundant nodes without altering the shape\n * The original path is not modified\n * @param {Array.<Array.<number>>} path The path\n * @return {Array.<Array.<number>>} The compressed path\n */\nfunction compressPath(path) {\n\n    // nothing to compress\n    if(path.length < 3) {\n        return path;\n    }\n\n    var compressed = [],\n        sx = path[0][0], // start x\n        sy = path[0][1], // start y\n        px = path[1][0], // second point x\n        py = path[1][1], // second point y\n        dx = px - sx, // direction between the two points\n        dy = py - sy, // direction between the two points\n        lx, ly,\n        ldx, ldy,\n        sq, i;\n\n    // normalize the direction\n    sq = Math.sqrt(dx*dx + dy*dy);\n    dx /= sq;\n    dy /= sq;\n\n    // start the new path\n    compressed.push([sx,sy]);\n\n    for(i = 2; i < path.length; i++) {\n\n        // store the last point\n        lx = px;\n        ly = py;\n\n        // store the last direction\n        ldx = dx;\n        ldy = dy;\n\n        // next point\n        px = path[i][0];\n        py = path[i][1];\n\n        // next direction\n        dx = px - lx;\n        dy = py - ly;\n\n        // normalize\n        sq = Math.sqrt(dx*dx + dy*dy);\n        dx /= sq;\n        dy /= sq;\n\n        // if the direction has changed, store the point\n        if ( dx !== ldx || dy !== ldy ) {\n            compressed.push([lx,ly]);\n        }\n    }\n\n    // store the last point\n    compressed.push([px,py]);\n\n    return compressed;\n}\nexports.compressPath = compressPath;\n","var Heap       = require('heap');\nvar Util       = require('../core/Util');\nvar Heuristic  = require('../core/Heuristic');\nvar DiagonalMovement = require('../core/DiagonalMovement');\n\n/**\n * A* path-finder.\n * based upon https://github.com/bgrins/javascript-astar\n * @constructor\n * @param {object} opt\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed. Deprecated, use diagonalMovement instead.\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching block corners. Deprecated, use diagonalMovement instead.\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\n * @param {function} opt.heuristic Heuristic function to estimate the distance\n *     (defaults to manhattan).\n * @param {integer} opt.weight Weight to apply to the heuristic to allow for suboptimal paths, \n *     in order to speed up the search.\n */\nfunction AStarFinder(opt) {\n    opt = opt || {};\n    this.allowDiagonal = opt.allowDiagonal;\n    this.dontCrossCorners = opt.dontCrossCorners;\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\n    this.weight = opt.weight || 1;\n    this.diagonalMovement = opt.diagonalMovement;\n\n    if (!this.diagonalMovement) {\n        if (!this.allowDiagonal) {\n            this.diagonalMovement = DiagonalMovement.Never;\n        } else {\n            if (this.dontCrossCorners) {\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\n            } else {\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\n            }\n        }\n    }\n\n    //When diagonal movement is allowed the manhattan heuristic is not admissible\n    //It should be octile instead\n    if (this.diagonalMovement === DiagonalMovement.Never) {\n        this.heuristic = opt.heuristic || Heuristic.manhattan;\n    } else {\n        this.heuristic = opt.heuristic || Heuristic.octile;\n    }\n}\n\n/**\n * Find and return the the path.\n * @return {Array.<[number, number]>} The path, including both start and\n *     end positions.\n */\nAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\n    var openList = new Heap(function(nodeA, nodeB) {\n            return nodeA.f - nodeB.f;\n        }),\n        startNode = grid.getNodeAt(startX, startY),\n        endNode = grid.getNodeAt(endX, endY),\n        heuristic = this.heuristic,\n        diagonalMovement = this.diagonalMovement,\n        weight = this.weight,\n        abs = Math.abs, SQRT2 = Math.SQRT2,\n        node, neighbors, neighbor, i, l, x, y, ng;\n\n    // set the `g` and `f` value of the start node to be 0\n    startNode.g = 0;\n    startNode.f = 0;\n\n    // push the start node into the open list\n    openList.push(startNode);\n    startNode.opened = true;\n\n    // while the open list is not empty\n    while (!openList.empty()) {\n        // pop the position of node which has the minimum `f` value.\n        node = openList.pop();\n        node.closed = true;\n\n        // if reached the end position, construct the path and return it\n        if (node === endNode) {\n            return Util.backtrace(endNode);\n        }\n\n        // get neigbours of the current node\n        neighbors = grid.getNeighbors(node, diagonalMovement);\n        for (i = 0, l = neighbors.length; i < l; ++i) {\n            neighbor = neighbors[i];\n\n            if (neighbor.closed) {\n                continue;\n            }\n\n            x = neighbor.x;\n            y = neighbor.y;\n\n            // get the distance between current node and the neighbor\n            // and calculate the next g score\n            ng = node.g + neighbor.cost + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);\n\n            // check if the neighbor has not been inspected yet, or\n            // can be reached with smaller cost from the current node\n            if (!neighbor.opened || ng < neighbor.g) {\n                neighbor.g = ng;\n                neighbor.h = neighbor.h || weight * heuristic(abs(x - endX), abs(y - endY));\n                neighbor.f = neighbor.g + neighbor.h;\n                neighbor.parent = node;\n\n                if (!neighbor.opened) {\n                    openList.push(neighbor);\n                    neighbor.opened = true;\n                } else {\n                    // the neighbor can be reached with smaller cost.\n                    // Since its f value has been updated, we have to\n                    // update its position in the open list\n                    openList.updateItem(neighbor);\n                }\n            }\n        } // end for each neighbor\n    } // end while not open list empty\n\n    // fail to find the path\n    return [];\n};\n\nmodule.exports = AStarFinder;\n","var AStarFinder = require('./AStarFinder');\n\n/**\n * Best-First-Search path-finder.\n * @constructor\n * @extends AStarFinder\n * @param {object} opt\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed. Deprecated, use diagonalMovement instead.\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching block corners. Deprecated, use diagonalMovement instead.\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\n * @param {function} opt.heuristic Heuristic function to estimate the distance\n *     (defaults to manhattan).\n */\nfunction BestFirstFinder(opt) {\n    AStarFinder.call(this, opt);\n\n    var orig = this.heuristic;\n    this.heuristic = function(dx, dy) {\n        return orig(dx, dy) * 1000000;\n    };\n}\n\nBestFirstFinder.prototype = new AStarFinder();\nBestFirstFinder.prototype.constructor = BestFirstFinder;\n\nmodule.exports = BestFirstFinder;\n","var Heap       = require('heap');\nvar Util       = require('../core/Util');\nvar Heuristic  = require('../core/Heuristic');\nvar DiagonalMovement = require('../core/DiagonalMovement');\n\n/**\n * A* path-finder.\n * based upon https://github.com/bgrins/javascript-astar\n * @constructor\n * @param {object} opt\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed. Deprecated, use diagonalMovement instead.\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching block corners. Deprecated, use diagonalMovement instead.\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\n * @param {function} opt.heuristic Heuristic function to estimate the distance\n *     (defaults to manhattan).\n * @param {integer} opt.weight Weight to apply to the heuristic to allow for suboptimal paths, \n *     in order to speed up the search.\n */\nfunction BiAStarFinder(opt) {\n    opt = opt || {};\n    this.allowDiagonal = opt.allowDiagonal;\n    this.dontCrossCorners = opt.dontCrossCorners;\n    this.diagonalMovement = opt.diagonalMovement;\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\n    this.weight = opt.weight || 1;\n\n    if (!this.diagonalMovement) {\n        if (!this.allowDiagonal) {\n            this.diagonalMovement = DiagonalMovement.Never;\n        } else {\n            if (this.dontCrossCorners) {\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\n            } else {\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\n            }\n        }\n    }\n\n    //When diagonal movement is allowed the manhattan heuristic is not admissible\n    //It should be octile instead\n    if (this.diagonalMovement === DiagonalMovement.Never) {\n        this.heuristic = opt.heuristic || Heuristic.manhattan;\n    } else {\n        this.heuristic = opt.heuristic || Heuristic.octile;\n    }\n}\n\n/**\n * Find and return the the path.\n * @return {Array.<[number, number]>} The path, including both start and\n *     end positions.\n */\nBiAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\n    var cmp = function(nodeA, nodeB) {\n            return nodeA.f - nodeB.f;\n        },\n        startOpenList = new Heap(cmp),\n        endOpenList = new Heap(cmp),\n        startNode = grid.getNodeAt(startX, startY),\n        endNode = grid.getNodeAt(endX, endY),\n        heuristic = this.heuristic,\n        diagonalMovement = this.diagonalMovement,\n        weight = this.weight,\n        abs = Math.abs, SQRT2 = Math.SQRT2,\n        node, neighbors, neighbor, i, l, x, y, ng,\n        BY_START = 1, BY_END = 2;\n\n    // set the `g` and `f` value of the start node to be 0\n    // and push it into the start open list\n    startNode.g = 0;\n    startNode.f = 0;\n    startOpenList.push(startNode);\n    startNode.opened = BY_START;\n\n    // set the `g` and `f` value of the end node to be 0\n    // and push it into the open open list\n    endNode.g = 0;\n    endNode.f = 0;\n    endOpenList.push(endNode);\n    endNode.opened = BY_END;\n\n    // while both the open lists are not empty\n    while (!startOpenList.empty() && !endOpenList.empty()) {\n\n        // pop the position of start node which has the minimum `f` value.\n        node = startOpenList.pop();\n        node.closed = true;\n\n        // get neigbours of the current node\n        neighbors = grid.getNeighbors(node, diagonalMovement);\n        for (i = 0, l = neighbors.length; i < l; ++i) {\n            neighbor = neighbors[i];\n\n            if (neighbor.closed) {\n                continue;\n            }\n            if (neighbor.opened === BY_END) {\n                return Util.biBacktrace(node, neighbor);\n            }\n\n            x = neighbor.x;\n            y = neighbor.y;\n\n            // get the distance between current node and the neighbor\n            // and calculate the next g score\n            ng = node.g + neighbor.cost + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);\n\n            // check if the neighbor has not been inspected yet, or\n            // can be reached with smaller cost from the current node\n            if (!neighbor.opened || ng < neighbor.g) {\n                neighbor.g = ng;\n                neighbor.h = neighbor.h || weight * heuristic(abs(x - endX), abs(y - endY));\n                neighbor.f = neighbor.g + neighbor.h;\n                neighbor.parent = node;\n\n                if (!neighbor.opened) {\n                    startOpenList.push(neighbor);\n                    neighbor.opened = BY_START;\n                } else {\n                    // the neighbor can be reached with smaller cost.\n                    // Since its f value has been updated, we have to\n                    // update its position in the open list\n                    startOpenList.updateItem(neighbor);\n                }\n            }\n        } // end for each neighbor\n\n\n        // pop the position of end node which has the minimum `f` value.\n        node = endOpenList.pop();\n        node.closed = true;\n\n        // get neigbours of the current node\n        neighbors = grid.getNeighbors(node, diagonalMovement);\n        for (i = 0, l = neighbors.length; i < l; ++i) {\n            neighbor = neighbors[i];\n\n            if (neighbor.closed) {\n                continue;\n            }\n            if (neighbor.opened === BY_START) {\n                return Util.biBacktrace(neighbor, node);\n            }\n\n            x = neighbor.x;\n            y = neighbor.y;\n\n            // get the distance between current node and the neighbor\n            // and calculate the next g score\n            ng = node.g + neighbor.cost + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);\n\n            // check if the neighbor has not been inspected yet, or\n            // can be reached with smaller cost from the current node\n            if (!neighbor.opened || ng < neighbor.g) {\n                neighbor.g = ng;\n                neighbor.h = neighbor.h || weight * heuristic(abs(x - startX), abs(y - startY));\n                neighbor.f = neighbor.g + neighbor.h;\n                neighbor.parent = node;\n\n                if (!neighbor.opened) {\n                    endOpenList.push(neighbor);\n                    neighbor.opened = BY_END;\n                } else {\n                    // the neighbor can be reached with smaller cost.\n                    // Since its f value has been updated, we have to\n                    // update its position in the open list\n                    endOpenList.updateItem(neighbor);\n                }\n            }\n        } // end for each neighbor\n    } // end while not open list empty\n\n    // fail to find the path\n    return [];\n};\n\nmodule.exports = BiAStarFinder;\n","var BiAStarFinder = require('./BiAStarFinder');\n\n/**\n * Bi-direcitional Best-First-Search path-finder.\n * @constructor\n * @extends BiAStarFinder\n * @param {object} opt\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed. Deprecated, use diagonalMovement instead.\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching block corners. Deprecated, use diagonalMovement instead.\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\n * @param {function} opt.heuristic Heuristic function to estimate the distance\n *     (defaults to manhattan).\n */\nfunction BiBestFirstFinder(opt) {\n    BiAStarFinder.call(this, opt);\n\n    var orig = this.heuristic;\n    this.heuristic = function(dx, dy) {\n        return orig(dx, dy) * 1000000;\n    };\n}\n\nBiBestFirstFinder.prototype = new BiAStarFinder();\nBiBestFirstFinder.prototype.constructor = BiBestFirstFinder;\n\nmodule.exports = BiBestFirstFinder;\n","var Util = require('../core/Util');\nvar DiagonalMovement = require('../core/DiagonalMovement');\n\n/**\n * Bi-directional Breadth-First-Search path finder.\n * @constructor\n * @param {object} opt\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed. Deprecated, use diagonalMovement instead.\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching block corners. Deprecated, use diagonalMovement instead.\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\n */\nfunction BiBreadthFirstFinder(opt) {\n    opt = opt || {};\n    this.allowDiagonal = opt.allowDiagonal;\n    this.dontCrossCorners = opt.dontCrossCorners;\n    this.diagonalMovement = opt.diagonalMovement;\n\n    if (!this.diagonalMovement) {\n        if (!this.allowDiagonal) {\n            this.diagonalMovement = DiagonalMovement.Never;\n        } else {\n            if (this.dontCrossCorners) {\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\n            } else {\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\n            }\n        }\n    }\n}\n\n\n/**\n * Find and return the the path.\n * @return {Array.<[number, number]>} The path, including both start and\n *     end positions.\n */\nBiBreadthFirstFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\n    var startNode = grid.getNodeAt(startX, startY),\n        endNode = grid.getNodeAt(endX, endY),\n        startOpenList = [], endOpenList = [],\n        neighbors, neighbor, node,\n        diagonalMovement = this.diagonalMovement,\n        BY_START = 0, BY_END = 1,\n        i, l;\n\n    // push the start and end nodes into the queues\n    startOpenList.push(startNode);\n    startNode.opened = true;\n    startNode.by = BY_START;\n\n    endOpenList.push(endNode);\n    endNode.opened = true;\n    endNode.by = BY_END;\n\n    // while both the queues are not empty\n    while (startOpenList.length && endOpenList.length) {\n\n        // expand start open list\n\n        node = startOpenList.shift();\n        node.closed = true;\n\n        neighbors = grid.getNeighbors(node, diagonalMovement);\n        for (i = 0, l = neighbors.length; i < l; ++i) {\n            neighbor = neighbors[i];\n\n            if (neighbor.closed) {\n                continue;\n            }\n            if (neighbor.opened) {\n                // if this node has been inspected by the reversed search,\n                // then a path is found.\n                if (neighbor.by === BY_END) {\n                    return Util.biBacktrace(node, neighbor);\n                }\n                continue;\n            }\n            startOpenList.push(neighbor);\n            neighbor.parent = node;\n            neighbor.opened = true;\n            neighbor.by = BY_START;\n        }\n\n        // expand end open list\n\n        node = endOpenList.shift();\n        node.closed = true;\n\n        neighbors = grid.getNeighbors(node, diagonalMovement);\n        for (i = 0, l = neighbors.length; i < l; ++i) {\n            neighbor = neighbors[i];\n\n            if (neighbor.closed) {\n                continue;\n            }\n            if (neighbor.opened) {\n                if (neighbor.by === BY_START) {\n                    return Util.biBacktrace(neighbor, node);\n                }\n                continue;\n            }\n            endOpenList.push(neighbor);\n            neighbor.parent = node;\n            neighbor.opened = true;\n            neighbor.by = BY_END;\n        }\n    }\n\n    // fail to find the path\n    return [];\n};\n\nmodule.exports = BiBreadthFirstFinder;\n","var BiAStarFinder = require('./BiAStarFinder');\n\n/**\n * Bi-directional Dijkstra path-finder.\n * @constructor\n * @extends BiAStarFinder\n * @param {object} opt\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed. Deprecated, use diagonalMovement instead.\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching block corners. Deprecated, use diagonalMovement instead.\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\n */\nfunction BiDijkstraFinder(opt) {\n    BiAStarFinder.call(this, opt);\n    this.heuristic = function(dx, dy) {\n        return 0;\n    };\n}\n\nBiDijkstraFinder.prototype = new BiAStarFinder();\nBiDijkstraFinder.prototype.constructor = BiDijkstraFinder;\n\nmodule.exports = BiDijkstraFinder;\n","var Util = require('../core/Util');\nvar DiagonalMovement = require('../core/DiagonalMovement');\n\n/**\n * Breadth-First-Search path finder.\n * @constructor\n * @param {object} opt\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed. Deprecated, use diagonalMovement instead.\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching block corners. Deprecated, use diagonalMovement instead.\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\n */\nfunction BreadthFirstFinder(opt) {\n    opt = opt || {};\n    this.allowDiagonal = opt.allowDiagonal;\n    this.dontCrossCorners = opt.dontCrossCorners;\n    this.diagonalMovement = opt.diagonalMovement;\n\n    if (!this.diagonalMovement) {\n        if (!this.allowDiagonal) {\n            this.diagonalMovement = DiagonalMovement.Never;\n        } else {\n            if (this.dontCrossCorners) {\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\n            } else {\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\n            }\n        }\n    }\n}\n\n/**\n * Find and return the the path.\n * @return {Array.<[number, number]>} The path, including both start and\n *     end positions.\n */\nBreadthFirstFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\n    var openList = [],\n        diagonalMovement = this.diagonalMovement,\n        startNode = grid.getNodeAt(startX, startY),\n        endNode = grid.getNodeAt(endX, endY),\n        neighbors, neighbor, node, i, l;\n\n    // push the start pos into the queue\n    openList.push(startNode);\n    startNode.opened = true;\n\n    // while the queue is not empty\n    while (openList.length) {\n        // take the front node from the queue\n        node = openList.shift();\n        node.closed = true;\n\n        // reached the end position\n        if (node === endNode) {\n            return Util.backtrace(endNode);\n        }\n\n        neighbors = grid.getNeighbors(node, diagonalMovement);\n        for (i = 0, l = neighbors.length; i < l; ++i) {\n            neighbor = neighbors[i];\n\n            // skip this neighbor if it has been inspected before\n            if (neighbor.closed || neighbor.opened) {\n                continue;\n            }\n\n            openList.push(neighbor);\n            neighbor.opened = true;\n            neighbor.parent = node;\n        }\n    }\n    \n    // fail to find the path\n    return [];\n};\n\nmodule.exports = BreadthFirstFinder;\n","var AStarFinder = require('./AStarFinder');\n\n/**\n * Dijkstra path-finder.\n * @constructor\n * @extends AStarFinder\n * @param {object} opt\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed. Deprecated, use diagonalMovement instead.\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching block corners. Deprecated, use diagonalMovement instead.\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\n */\nfunction DijkstraFinder(opt) {\n    AStarFinder.call(this, opt);\n    this.heuristic = function(dx, dy) {\n        return 0;\n    };\n}\n\nDijkstraFinder.prototype = new AStarFinder();\nDijkstraFinder.prototype.constructor = DijkstraFinder;\n\nmodule.exports = DijkstraFinder;\n","var Util       = require('../core/Util');\nvar Heuristic  = require('../core/Heuristic');\nvar Node       = require('../core/Node');\nvar DiagonalMovement = require('../core/DiagonalMovement');\n\n/**\n * Iterative Deeping A Star (IDA*) path-finder.\n *\n * Recursion based on:\n *   http://www.apl.jhu.edu/~hall/AI-Programming/IDA-Star.html\n *\n * Path retracing based on:\n *  V. Nageshwara Rao, Vipin Kumar and K. Ramesh\n *  \"A Parallel Implementation of Iterative-Deeping-A*\", January 1987.\n *  ftp://ftp.cs.utexas.edu/.snapshot/hourly.1/pub/AI-Lab/tech-reports/UT-AI-TR-87-46.pdf\n *\n * @author Gerard Meier (www.gerardmeier.com)\n *\n * @constructor\n * @param {object} opt\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed. Deprecated, use diagonalMovement instead.\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching block corners. Deprecated, use diagonalMovement instead.\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\n * @param {function} opt.heuristic Heuristic function to estimate the distance\n *     (defaults to manhattan).\n * @param {integer} opt.weight Weight to apply to the heuristic to allow for suboptimal paths,\n *     in order to speed up the search.\n * @param {object} opt.trackRecursion Whether to track recursion for statistical purposes.\n * @param {object} opt.timeLimit Maximum execution time. Use <= 0 for infinite.\n */\n\nfunction IDAStarFinder(opt) {\n    opt = opt || {};\n    this.allowDiagonal = opt.allowDiagonal;\n    this.dontCrossCorners = opt.dontCrossCorners;\n    this.diagonalMovement = opt.diagonalMovement;\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\n    this.weight = opt.weight || 1;\n    this.trackRecursion = opt.trackRecursion || false;\n    this.timeLimit = opt.timeLimit || Infinity; // Default: no time limit.\n\n    if (!this.diagonalMovement) {\n        if (!this.allowDiagonal) {\n            this.diagonalMovement = DiagonalMovement.Never;\n        } else {\n            if (this.dontCrossCorners) {\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\n            } else {\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\n            }\n        }\n    }\n\n    //When diagonal movement is allowed the manhattan heuristic is not admissible\n    //It should be octile instead\n    if (this.diagonalMovement === DiagonalMovement.Never) {\n        this.heuristic = opt.heuristic || Heuristic.manhattan;\n    } else {\n        this.heuristic = opt.heuristic || Heuristic.octile;\n    }\n}\n\n/**\n * Find and return the the path. When an empty array is returned, either\n * no path is possible, or the maximum execution time is reached.\n *\n * @return {Array.<[number, number]>} The path, including both start and\n *     end positions.\n */\nIDAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\n    // Used for statistics:\n    var nodesVisited = 0;\n\n    // Execution time limitation:\n    var startTime = new Date().getTime();\n\n    // Heuristic helper:\n    var h = function(a, b) {\n        return this.heuristic(Math.abs(b.x - a.x), Math.abs(b.y - a.y));\n    }.bind(this);\n\n    // Step cost from a to b:\n    var cost = function(a, b) {\n        return (a.x === b.x || a.y === b.y) ? 1 : Math.SQRT2;\n    };\n\n    /**\n     * IDA* search implementation.\n     *\n     * @param {Node} The node currently expanding from.\n     * @param {number} Cost to reach the given node.\n     * @param {number} Maximum search depth (cut-off value).\n     * @param {{Array.<[number, number]>}} The found route.\n     * @param {number} Recursion depth.\n     *\n     * @return {Object} either a number with the new optimal cut-off depth,\n     * or a valid node instance, in which case a path was found.\n     */\n    var search = function(node, g, cutoff, route, depth) {\n        nodesVisited++;\n\n        // Enforce timelimit:\n        if(this.timeLimit > 0 && new Date().getTime() - startTime > this.timeLimit * 1000) {\n            // Enforced as \"path-not-found\".\n            return Infinity;\n        }\n\n        var f = g + h(node, end) * this.weight;\n\n        // We've searched too deep for this iteration.\n        if(f > cutoff) {\n            return f;\n        }\n\n        if(node == end) {\n            route[depth] = [node.x, node.y];\n            return node;\n        }\n\n        var min, t, k, neighbour;\n\n        var neighbours = grid.getNeighbors(node, this.diagonalMovement);\n\n        // Sort the neighbours, gives nicer paths. But, this deviates\n        // from the original algorithm - so I left it out.\n        //neighbours.sort(function(a, b){\n        //    return h(a, end) - h(b, end);\n        //});\n\n        \n        /*jshint -W084 *///Disable warning: Expected a conditional expression and instead saw an assignment\n        for(k = 0, min = Infinity; neighbour = neighbours[k]; ++k) {\n        /*jshint +W084 *///Enable warning: Expected a conditional expression and instead saw an assignment\n            if(this.trackRecursion) {\n                // Retain a copy for visualisation. Due to recursion, this\n                // node may be part of other paths too.\n                neighbour.retainCount = neighbour.retainCount + 1 || 1;\n\n                if(neighbour.tested !== true) {\n                    neighbour.tested = true;\n                }\n            }\n\n            t = search(neighbour, g + cost(node, neighbour), cutoff, route, depth + 1);\n\n            if(t instanceof Node) {\n                route[depth] = [node.x, node.y];\n\n                // For a typical A* linked list, this would work:\n                // neighbour.parent = node;\n                return t;\n            }\n\n            // Decrement count, then determine whether it's actually closed.\n            if(this.trackRecursion && (--neighbour.retainCount) === 0) {\n                neighbour.tested = false;\n            }\n\n            if(t < min) {\n                min = t;\n            }\n        }\n\n        return min;\n\n    }.bind(this);\n\n    // Node instance lookups:\n    var start = grid.getNodeAt(startX, startY);\n    var end   = grid.getNodeAt(endX, endY);\n\n    // Initial search depth, given the typical heuristic contraints,\n    // there should be no cheaper route possible.\n    var cutOff = h(start, end);\n\n    var j, route, t;\n\n    // With an overflow protection.\n    for(j = 0; true; ++j) {\n        //console.log(\"Iteration: \" + j + \", search cut-off value: \" + cutOff + \", nodes visited thus far: \" + nodesVisited + \".\");\n\n        route = [];\n\n        // Search till cut-off depth:\n        t = search(start, 0, cutOff, route, 0);\n\n        // Route not possible, or not found in time limit.\n        if(t === Infinity) {\n            return [];\n        }\n\n        // If t is a node, it's also the end node. Route is now\n        // populated with a valid path to the end node.\n        if(t instanceof Node) {\n            //console.log(\"Finished at iteration: \" + j + \", search cut-off value: \" + cutOff + \", nodes visited: \" + nodesVisited + \".\");\n            return route;\n        }\n\n        // Try again, this time with a deeper cut-off. The t score\n        // is the closest we got to the end node.\n        cutOff = t;\n    }\n\n    // This _should_ never to be reached.\n    return [];\n};\n\nmodule.exports = IDAStarFinder;\n","/**\n * @author imor / https://github.com/imor\n */\nvar JumpPointFinderBase = require('./JumpPointFinderBase');\nvar DiagonalMovement = require('../core/DiagonalMovement');\n\n/**\n * Path finder using the Jump Point Search algorithm which always moves\n * diagonally irrespective of the number of obstacles.\n */\nfunction JPFAlwaysMoveDiagonally(opt) {\n    JumpPointFinderBase.call(this, opt);\n}\n\nJPFAlwaysMoveDiagonally.prototype = new JumpPointFinderBase();\nJPFAlwaysMoveDiagonally.prototype.constructor = JPFAlwaysMoveDiagonally;\n\n/**\n * Search recursively in the direction (parent -> child), stopping only when a\n * jump point is found.\n * @protected\n * @return {Array.<[number, number]>} The x, y coordinate of the jump point\n *     found, or null if not found\n */\nJPFAlwaysMoveDiagonally.prototype._jump = function(x, y, px, py) {\n    var grid = this.grid,\n        dx = x - px, dy = y - py;\n\n    if (!grid.isWalkableAt(x, y)) {\n        return null;\n    }\n\n    if(this.trackJumpRecursion === true) {\n        grid.getNodeAt(x, y).tested = true;\n    }\n\n    if (grid.getNodeAt(x, y) === this.endNode) {\n        return [x, y];\n    }\n\n    // check for forced neighbors\n    // along the diagonal\n    if (dx !== 0 && dy !== 0) {\n        if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||\n            (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {\n            return [x, y];\n        }\n        // when moving diagonally, must check for vertical/horizontal jump points\n        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {\n            return [x, y];\n        }\n    }\n    // horizontally/vertically\n    else {\n        if( dx !== 0 ) { // moving along x\n            if((grid.isWalkableAt(x + dx, y + 1) && !grid.isWalkableAt(x, y + 1)) ||\n               (grid.isWalkableAt(x + dx, y - 1) && !grid.isWalkableAt(x, y - 1))) {\n                return [x, y];\n            }\n        }\n        else {\n            if((grid.isWalkableAt(x + 1, y + dy) && !grid.isWalkableAt(x + 1, y)) ||\n               (grid.isWalkableAt(x - 1, y + dy) && !grid.isWalkableAt(x - 1, y))) {\n                return [x, y];\n            }\n        }\n    }\n\n    return this._jump(x + dx, y + dy, x, y);\n};\n\n/**\n * Find the neighbors for the given node. If the node has a parent,\n * prune the neighbors based on the jump point search algorithm, otherwise\n * return all available neighbors.\n * @return {Array.<[number, number]>} The neighbors found.\n */\nJPFAlwaysMoveDiagonally.prototype._findNeighbors = function(node) {\n    var parent = node.parent,\n        x = node.x, y = node.y,\n        grid = this.grid,\n        px, py, nx, ny, dx, dy,\n        neighbors = [], neighborNodes, neighborNode, i, l;\n\n    // directed pruning: can ignore most neighbors, unless forced.\n    if (parent) {\n        px = parent.x;\n        py = parent.y;\n        // get the normalized direction of travel\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\n\n        // search diagonally\n        if (dx !== 0 && dy !== 0) {\n            if (grid.isWalkableAt(x, y + dy)) {\n                neighbors.push([x, y + dy]);\n            }\n            if (grid.isWalkableAt(x + dx, y)) {\n                neighbors.push([x + dx, y]);\n            }\n            if (grid.isWalkableAt(x + dx, y + dy)) {\n                neighbors.push([x + dx, y + dy]);\n            }\n            if (!grid.isWalkableAt(x - dx, y)) {\n                neighbors.push([x - dx, y + dy]);\n            }\n            if (!grid.isWalkableAt(x, y - dy)) {\n                neighbors.push([x + dx, y - dy]);\n            }\n        }\n        // search horizontally/vertically\n        else {\n            if(dx === 0) {\n                if (grid.isWalkableAt(x, y + dy)) {\n                    neighbors.push([x, y + dy]);\n                }\n                if (!grid.isWalkableAt(x + 1, y)) {\n                    neighbors.push([x + 1, y + dy]);\n                }\n                if (!grid.isWalkableAt(x - 1, y)) {\n                    neighbors.push([x - 1, y + dy]);\n                }\n            }\n            else {\n                if (grid.isWalkableAt(x + dx, y)) {\n                    neighbors.push([x + dx, y]);\n                }\n                if (!grid.isWalkableAt(x, y + 1)) {\n                    neighbors.push([x + dx, y + 1]);\n                }\n                if (!grid.isWalkableAt(x, y - 1)) {\n                    neighbors.push([x + dx, y - 1]);\n                }\n            }\n        }\n    }\n    // return all neighbors\n    else {\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.Always);\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\n            neighborNode = neighborNodes[i];\n            neighbors.push([neighborNode.x, neighborNode.y]);\n        }\n    }\n\n    return neighbors;\n};\n\nmodule.exports = JPFAlwaysMoveDiagonally;\n","/**\n * @author imor / https://github.com/imor\n */\nvar JumpPointFinderBase = require('./JumpPointFinderBase');\nvar DiagonalMovement = require('../core/DiagonalMovement');\n\n/**\n * Path finder using the Jump Point Search algorithm which moves\n * diagonally only when there is at most one obstacle.\n */\nfunction JPFMoveDiagonallyIfAtMostOneObstacle(opt) {\n    JumpPointFinderBase.call(this, opt);\n}\n\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype = new JumpPointFinderBase();\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype.constructor = JPFMoveDiagonallyIfAtMostOneObstacle;\n\n/**\n * Search recursively in the direction (parent -> child), stopping only when a\n * jump point is found.\n * @protected\n * @return {Array.<[number, number]>} The x, y coordinate of the jump point\n *     found, or null if not found\n */\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype._jump = function(x, y, px, py) {\n    var grid = this.grid,\n        dx = x - px, dy = y - py;\n\n    if (!grid.isWalkableAt(x, y)) {\n        return null;\n    }\n\n    if(this.trackJumpRecursion === true) {\n        grid.getNodeAt(x, y).tested = true;\n    }\n\n    if (grid.getNodeAt(x, y) === this.endNode) {\n        return [x, y];\n    }\n\n    // check for forced neighbors\n    // along the diagonal\n    if (dx !== 0 && dy !== 0) {\n        if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||\n            (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {\n            return [x, y];\n        }\n        // when moving diagonally, must check for vertical/horizontal jump points\n        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {\n            return [x, y];\n        }\n    }\n    // horizontally/vertically\n    else {\n        if( dx !== 0 ) { // moving along x\n            if((grid.isWalkableAt(x + dx, y + 1) && !grid.isWalkableAt(x, y + 1)) ||\n               (grid.isWalkableAt(x + dx, y - 1) && !grid.isWalkableAt(x, y - 1))) {\n                return [x, y];\n            }\n        }\n        else {\n            if((grid.isWalkableAt(x + 1, y + dy) && !grid.isWalkableAt(x + 1, y)) ||\n               (grid.isWalkableAt(x - 1, y + dy) && !grid.isWalkableAt(x - 1, y))) {\n                return [x, y];\n            }\n        }\n    }\n\n    // moving diagonally, must make sure one of the vertical/horizontal\n    // neighbors is open to allow the path\n    if (grid.isWalkableAt(x + dx, y) || grid.isWalkableAt(x, y + dy)) {\n        return this._jump(x + dx, y + dy, x, y);\n    } else {\n        return null;\n    }\n};\n\n/**\n * Find the neighbors for the given node. If the node has a parent,\n * prune the neighbors based on the jump point search algorithm, otherwise\n * return all available neighbors.\n * @return {Array.<[number, number]>} The neighbors found.\n */\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype._findNeighbors = function(node) {\n    var parent = node.parent,\n        x = node.x, y = node.y,\n        grid = this.grid,\n        px, py, nx, ny, dx, dy,\n        neighbors = [], neighborNodes, neighborNode, i, l;\n\n    // directed pruning: can ignore most neighbors, unless forced.\n    if (parent) {\n        px = parent.x;\n        py = parent.y;\n        // get the normalized direction of travel\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\n\n        // search diagonally\n        if (dx !== 0 && dy !== 0) {\n            if (grid.isWalkableAt(x, y + dy)) {\n                neighbors.push([x, y + dy]);\n            }\n            if (grid.isWalkableAt(x + dx, y)) {\n                neighbors.push([x + dx, y]);\n            }\n            if (grid.isWalkableAt(x, y + dy) || grid.isWalkableAt(x + dx, y)) {\n                neighbors.push([x + dx, y + dy]);\n            }\n            if (!grid.isWalkableAt(x - dx, y) && grid.isWalkableAt(x, y + dy)) {\n                neighbors.push([x - dx, y + dy]);\n            }\n            if (!grid.isWalkableAt(x, y - dy) && grid.isWalkableAt(x + dx, y)) {\n                neighbors.push([x + dx, y - dy]);\n            }\n        }\n        // search horizontally/vertically\n        else {\n            if(dx === 0) {\n                if (grid.isWalkableAt(x, y + dy)) {\n                    neighbors.push([x, y + dy]);\n                    if (!grid.isWalkableAt(x + 1, y)) {\n                        neighbors.push([x + 1, y + dy]);\n                    }\n                    if (!grid.isWalkableAt(x - 1, y)) {\n                        neighbors.push([x - 1, y + dy]);\n                    }\n                }\n            }\n            else {\n                if (grid.isWalkableAt(x + dx, y)) {\n                    neighbors.push([x + dx, y]);\n                    if (!grid.isWalkableAt(x, y + 1)) {\n                        neighbors.push([x + dx, y + 1]);\n                    }\n                    if (!grid.isWalkableAt(x, y - 1)) {\n                        neighbors.push([x + dx, y - 1]);\n                    }\n                }\n            }\n        }\n    }\n    // return all neighbors\n    else {\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.IfAtMostOneObstacle);\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\n            neighborNode = neighborNodes[i];\n            neighbors.push([neighborNode.x, neighborNode.y]);\n        }\n    }\n\n    return neighbors;\n};\n\nmodule.exports = JPFMoveDiagonallyIfAtMostOneObstacle;\n","/**\n * @author imor / https://github.com/imor\n */\nvar JumpPointFinderBase = require('./JumpPointFinderBase');\nvar DiagonalMovement = require('../core/DiagonalMovement');\n\n/**\n * Path finder using the Jump Point Search algorithm which moves\n * diagonally only when there are no obstacles.\n */\nfunction JPFMoveDiagonallyIfNoObstacles(opt) {\n    JumpPointFinderBase.call(this, opt);\n}\n\nJPFMoveDiagonallyIfNoObstacles.prototype = new JumpPointFinderBase();\nJPFMoveDiagonallyIfNoObstacles.prototype.constructor = JPFMoveDiagonallyIfNoObstacles;\n\n/**\n * Search recursively in the direction (parent -> child), stopping only when a\n * jump point is found.\n * @protected\n * @return {Array.<[number, number]>} The x, y coordinate of the jump point\n *     found, or null if not found\n */\nJPFMoveDiagonallyIfNoObstacles.prototype._jump = function(x, y, px, py) {\n    var grid = this.grid,\n        dx = x - px, dy = y - py;\n\n    if (!grid.isWalkableAt(x, y)) {\n        return null;\n    }\n\n    if(this.trackJumpRecursion === true) {\n        grid.getNodeAt(x, y).tested = true;\n    }\n\n    if (grid.getNodeAt(x, y) === this.endNode) {\n        return [x, y];\n    }\n\n    // check for forced neighbors\n    // along the diagonal\n    if (dx !== 0 && dy !== 0) {\n        // if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||\n            // (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {\n            // return [x, y];\n        // }\n        // when moving diagonally, must check for vertical/horizontal jump points\n        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {\n            return [x, y];\n        }\n    }\n    // horizontally/vertically\n    else {\n        if (dx !== 0) {\n            if ((grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1)) ||\n                (grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1))) {\n                return [x, y];\n            }\n        }\n        else if (dy !== 0) {\n            if ((grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy)) ||\n                (grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy))) {\n                return [x, y];\n            }\n            // When moving vertically, must check for horizontal jump points\n            // if (this._jump(x + 1, y, x, y) || this._jump(x - 1, y, x, y)) {\n                // return [x, y];\n            // }\n        }\n    }\n\n    // moving diagonally, must make sure one of the vertical/horizontal\n    // neighbors is open to allow the path\n    if (grid.isWalkableAt(x + dx, y) && grid.isWalkableAt(x, y + dy)) {\n        return this._jump(x + dx, y + dy, x, y);\n    } else {\n        return null;\n    }\n};\n\n/**\n * Find the neighbors for the given node. If the node has a parent,\n * prune the neighbors based on the jump point search algorithm, otherwise\n * return all available neighbors.\n * @return {Array.<[number, number]>} The neighbors found.\n */\nJPFMoveDiagonallyIfNoObstacles.prototype._findNeighbors = function(node) {\n    var parent = node.parent,\n        x = node.x, y = node.y,\n        grid = this.grid,\n        px, py, nx, ny, dx, dy,\n        neighbors = [], neighborNodes, neighborNode, i, l;\n\n    // directed pruning: can ignore most neighbors, unless forced.\n    if (parent) {\n        px = parent.x;\n        py = parent.y;\n        // get the normalized direction of travel\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\n\n        // search diagonally\n        if (dx !== 0 && dy !== 0) {\n            if (grid.isWalkableAt(x, y + dy)) {\n                neighbors.push([x, y + dy]);\n            }\n            if (grid.isWalkableAt(x + dx, y)) {\n                neighbors.push([x + dx, y]);\n            }\n            if (grid.isWalkableAt(x, y + dy) && grid.isWalkableAt(x + dx, y)) {\n                neighbors.push([x + dx, y + dy]);\n            }\n        }\n        // search horizontally/vertically\n        else {\n            var isNextWalkable;\n            if (dx !== 0) {\n                isNextWalkable = grid.isWalkableAt(x + dx, y);\n                var isTopWalkable = grid.isWalkableAt(x, y + 1);\n                var isBottomWalkable = grid.isWalkableAt(x, y - 1);\n\n                if (isNextWalkable) {\n                    neighbors.push([x + dx, y]);\n                    if (isTopWalkable) {\n                        neighbors.push([x + dx, y + 1]);\n                    }\n                    if (isBottomWalkable) {\n                        neighbors.push([x + dx, y - 1]);\n                    }\n                }\n                if (isTopWalkable) {\n                    neighbors.push([x, y + 1]);\n                }\n                if (isBottomWalkable) {\n                    neighbors.push([x, y - 1]);\n                }\n            }\n            else if (dy !== 0) {\n                isNextWalkable = grid.isWalkableAt(x, y + dy);\n                var isRightWalkable = grid.isWalkableAt(x + 1, y);\n                var isLeftWalkable = grid.isWalkableAt(x - 1, y);\n\n                if (isNextWalkable) {\n                    neighbors.push([x, y + dy]);\n                    if (isRightWalkable) {\n                        neighbors.push([x + 1, y + dy]);\n                    }\n                    if (isLeftWalkable) {\n                        neighbors.push([x - 1, y + dy]);\n                    }\n                }\n                if (isRightWalkable) {\n                    neighbors.push([x + 1, y]);\n                }\n                if (isLeftWalkable) {\n                    neighbors.push([x - 1, y]);\n                }\n            }\n        }\n    }\n    // return all neighbors\n    else {\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.OnlyWhenNoObstacles);\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\n            neighborNode = neighborNodes[i];\n            neighbors.push([neighborNode.x, neighborNode.y]);\n        }\n    }\n\n    return neighbors;\n};\n\nmodule.exports = JPFMoveDiagonallyIfNoObstacles;\n","/**\n * @author imor / https://github.com/imor\n */\nvar JumpPointFinderBase = require('./JumpPointFinderBase');\nvar DiagonalMovement = require('../core/DiagonalMovement');\n\n/**\n * Path finder using the Jump Point Search algorithm allowing only horizontal\n * or vertical movements.\n */\nfunction JPFNeverMoveDiagonally(opt) {\n    JumpPointFinderBase.call(this, opt);\n}\n\nJPFNeverMoveDiagonally.prototype = new JumpPointFinderBase();\nJPFNeverMoveDiagonally.prototype.constructor = JPFNeverMoveDiagonally;\n\n/**\n * Search recursively in the direction (parent -> child), stopping only when a\n * jump point is found.\n * @protected\n * @return {Array.<[number, number]>} The x, y coordinate of the jump point\n *     found, or null if not found\n */\nJPFNeverMoveDiagonally.prototype._jump = function(x, y, px, py) {\n    var grid = this.grid,\n        dx = x - px, dy = y - py;\n\n    if (!grid.isWalkableAt(x, y)) {\n        return null;\n    }\n\n    if(this.trackJumpRecursion === true) {\n        grid.getNodeAt(x, y).tested = true;\n    }\n\n    if (grid.getNodeAt(x, y) === this.endNode) {\n        return [x, y];\n    }\n\n    if (dx !== 0) {\n        if ((grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1)) ||\n            (grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1))) {\n            return [x, y];\n        }\n    }\n    else if (dy !== 0) {\n        if ((grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy)) ||\n            (grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy))) {\n            return [x, y];\n        }\n        //When moving vertically, must check for horizontal jump points\n        if (this._jump(x + 1, y, x, y) || this._jump(x - 1, y, x, y)) {\n            return [x, y];\n        }\n    }\n    else {\n        throw new Error(\"Only horizontal and vertical movements are allowed\");\n    }\n\n    return this._jump(x + dx, y + dy, x, y);\n};\n\n/**\n * Find the neighbors for the given node. If the node has a parent,\n * prune the neighbors based on the jump point search algorithm, otherwise\n * return all available neighbors.\n * @return {Array.<[number, number]>} The neighbors found.\n */\nJPFNeverMoveDiagonally.prototype._findNeighbors = function(node) {\n    var parent = node.parent,\n        x = node.x, y = node.y,\n        grid = this.grid,\n        px, py, nx, ny, dx, dy,\n        neighbors = [], neighborNodes, neighborNode, i, l;\n\n    // directed pruning: can ignore most neighbors, unless forced.\n    if (parent) {\n        px = parent.x;\n        py = parent.y;\n        // get the normalized direction of travel\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\n\n        if (dx !== 0) {\n            if (grid.isWalkableAt(x, y - 1)) {\n                neighbors.push([x, y - 1]);\n            }\n            if (grid.isWalkableAt(x, y + 1)) {\n                neighbors.push([x, y + 1]);\n            }\n            if (grid.isWalkableAt(x + dx, y)) {\n                neighbors.push([x + dx, y]);\n            }\n        }\n        else if (dy !== 0) {\n            if (grid.isWalkableAt(x - 1, y)) {\n                neighbors.push([x - 1, y]);\n            }\n            if (grid.isWalkableAt(x + 1, y)) {\n                neighbors.push([x + 1, y]);\n            }\n            if (grid.isWalkableAt(x, y + dy)) {\n                neighbors.push([x, y + dy]);\n            }\n        }\n    }\n    // return all neighbors\n    else {\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.Never);\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\n            neighborNode = neighborNodes[i];\n            neighbors.push([neighborNode.x, neighborNode.y]);\n        }\n    }\n\n    return neighbors;\n};\n\nmodule.exports = JPFNeverMoveDiagonally;\n","/**\n * @author aniero / https://github.com/aniero\n */\nvar DiagonalMovement = require('../core/DiagonalMovement');\nvar JPFNeverMoveDiagonally = require('./JPFNeverMoveDiagonally');\nvar JPFAlwaysMoveDiagonally = require('./JPFAlwaysMoveDiagonally');\nvar JPFMoveDiagonallyIfNoObstacles = require('./JPFMoveDiagonallyIfNoObstacles');\nvar JPFMoveDiagonallyIfAtMostOneObstacle = require('./JPFMoveDiagonallyIfAtMostOneObstacle');\n\n/**\n * Path finder using the Jump Point Search algorithm\n * @param {object} opt\n * @param {function} opt.heuristic Heuristic function to estimate the distance\n *     (defaults to manhattan).\n * @param {DiagonalMovement} opt.diagonalMovement Condition under which diagonal\n *      movement will be allowed.\n */\nfunction JumpPointFinder(opt) {\n    opt = opt || {};\n    if (opt.diagonalMovement === DiagonalMovement.Never) {\n        return new JPFNeverMoveDiagonally(opt);\n    } else if (opt.diagonalMovement === DiagonalMovement.Always) {\n        return new JPFAlwaysMoveDiagonally(opt);\n    } else if (opt.diagonalMovement === DiagonalMovement.OnlyWhenNoObstacles) {\n        return new JPFMoveDiagonallyIfNoObstacles(opt);\n    } else {\n        return new JPFMoveDiagonallyIfAtMostOneObstacle(opt);\n    }\n}\n\nmodule.exports = JumpPointFinder;\n","/**\n * @author imor / https://github.com/imor\n */\nvar Heap       = require('heap');\nvar Util       = require('../core/Util');\nvar Heuristic  = require('../core/Heuristic');\nvar DiagonalMovement = require('../core/DiagonalMovement');\n\n/**\n * Base class for the Jump Point Search algorithm\n * @param {object} opt\n * @param {function} opt.heuristic Heuristic function to estimate the distance\n *     (defaults to manhattan).\n */\nfunction JumpPointFinderBase(opt) {\n    opt = opt || {};\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\n    this.trackJumpRecursion = opt.trackJumpRecursion || false;\n}\n\n/**\n * Find and return the path.\n * @return {Array.<[number, number]>} The path, including both start and\n *     end positions.\n */\nJumpPointFinderBase.prototype.findPath = function(startX, startY, endX, endY, grid) {\n    var openList = this.openList = new Heap(function(nodeA, nodeB) {\n            return nodeA.f - nodeB.f;\n        }),\n        startNode = this.startNode = grid.getNodeAt(startX, startY),\n        endNode = this.endNode = grid.getNodeAt(endX, endY), node;\n\n    this.grid = grid;\n\n\n    // set the `g` and `f` value of the start node to be 0\n    startNode.g = 0;\n    startNode.f = 0;\n\n    // push the start node into the open list\n    openList.push(startNode);\n    startNode.opened = true;\n\n    // while the open list is not empty\n    while (!openList.empty()) {\n        // pop the position of node which has the minimum `f` value.\n        node = openList.pop();\n        node.closed = true;\n\n        if (node === endNode) {\n            return Util.expandPath(Util.backtrace(endNode));\n        }\n\n        this._identifySuccessors(node);\n    }\n\n    // fail to find the path\n    return [];\n};\n\n/**\n * Identify successors for the given node. Runs a jump point search in the\n * direction of each available neighbor, adding any points found to the open\n * list.\n * @protected\n */\nJumpPointFinderBase.prototype._identifySuccessors = function(node) {\n    var grid = this.grid,\n        heuristic = this.heuristic,\n        openList = this.openList,\n        endX = this.endNode.x,\n        endY = this.endNode.y,\n        neighbors, neighbor,\n        jumpPoint, i, l,\n        x = node.x, y = node.y,\n        jx, jy, dx, dy, d, ng, jumpNode,\n        abs = Math.abs, max = Math.max;\n\n    neighbors = this._findNeighbors(node);\n    for(i = 0, l = neighbors.length; i < l; ++i) {\n        neighbor = neighbors[i];\n        jumpPoint = this._jump(neighbor[0], neighbor[1], x, y);\n        if (jumpPoint) {\n\n            jx = jumpPoint[0];\n            jy = jumpPoint[1];\n            jumpNode = grid.getNodeAt(jx, jy);\n\n            if (jumpNode.closed) {\n                continue;\n            }\n\n            // include distance, as parent may not be immediately adjacent:\n            d = Heuristic.octile(abs(jx - x), abs(jy - y));\n            ng = node.g + d; // next `g` value\n\n            if (!jumpNode.opened || ng < jumpNode.g) {\n                jumpNode.g = ng;\n                jumpNode.h = jumpNode.h || heuristic(abs(jx - endX), abs(jy - endY));\n                jumpNode.f = jumpNode.g + jumpNode.h;\n                jumpNode.parent = node;\n\n                if (!jumpNode.opened) {\n                    openList.push(jumpNode);\n                    jumpNode.opened = true;\n                } else {\n                    openList.updateItem(jumpNode);\n                }\n            }\n        }\n    }\n};\n\nmodule.exports = JumpPointFinderBase;\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJkaXN0L2xpYi9ncmlkRGlzdGFuY2UuanMiLCJkaXN0L2xpYi9zb3J0ZWRGb29kLmpzIiwiZGlzdC9saWIvd2VpZ2h0LmpzIiwiZGlzdC93ZWIuanMiLCJub2RlX21vZHVsZXMvaGVhcC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9oZWFwL2xpYi9oZWFwLmpzIiwibm9kZV9tb2R1bGVzL3BhdGhmaW5kaW5nL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3BhdGhmaW5kaW5nL3NyYy9QYXRoRmluZGluZy5qcyIsIm5vZGVfbW9kdWxlcy9wYXRoZmluZGluZy9zcmMvY29yZS9EaWFnb25hbE1vdmVtZW50LmpzIiwibm9kZV9tb2R1bGVzL3BhdGhmaW5kaW5nL3NyYy9jb3JlL0dyaWQuanMiLCJub2RlX21vZHVsZXMvcGF0aGZpbmRpbmcvc3JjL2NvcmUvSGV1cmlzdGljLmpzIiwibm9kZV9tb2R1bGVzL3BhdGhmaW5kaW5nL3NyYy9jb3JlL05vZGUuanMiLCJub2RlX21vZHVsZXMvcGF0aGZpbmRpbmcvc3JjL2NvcmUvVXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9wYXRoZmluZGluZy9zcmMvZmluZGVycy9BU3RhckZpbmRlci5qcyIsIm5vZGVfbW9kdWxlcy9wYXRoZmluZGluZy9zcmMvZmluZGVycy9CZXN0Rmlyc3RGaW5kZXIuanMiLCJub2RlX21vZHVsZXMvcGF0aGZpbmRpbmcvc3JjL2ZpbmRlcnMvQmlBU3RhckZpbmRlci5qcyIsIm5vZGVfbW9kdWxlcy9wYXRoZmluZGluZy9zcmMvZmluZGVycy9CaUJlc3RGaXJzdEZpbmRlci5qcyIsIm5vZGVfbW9kdWxlcy9wYXRoZmluZGluZy9zcmMvZmluZGVycy9CaUJyZWFkdGhGaXJzdEZpbmRlci5qcyIsIm5vZGVfbW9kdWxlcy9wYXRoZmluZGluZy9zcmMvZmluZGVycy9CaURpamtzdHJhRmluZGVyLmpzIiwibm9kZV9tb2R1bGVzL3BhdGhmaW5kaW5nL3NyYy9maW5kZXJzL0JyZWFkdGhGaXJzdEZpbmRlci5qcyIsIm5vZGVfbW9kdWxlcy9wYXRoZmluZGluZy9zcmMvZmluZGVycy9EaWprc3RyYUZpbmRlci5qcyIsIm5vZGVfbW9kdWxlcy9wYXRoZmluZGluZy9zcmMvZmluZGVycy9JREFTdGFyRmluZGVyLmpzIiwibm9kZV9tb2R1bGVzL3BhdGhmaW5kaW5nL3NyYy9maW5kZXJzL0pQRkFsd2F5c01vdmVEaWFnb25hbGx5LmpzIiwibm9kZV9tb2R1bGVzL3BhdGhmaW5kaW5nL3NyYy9maW5kZXJzL0pQRk1vdmVEaWFnb25hbGx5SWZBdE1vc3RPbmVPYnN0YWNsZS5qcyIsIm5vZGVfbW9kdWxlcy9wYXRoZmluZGluZy9zcmMvZmluZGVycy9KUEZNb3ZlRGlhZ29uYWxseUlmTm9PYnN0YWNsZXMuanMiLCJub2RlX21vZHVsZXMvcGF0aGZpbmRpbmcvc3JjL2ZpbmRlcnMvSlBGTmV2ZXJNb3ZlRGlhZ29uYWxseS5qcyIsIm5vZGVfbW9kdWxlcy9wYXRoZmluZGluZy9zcmMvZmluZGVycy9KdW1wUG9pbnRGaW5kZXIuanMiLCJub2RlX21vZHVsZXMvcGF0aGZpbmRpbmcvc3JjL2ZpbmRlcnMvSnVtcFBvaW50RmluZGVyQmFzZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqS0E7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqWEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIGdyaWREaXN0YW5jZSh4MSwgeTEsIHgyLCB5Mikge1xuICAgIHJldHVybiBNYXRoLmFicyh4MSAtIHgyKSArIE1hdGguYWJzKHkxIC0geTIpO1xufVxuZXhwb3J0cy5ncmlkRGlzdGFuY2UgPSBncmlkRGlzdGFuY2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGdyaWREaXN0YW5jZV8xID0gcmVxdWlyZShcIi4vZ3JpZERpc3RhbmNlXCIpO1xuZnVuY3Rpb24gc29ydGVkRm9vZChkYXRhKSB7XG4gICAgY29uc3Qgc29ydGVkID0ge1xuICAgICAgICBmb29kOiBudWxsLFxuICAgICAgICBkaXN0YW5jZTogMTAwMDAwLFxuICAgIH07XG4gICAgaWYgKCFkYXRhLmJvYXJkLmZvb2QubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGZvb2Qgb2YgZGF0YS5ib2FyZC5mb29kKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgIGZvb2Q6IGZvb2QsXG4gICAgICAgICAgICBkaXN0YW5jZTogZ3JpZERpc3RhbmNlXzEuZ3JpZERpc3RhbmNlKGRhdGEueW91LmJvZHlbMF0ueCwgZGF0YS55b3UuYm9keVswXS55LCBmb29kLngsIGZvb2QueSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXN1bHQuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICByZXR1cm4gYS5kaXN0YW5jZSAtIGIuZGlzdGFuY2U7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuc29ydGVkRm9vZCA9IHNvcnRlZEZvb2Q7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGdyaWREaXN0YW5jZV8xID0gcmVxdWlyZShcIi4vZ3JpZERpc3RhbmNlXCIpO1xuZnVuY3Rpb24gd2VpZ2h0KGRhdGEsIHgsIHkpIHtcbiAgICBmb3IgKGNvbnN0IHNuYWtlIG9mIGRhdGEuYm9hcmQuc25ha2VzKSB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBzbmFrZS5ib2R5O1xuICAgICAgICAvLyBjb25zdCBib2R5ID0gc25ha2UuYm9keS5maWx0ZXIoKHAxLCBpLCBhKSA9PiBhLmZpbmRJbmRleChwMiA9PiBwMS54ID09IHAyLnggJiYgcDEueSA9PSBwMi55KSA9PT0gaSk7XG4gICAgICAgIGZvciAoY29uc3QgW3AsIHBhcnRdIG9mIGJvZHkuZW50cmllcygpKSB7XG4gICAgICAgICAgICAvLyBJcyBwYXJ0IG9mIHNuYWtlP1xuICAgICAgICAgICAgaWYgKHBhcnQueCA9PSB4ICYmIHBhcnQueSA9PSB5KSB7XG4gICAgICAgICAgICAgICAgLy8gSXMgZW5kIG9mIHNuYWtlP1xuICAgICAgICAgICAgICAgIGlmIChwICE9IGJvZHkubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBzbmFrZSBvZiBkYXRhLmJvYXJkLnNuYWtlcykge1xuICAgICAgICBjb25zdCBib2R5ID0gc25ha2UuYm9keTtcbiAgICAgICAgZm9yIChjb25zdCBbcCwgcGFydF0gb2YgYm9keS5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIC8vIElzIG5lYXIgaGVhZD9cbiAgICAgICAgICAgIGlmIChzbmFrZS5pZCAhPSBkYXRhLnlvdS5pZCAmJiBwID09IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IGdyaWREaXN0YW5jZV8xLmdyaWREaXN0YW5jZSh4LCB5LCBwYXJ0LngsIHBhcnQueSk7XG4gICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDwgNCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlzdGFuY2UgKiAxMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDUwO1xufVxuZXhwb3J0cy53ZWlnaHQgPSB3ZWlnaHQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHdlaWdodF8xID0gcmVxdWlyZShcIi4vbGliL3dlaWdodFwiKTtcbmNvbnN0IHNvcnRlZEZvb2RfMSA9IHJlcXVpcmUoXCIuL2xpYi9zb3J0ZWRGb29kXCIpO1xuY29uc3QgUEYgPSByZXF1aXJlKCdwYXRoZmluZGluZycpO1xuLy8gY29uc3QgY29sb3JzID0gWycjMmVjYzcxJywgJyMzNDk4ZGInLCAnIzliNTliNicsICcjZjFjNDBmJywgJyNlNjdlMjInLCAnI2U3NGMzYycsICcjOTVhNWE2JywgJyMzNDQ5NWUnXTtcbmNvbnN0IGdyaWQgPSAkKCcuZ3JpZCcpO1xuY29uc3QgZ2V0Q29sID0gKHgsIHkpID0+IHtcbiAgICByZXR1cm4gZ3JpZC5maW5kKCcucm93JykuZXEoeSkuZmluZCgnLmNvbCcpLmVxKHgpO1xufTtcbmNvbnN0IEJMT0NLRUQgPSAxO1xuY29uc3QgRlJFRSA9IDA7XG5jb25zdCBwZiA9IG5ldyBQRi5BU3RhckZpbmRlcih7XG4gICAgYWxsb3dEaWFnb25hbDogZmFsc2UsXG4gICAgdXNlQ29zdDogdHJ1ZSxcbn0pO1xuY29uc3QgZHJhd0JvYXJkID0gKGRhdGEpID0+IHtcbiAgICBncmlkLmh0bWwoJycpO1xuICAgIGNvbnN0IG1hdHJpeCA9IFtdO1xuICAgIGNvbnN0IGNvc3RzID0gW107XG4gICAgZm9yICh2YXIgeSA9IDA7IHkgPCBkYXRhLmJvYXJkLmhlaWdodDsgeSsrKSB7XG4gICAgICAgIG1hdHJpeFt5XSA9IFtdO1xuICAgICAgICBjb3N0c1t5XSA9IFtdO1xuICAgICAgICBjb25zdCByb3cgPSAkKCc8ZGl2PicpLmFkZENsYXNzKCdyb3cnKS5hcHBlbmRUbyhncmlkKTtcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBkYXRhLmJvYXJkLndpZHRoOyB4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHcgPSB3ZWlnaHRfMS53ZWlnaHQoZGF0YSwgeCwgeSk7XG4gICAgICAgICAgICBtYXRyaXhbeV1beF0gPSB3ID4gMCA/IEZSRUUgOiBCTE9DS0VEO1xuICAgICAgICAgICAgY29zdHNbeV1beF0gPSAxMDAgLSB3O1xuICAgICAgICAgICAgY29uc3QgY29sID0gJCgnPGRpdj4nKS5hZGRDbGFzcygnY29sJykuY3NzKHtcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGByZ2JhKDAsIDAsIDAsICR7KDEwMCAtIHcpIC8gMTAwfSlgLFxuICAgICAgICAgICAgfSkuYXBwZW5kVG8ocm93KTtcbiAgICAgICAgICAgICQoJzxkaXY+JykuYWRkQ2xhc3MoJ3dlaWdodCcpLmh0bWwoeCArICcvJyArIHkgKyAnPGJyLz53OicgKyB3ICsgJzxici8+JyArIChtYXRyaXhbeV1beF0gPT0gRlJFRSA/ICdGUkVFJyA6ICdCTE9DS0VEJykgKyAnPGJyLz5jOicgKyBjb3N0c1t5XVt4XSkuY3NzKHtcbiAgICAgICAgICAgICAgICBjb2xvcjogdyA8IDYwID8gJ3doaXRlJyA6ICdibGFjaycsXG4gICAgICAgICAgICB9KS5hcHBlbmRUbyhjb2wpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgZm9vZCBvZiBkYXRhLmJvYXJkLmZvb2QpIHtcbiAgICAgICAgY29uc3QgY29sID0gZ2V0Q29sKGZvb2QueCwgZm9vZC55KTtcbiAgICAgICAgJCgnPGRpdj4nKS5hZGRDbGFzcygnZm9vZCcpLmFwcGVuZFRvKGNvbCk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgc25ha2Ugb2YgZGF0YS5ib2FyZC5zbmFrZXMpIHtcbiAgICAgICAgY29uc3QgY29sb3IgPSBzbmFrZS5pZCA9PSBkYXRhLnlvdS5pZCA/ICcjMmVjYzcxJyA6ICcjZTc0YzNjJztcbiAgICAgICAgZm9yIChjb25zdCBbcCwgcGFydF0gb2Ygc25ha2UuYm9keS5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbCA9IGdldENvbChwYXJ0LngsIHBhcnQueSk7XG4gICAgICAgICAgICAkKCc8ZGl2PicpLmFkZENsYXNzKCdzbmFrZScpLmNzcyh7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjb2xvcixcbiAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IHAgPT0gMCA/IDEwMCA6IDAsXG4gICAgICAgICAgICB9KS50ZXh0KCcgJykuYXBwZW5kVG8oY29sKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzb3J0ZWQgPSBzb3J0ZWRGb29kXzEuc29ydGVkRm9vZChkYXRhKTtcbiAgICBpZiAoIXNvcnRlZC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjbG9zZXN0OiBmb3IgKGNvbnN0IGNsb3Nlc3Qgb2Ygc29ydGVkKSB7XG4gICAgICAgIGNvbnN0IHBmR3JpZCA9IG5ldyBQRi5HcmlkKGRhdGEuYm9hcmQud2lkdGgsIGRhdGEuYm9hcmQuaGVpZ2h0LCBtYXRyaXgsIGNvc3RzKTtcbiAgICAgICAgY29uc3QgcGF0aCA9IHBmLmZpbmRQYXRoKGRhdGEueW91LmJvZHlbMF0ueCwgZGF0YS55b3UuYm9keVswXS55LCBjbG9zZXN0LmZvb2QueCwgY2xvc2VzdC5mb29kLnksIHBmR3JpZC5jbG9uZSgpKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwID0gcGF0aFtpXTtcbiAgICAgICAgICAgIGlmIChpID09IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvbCA9IGdldENvbChwWzBdLCBwWzFdKTtcbiAgICAgICAgICAgICQoJzxkaXY+JykuYWRkQ2xhc3MoJ3BhdGgnKS5hcHBlbmRUbyhjb2wpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcCA9IHBhdGhbaV07XG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBbMF0gPT0gZGF0YS55b3UuYm9keVswXS54IC0gMSAmJiBwWzFdID09IGRhdGEueW91LmJvZHlbMF0ueSkge1xuICAgICAgICAgICAgICAgIC8vIExlZnRcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnbW92ZVRvd2FyZHNGb29kUGYnLCBwLCAnbGVmdCcpO1xuICAgICAgICAgICAgICAgIGJyZWFrIGNsb3Nlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwWzBdID09IGRhdGEueW91LmJvZHlbMF0ueCArIDEgJiYgcFsxXSA9PSBkYXRhLnlvdS5ib2R5WzBdLnkpIHtcbiAgICAgICAgICAgICAgICAvLyBSaWdodFxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdtb3ZlVG93YXJkc0Zvb2RQZicsIHAsICdyaWdodCcpO1xuICAgICAgICAgICAgICAgIGJyZWFrIGNsb3Nlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwWzBdID09IGRhdGEueW91LmJvZHlbMF0ueCAmJiBwWzFdID09IGRhdGEueW91LmJvZHlbMF0ueSAtIDEpIHtcbiAgICAgICAgICAgICAgICAvLyBVcFxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdtb3ZlVG93YXJkc0Zvb2RQZicsIHAsICd1cCcpO1xuICAgICAgICAgICAgICAgIGJyZWFrIGNsb3Nlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwWzBdID09IGRhdGEueW91LmJvZHlbMF0ueCAmJiBwWzFdID09IGRhdGEueW91LmJvZHlbMF0ueSArIDEpIHtcbiAgICAgICAgICAgICAgICAvLyBEb3duXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ21vdmVUb3dhcmRzRm9vZFBmJywgcCwgJ2Rvd24nKTtcbiAgICAgICAgICAgICAgICBicmVhayBjbG9zZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ21vdmVUb3dhcmRzRm9vZFBmJywgcCwgJ25vIHBhdGgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBoYXNXYXlPdXQoZGF0YSwgcGF0aCk7XG59O1xuY29uc3QgaGFzV2F5T3V0ID0gKGRhdGEsIHBhdGgpID0+IHtcbiAgICBjb25zdCBtYXRyaXggPSBbXTtcbiAgICBjb25zdCBjb3N0cyA9IFtdO1xuICAgIGZvciAodmFyIHkgPSAwOyB5IDwgZGF0YS5ib2FyZC5oZWlnaHQ7IHkrKykge1xuICAgICAgICBtYXRyaXhbeV0gPSBbXTtcbiAgICAgICAgY29zdHNbeV0gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBkYXRhLmJvYXJkLndpZHRoOyB4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHcgPSB3ZWlnaHRfMS53ZWlnaHQoZGF0YSwgeCwgeSk7XG4gICAgICAgICAgICBtYXRyaXhbeV1beF0gPSB3ID4gMCA/IEZSRUUgOiBCTE9DS0VEO1xuICAgICAgICAgICAgY29zdHNbeV1beF0gPSAxMDAgLSB3O1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2ksIHBdIG9mIHBhdGguZW50cmllcygpKSB7XG4gICAgICAgIG1hdHJpeFtwWzFdXVtwWzBdXSA9IEJMT0NLRUQ7XG4gICAgfVxuICAgIGNvbnN0IHBmR3JpZCA9IG5ldyBQRi5HcmlkKGRhdGEuYm9hcmQud2lkdGgsIGRhdGEuYm9hcmQuaGVpZ2h0LCBtYXRyaXgsIGNvc3RzKTtcbiAgICBmb3IgKGNvbnN0IGZvb2Qgb2YgZGF0YS5ib2FyZC5mb29kKSB7XG4gICAgICAgIGNvbnN0IHdheU91dFBhdGggPSBwZi5maW5kUGF0aChkYXRhLnlvdS5ib2R5WzBdLngsIGRhdGEueW91LmJvZHlbMF0ueSwgZm9vZC54LCBmb29kLnksIHBmR3JpZC5jbG9uZSgpKTtcbiAgICAgICAgY29uc29sZS5sb2cod2F5T3V0UGF0aCk7XG4gICAgfVxufTtcbmxldCBnYW1lID0gbnVsbDtcbmNvbnN0IGxvYWRHYW1lID0gKGdhbWVGaWxlLCB0dXJuID0gbnVsbCkgPT4ge1xuICAgICQoJy5tb3ZlcycpLmh0bWwoJycpO1xuICAgICQuZ2V0SlNPTignLi4vZ2FtZXMvJyArIGdhbWVGaWxlKS5kb25lKChyZXNwb25zZSkgPT4ge1xuICAgICAgICBnYW1lID0gcmVzcG9uc2U7XG4gICAgICAgIGlmICh0dXJuKSB7XG4gICAgICAgICAgICBkcmF3Qm9hcmQoZ2FtZS5tb3Zlc1t0dXJuXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkcmF3Qm9hcmQoZ2FtZS5zdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBtb3ZlIG9mIGdhbWUubW92ZXMpIHtcbiAgICAgICAgICAgIGlmICghbW92ZSB8fCAhbW92ZS50dXJuKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkKCc8ZGl2PicpLmFkZENsYXNzKCdtb3ZlJykuZGF0YSgndHVybicsIG1vdmUudHVybikudGV4dCgnTW92ZSAnICsgbW92ZS50dXJuKS5hcHBlbmRUbygnLm1vdmVzJyk7XG4gICAgICAgIH1cbiAgICB9KS5mYWlsKCh4aHIsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKSA9PiB7XG4gICAgICAgICQoJy5sb2cnKS50ZXh0KHRleHRTdGF0dXMgKyAnOiAnICsgZXJyb3JUaHJvd24pO1xuICAgICAgICBjb25zb2xlLmVycm9yKHRleHRTdGF0dXMsIGVycm9yVGhyb3duKTtcbiAgICB9KTtcbn07XG4kKCcuZ2FtZScpLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBnYW1lRmlsZSA9ICQodGhpcykuZGF0YSgnZ2FtZScpO1xuICAgIGxvYWRHYW1lKGdhbWVGaWxlKTtcbn0pO1xuY29uc3QgdXJsUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoKTtcbmNvbnN0IHF1ZXJ5R2FtZSA9IHVybFBhcmFtcy5nZXQoJ2dhbWUnKTtcbmNvbnN0IHF1ZXJ5VHVybiA9IHVybFBhcmFtcy5nZXQoJ3R1cm4nKTtcbmlmIChxdWVyeUdhbWUpIHtcbiAgICBsb2FkR2FtZShxdWVyeUdhbWUsIHF1ZXJ5VHVybik7XG59XG5lbHNlIHtcbiAgICAkKCcuZ2FtZTpsYXN0JykuY2xpY2soKTtcbn1cbiQoJy5tb3ZlcycpLm9uKCdjbGljaycsICcubW92ZScsIGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCB0dXJuID0gJCh0aGlzKS5kYXRhKCd0dXJuJyk7XG4gICAgZHJhd0JvYXJkKGdhbWUubW92ZXNbdHVybl0pO1xuICAgIGNvbnN0IG5ld1VybCA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIHdpbmRvdy5sb2NhdGlvbi5ob3N0ICsgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lICsgJz9nYW1lPScgKyBnYW1lLm1vdmVzW3R1cm5dLnlvdS5pZCArICcmdHVybj0nICsgdHVybjtcbiAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoe1xuICAgICAgICBwYXRoOiBuZXdVcmwsXG4gICAgfSwgJycsIG5ld1VybCk7XG59KTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvaGVhcCcpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjguMFxuKGZ1bmN0aW9uKCkge1xuICB2YXIgSGVhcCwgZGVmYXVsdENtcCwgZmxvb3IsIGhlYXBpZnksIGhlYXBwb3AsIGhlYXBwdXNoLCBoZWFwcHVzaHBvcCwgaGVhcHJlcGxhY2UsIGluc29ydCwgbWluLCBubGFyZ2VzdCwgbnNtYWxsZXN0LCB1cGRhdGVJdGVtLCBfc2lmdGRvd24sIF9zaWZ0dXA7XG5cbiAgZmxvb3IgPSBNYXRoLmZsb29yLCBtaW4gPSBNYXRoLm1pbjtcblxuXG4gIC8qXG4gIERlZmF1bHQgY29tcGFyaXNvbiBmdW5jdGlvbiB0byBiZSB1c2VkXG4gICAqL1xuXG4gIGRlZmF1bHRDbXAgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgaWYgKHggPCB5KSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGlmICh4ID4geSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9O1xuXG5cbiAgLypcbiAgSW5zZXJ0IGl0ZW0geCBpbiBsaXN0IGEsIGFuZCBrZWVwIGl0IHNvcnRlZCBhc3N1bWluZyBhIGlzIHNvcnRlZC5cbiAgXG4gIElmIHggaXMgYWxyZWFkeSBpbiBhLCBpbnNlcnQgaXQgdG8gdGhlIHJpZ2h0IG9mIHRoZSByaWdodG1vc3QgeC5cbiAgXG4gIE9wdGlvbmFsIGFyZ3MgbG8gKGRlZmF1bHQgMCkgYW5kIGhpIChkZWZhdWx0IGEubGVuZ3RoKSBib3VuZCB0aGUgc2xpY2VcbiAgb2YgYSB0byBiZSBzZWFyY2hlZC5cbiAgICovXG5cbiAgaW5zb3J0ID0gZnVuY3Rpb24oYSwgeCwgbG8sIGhpLCBjbXApIHtcbiAgICB2YXIgbWlkO1xuICAgIGlmIChsbyA9PSBudWxsKSB7XG4gICAgICBsbyA9IDA7XG4gICAgfVxuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgaWYgKGxvIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdsbyBtdXN0IGJlIG5vbi1uZWdhdGl2ZScpO1xuICAgIH1cbiAgICBpZiAoaGkgPT0gbnVsbCkge1xuICAgICAgaGkgPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICAgIG1pZCA9IGZsb29yKChsbyArIGhpKSAvIDIpO1xuICAgICAgaWYgKGNtcCh4LCBhW21pZF0pIDwgMCkge1xuICAgICAgICBoaSA9IG1pZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvID0gbWlkICsgMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIChbXS5zcGxpY2UuYXBwbHkoYSwgW2xvLCBsbyAtIGxvXS5jb25jYXQoeCkpLCB4KTtcbiAgfTtcblxuXG4gIC8qXG4gIFB1c2ggaXRlbSBvbnRvIGhlYXAsIG1haW50YWluaW5nIHRoZSBoZWFwIGludmFyaWFudC5cbiAgICovXG5cbiAgaGVhcHB1c2ggPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgY21wKSB7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBhcnJheS5wdXNoKGl0ZW0pO1xuICAgIHJldHVybiBfc2lmdGRvd24oYXJyYXksIDAsIGFycmF5Lmxlbmd0aCAtIDEsIGNtcCk7XG4gIH07XG5cblxuICAvKlxuICBQb3AgdGhlIHNtYWxsZXN0IGl0ZW0gb2ZmIHRoZSBoZWFwLCBtYWludGFpbmluZyB0aGUgaGVhcCBpbnZhcmlhbnQuXG4gICAqL1xuXG4gIGhlYXBwb3AgPSBmdW5jdGlvbihhcnJheSwgY21wKSB7XG4gICAgdmFyIGxhc3RlbHQsIHJldHVybml0ZW07XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBsYXN0ZWx0ID0gYXJyYXkucG9wKCk7XG4gICAgaWYgKGFycmF5Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuaXRlbSA9IGFycmF5WzBdO1xuICAgICAgYXJyYXlbMF0gPSBsYXN0ZWx0O1xuICAgICAgX3NpZnR1cChhcnJheSwgMCwgY21wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuaXRlbSA9IGxhc3RlbHQ7XG4gICAgfVxuICAgIHJldHVybiByZXR1cm5pdGVtO1xuICB9O1xuXG5cbiAgLypcbiAgUG9wIGFuZCByZXR1cm4gdGhlIGN1cnJlbnQgc21hbGxlc3QgdmFsdWUsIGFuZCBhZGQgdGhlIG5ldyBpdGVtLlxuICBcbiAgVGhpcyBpcyBtb3JlIGVmZmljaWVudCB0aGFuIGhlYXBwb3AoKSBmb2xsb3dlZCBieSBoZWFwcHVzaCgpLCBhbmQgY2FuIGJlXG4gIG1vcmUgYXBwcm9wcmlhdGUgd2hlbiB1c2luZyBhIGZpeGVkIHNpemUgaGVhcC4gTm90ZSB0aGF0IHRoZSB2YWx1ZVxuICByZXR1cm5lZCBtYXkgYmUgbGFyZ2VyIHRoYW4gaXRlbSEgVGhhdCBjb25zdHJhaW5zIHJlYXNvbmFibGUgdXNlIG9mXG4gIHRoaXMgcm91dGluZSB1bmxlc3Mgd3JpdHRlbiBhcyBwYXJ0IG9mIGEgY29uZGl0aW9uYWwgcmVwbGFjZW1lbnQ6XG4gICAgICBpZiBpdGVtID4gYXJyYXlbMF1cbiAgICAgICAgaXRlbSA9IGhlYXByZXBsYWNlKGFycmF5LCBpdGVtKVxuICAgKi9cblxuICBoZWFwcmVwbGFjZSA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBjbXApIHtcbiAgICB2YXIgcmV0dXJuaXRlbTtcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIHJldHVybml0ZW0gPSBhcnJheVswXTtcbiAgICBhcnJheVswXSA9IGl0ZW07XG4gICAgX3NpZnR1cChhcnJheSwgMCwgY21wKTtcbiAgICByZXR1cm4gcmV0dXJuaXRlbTtcbiAgfTtcblxuXG4gIC8qXG4gIEZhc3QgdmVyc2lvbiBvZiBhIGhlYXBwdXNoIGZvbGxvd2VkIGJ5IGEgaGVhcHBvcC5cbiAgICovXG5cbiAgaGVhcHB1c2hwb3AgPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgY21wKSB7XG4gICAgdmFyIF9yZWY7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBpZiAoYXJyYXkubGVuZ3RoICYmIGNtcChhcnJheVswXSwgaXRlbSkgPCAwKSB7XG4gICAgICBfcmVmID0gW2FycmF5WzBdLCBpdGVtXSwgaXRlbSA9IF9yZWZbMF0sIGFycmF5WzBdID0gX3JlZlsxXTtcbiAgICAgIF9zaWZ0dXAoYXJyYXksIDAsIGNtcCk7XG4gICAgfVxuICAgIHJldHVybiBpdGVtO1xuICB9O1xuXG5cbiAgLypcbiAgVHJhbnNmb3JtIGxpc3QgaW50byBhIGhlYXAsIGluLXBsYWNlLCBpbiBPKGFycmF5Lmxlbmd0aCkgdGltZS5cbiAgICovXG5cbiAgaGVhcGlmeSA9IGZ1bmN0aW9uKGFycmF5LCBjbXApIHtcbiAgICB2YXIgaSwgX2ksIF9qLCBfbGVuLCBfcmVmLCBfcmVmMSwgX3Jlc3VsdHMsIF9yZXN1bHRzMTtcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIF9yZWYxID0gKGZ1bmN0aW9uKCkge1xuICAgICAgX3Jlc3VsdHMxID0gW107XG4gICAgICBmb3IgKHZhciBfaiA9IDAsIF9yZWYgPSBmbG9vcihhcnJheS5sZW5ndGggLyAyKTsgMCA8PSBfcmVmID8gX2ogPCBfcmVmIDogX2ogPiBfcmVmOyAwIDw9IF9yZWYgPyBfaisrIDogX2otLSl7IF9yZXN1bHRzMS5wdXNoKF9qKTsgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzMTtcbiAgICB9KS5hcHBseSh0aGlzKS5yZXZlcnNlKCk7XG4gICAgX3Jlc3VsdHMgPSBbXTtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYxLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICBpID0gX3JlZjFbX2ldO1xuICAgICAgX3Jlc3VsdHMucHVzaChfc2lmdHVwKGFycmF5LCBpLCBjbXApKTtcbiAgICB9XG4gICAgcmV0dXJuIF9yZXN1bHRzO1xuICB9O1xuXG5cbiAgLypcbiAgVXBkYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZ2l2ZW4gaXRlbSBpbiB0aGUgaGVhcC5cbiAgVGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgY2FsbGVkIGV2ZXJ5IHRpbWUgdGhlIGl0ZW0gaXMgYmVpbmcgbW9kaWZpZWQuXG4gICAqL1xuXG4gIHVwZGF0ZUl0ZW0gPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgY21wKSB7XG4gICAgdmFyIHBvcztcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIHBvcyA9IGFycmF5LmluZGV4T2YoaXRlbSk7XG4gICAgaWYgKHBvcyA9PT0gLTEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgX3NpZnRkb3duKGFycmF5LCAwLCBwb3MsIGNtcCk7XG4gICAgcmV0dXJuIF9zaWZ0dXAoYXJyYXksIHBvcywgY21wKTtcbiAgfTtcblxuXG4gIC8qXG4gIEZpbmQgdGhlIG4gbGFyZ2VzdCBlbGVtZW50cyBpbiBhIGRhdGFzZXQuXG4gICAqL1xuXG4gIG5sYXJnZXN0ID0gZnVuY3Rpb24oYXJyYXksIG4sIGNtcCkge1xuICAgIHZhciBlbGVtLCByZXN1bHQsIF9pLCBfbGVuLCBfcmVmO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgcmVzdWx0ID0gYXJyYXkuc2xpY2UoMCwgbik7XG4gICAgaWYgKCFyZXN1bHQubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBoZWFwaWZ5KHJlc3VsdCwgY21wKTtcbiAgICBfcmVmID0gYXJyYXkuc2xpY2Uobik7XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICBlbGVtID0gX3JlZltfaV07XG4gICAgICBoZWFwcHVzaHBvcChyZXN1bHQsIGVsZW0sIGNtcCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQuc29ydChjbXApLnJldmVyc2UoKTtcbiAgfTtcblxuXG4gIC8qXG4gIEZpbmQgdGhlIG4gc21hbGxlc3QgZWxlbWVudHMgaW4gYSBkYXRhc2V0LlxuICAgKi9cblxuICBuc21hbGxlc3QgPSBmdW5jdGlvbihhcnJheSwgbiwgY21wKSB7XG4gICAgdmFyIGVsZW0sIGksIGxvcywgcmVzdWx0LCBfaSwgX2osIF9sZW4sIF9yZWYsIF9yZWYxLCBfcmVzdWx0cztcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIGlmIChuICogMTAgPD0gYXJyYXkubGVuZ3RoKSB7XG4gICAgICByZXN1bHQgPSBhcnJheS5zbGljZSgwLCBuKS5zb3J0KGNtcCk7XG4gICAgICBpZiAoIXJlc3VsdC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGxvcyA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV07XG4gICAgICBfcmVmID0gYXJyYXkuc2xpY2Uobik7XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgZWxlbSA9IF9yZWZbX2ldO1xuICAgICAgICBpZiAoY21wKGVsZW0sIGxvcykgPCAwKSB7XG4gICAgICAgICAgaW5zb3J0KHJlc3VsdCwgZWxlbSwgMCwgbnVsbCwgY21wKTtcbiAgICAgICAgICByZXN1bHQucG9wKCk7XG4gICAgICAgICAgbG9zID0gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaGVhcGlmeShhcnJheSwgY21wKTtcbiAgICBfcmVzdWx0cyA9IFtdO1xuICAgIGZvciAoaSA9IF9qID0gMCwgX3JlZjEgPSBtaW4obiwgYXJyYXkubGVuZ3RoKTsgMCA8PSBfcmVmMSA/IF9qIDwgX3JlZjEgOiBfaiA+IF9yZWYxOyBpID0gMCA8PSBfcmVmMSA/ICsrX2ogOiAtLV9qKSB7XG4gICAgICBfcmVzdWx0cy5wdXNoKGhlYXBwb3AoYXJyYXksIGNtcCkpO1xuICAgIH1cbiAgICByZXR1cm4gX3Jlc3VsdHM7XG4gIH07XG5cbiAgX3NpZnRkb3duID0gZnVuY3Rpb24oYXJyYXksIHN0YXJ0cG9zLCBwb3MsIGNtcCkge1xuICAgIHZhciBuZXdpdGVtLCBwYXJlbnQsIHBhcmVudHBvcztcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIG5ld2l0ZW0gPSBhcnJheVtwb3NdO1xuICAgIHdoaWxlIChwb3MgPiBzdGFydHBvcykge1xuICAgICAgcGFyZW50cG9zID0gKHBvcyAtIDEpID4+IDE7XG4gICAgICBwYXJlbnQgPSBhcnJheVtwYXJlbnRwb3NdO1xuICAgICAgaWYgKGNtcChuZXdpdGVtLCBwYXJlbnQpIDwgMCkge1xuICAgICAgICBhcnJheVtwb3NdID0gcGFyZW50O1xuICAgICAgICBwb3MgPSBwYXJlbnRwb3M7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBhcnJheVtwb3NdID0gbmV3aXRlbTtcbiAgfTtcblxuICBfc2lmdHVwID0gZnVuY3Rpb24oYXJyYXksIHBvcywgY21wKSB7XG4gICAgdmFyIGNoaWxkcG9zLCBlbmRwb3MsIG5ld2l0ZW0sIHJpZ2h0cG9zLCBzdGFydHBvcztcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIGVuZHBvcyA9IGFycmF5Lmxlbmd0aDtcbiAgICBzdGFydHBvcyA9IHBvcztcbiAgICBuZXdpdGVtID0gYXJyYXlbcG9zXTtcbiAgICBjaGlsZHBvcyA9IDIgKiBwb3MgKyAxO1xuICAgIHdoaWxlIChjaGlsZHBvcyA8IGVuZHBvcykge1xuICAgICAgcmlnaHRwb3MgPSBjaGlsZHBvcyArIDE7XG4gICAgICBpZiAocmlnaHRwb3MgPCBlbmRwb3MgJiYgIShjbXAoYXJyYXlbY2hpbGRwb3NdLCBhcnJheVtyaWdodHBvc10pIDwgMCkpIHtcbiAgICAgICAgY2hpbGRwb3MgPSByaWdodHBvcztcbiAgICAgIH1cbiAgICAgIGFycmF5W3Bvc10gPSBhcnJheVtjaGlsZHBvc107XG4gICAgICBwb3MgPSBjaGlsZHBvcztcbiAgICAgIGNoaWxkcG9zID0gMiAqIHBvcyArIDE7XG4gICAgfVxuICAgIGFycmF5W3Bvc10gPSBuZXdpdGVtO1xuICAgIHJldHVybiBfc2lmdGRvd24oYXJyYXksIHN0YXJ0cG9zLCBwb3MsIGNtcCk7XG4gIH07XG5cbiAgSGVhcCA9IChmdW5jdGlvbigpIHtcbiAgICBIZWFwLnB1c2ggPSBoZWFwcHVzaDtcblxuICAgIEhlYXAucG9wID0gaGVhcHBvcDtcblxuICAgIEhlYXAucmVwbGFjZSA9IGhlYXByZXBsYWNlO1xuXG4gICAgSGVhcC5wdXNocG9wID0gaGVhcHB1c2hwb3A7XG5cbiAgICBIZWFwLmhlYXBpZnkgPSBoZWFwaWZ5O1xuXG4gICAgSGVhcC51cGRhdGVJdGVtID0gdXBkYXRlSXRlbTtcblxuICAgIEhlYXAubmxhcmdlc3QgPSBubGFyZ2VzdDtcblxuICAgIEhlYXAubnNtYWxsZXN0ID0gbnNtYWxsZXN0O1xuXG4gICAgZnVuY3Rpb24gSGVhcChjbXApIHtcbiAgICAgIHRoaXMuY21wID0gY21wICE9IG51bGwgPyBjbXAgOiBkZWZhdWx0Q21wO1xuICAgICAgdGhpcy5ub2RlcyA9IFtdO1xuICAgIH1cblxuICAgIEhlYXAucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gaGVhcHB1c2godGhpcy5ub2RlcywgeCwgdGhpcy5jbXApO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBoZWFwcG9wKHRoaXMubm9kZXMsIHRoaXMuY21wKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZXNbMF07XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZXMuaW5kZXhPZih4KSAhPT0gLTE7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gaGVhcHJlcGxhY2UodGhpcy5ub2RlcywgeCwgdGhpcy5jbXApO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5wdXNocG9wID0gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIGhlYXBwdXNocG9wKHRoaXMubm9kZXMsIHgsIHRoaXMuY21wKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUuaGVhcGlmeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGhlYXBpZnkodGhpcy5ub2RlcywgdGhpcy5jbXApO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS51cGRhdGVJdGVtID0gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHVwZGF0ZUl0ZW0odGhpcy5ub2RlcywgeCwgdGhpcy5jbXApO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZXMgPSBbXTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUuZW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzLmxlbmd0aCA9PT0gMDtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZXMubGVuZ3RoO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGhlYXA7XG4gICAgICBoZWFwID0gbmV3IEhlYXAoKTtcbiAgICAgIGhlYXAubm9kZXMgPSB0aGlzLm5vZGVzLnNsaWNlKDApO1xuICAgICAgcmV0dXJuIGhlYXA7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzLnNsaWNlKDApO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5pbnNlcnQgPSBIZWFwLnByb3RvdHlwZS5wdXNoO1xuXG4gICAgSGVhcC5wcm90b3R5cGUudG9wID0gSGVhcC5wcm90b3R5cGUucGVlaztcblxuICAgIEhlYXAucHJvdG90eXBlLmZyb250ID0gSGVhcC5wcm90b3R5cGUucGVlaztcblxuICAgIEhlYXAucHJvdG90eXBlLmhhcyA9IEhlYXAucHJvdG90eXBlLmNvbnRhaW5zO1xuXG4gICAgSGVhcC5wcm90b3R5cGUuY29weSA9IEhlYXAucHJvdG90eXBlLmNsb25lO1xuXG4gICAgcmV0dXJuIEhlYXA7XG5cbiAgfSkoKTtcblxuICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUgIT09IG51bGwgPyBtb2R1bGUuZXhwb3J0cyA6IHZvaWQgMCkge1xuICAgIG1vZHVsZS5leHBvcnRzID0gSGVhcDtcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3cuSGVhcCA9IEhlYXA7XG4gIH1cblxufSkuY2FsbCh0aGlzKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zcmMvUGF0aEZpbmRpbmcnKTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAgICdIZWFwJyAgICAgICAgICAgICAgICAgICAgICA6IHJlcXVpcmUoJ2hlYXAnKSxcbiAgICAnTm9kZScgICAgICAgICAgICAgICAgICAgICAgOiByZXF1aXJlKCcuL2NvcmUvTm9kZScpLFxuICAgICdHcmlkJyAgICAgICAgICAgICAgICAgICAgICA6IHJlcXVpcmUoJy4vY29yZS9HcmlkJyksXG4gICAgJ1V0aWwnICAgICAgICAgICAgICAgICAgICAgIDogcmVxdWlyZSgnLi9jb3JlL1V0aWwnKSxcblx0J0RpYWdvbmFsTW92ZW1lbnQnICAgICAgICAgIDogcmVxdWlyZSgnLi9jb3JlL0RpYWdvbmFsTW92ZW1lbnQnKSxcbiAgICAnSGV1cmlzdGljJyAgICAgICAgICAgICAgICAgOiByZXF1aXJlKCcuL2NvcmUvSGV1cmlzdGljJyksXG4gICAgJ0FTdGFyRmluZGVyJyAgICAgICAgICAgICAgIDogcmVxdWlyZSgnLi9maW5kZXJzL0FTdGFyRmluZGVyJyksXG4gICAgJ0Jlc3RGaXJzdEZpbmRlcicgICAgICAgICAgIDogcmVxdWlyZSgnLi9maW5kZXJzL0Jlc3RGaXJzdEZpbmRlcicpLFxuICAgICdCcmVhZHRoRmlyc3RGaW5kZXInICAgICAgICA6IHJlcXVpcmUoJy4vZmluZGVycy9CcmVhZHRoRmlyc3RGaW5kZXInKSxcbiAgICAnRGlqa3N0cmFGaW5kZXInICAgICAgICAgICAgOiByZXF1aXJlKCcuL2ZpbmRlcnMvRGlqa3N0cmFGaW5kZXInKSxcbiAgICAnQmlBU3RhckZpbmRlcicgICAgICAgICAgICAgOiByZXF1aXJlKCcuL2ZpbmRlcnMvQmlBU3RhckZpbmRlcicpLFxuICAgICdCaUJlc3RGaXJzdEZpbmRlcicgICAgICAgICA6IHJlcXVpcmUoJy4vZmluZGVycy9CaUJlc3RGaXJzdEZpbmRlcicpLFxuICAgICdCaUJyZWFkdGhGaXJzdEZpbmRlcicgICAgICA6IHJlcXVpcmUoJy4vZmluZGVycy9CaUJyZWFkdGhGaXJzdEZpbmRlcicpLFxuICAgICdCaURpamtzdHJhRmluZGVyJyAgICAgICAgICA6IHJlcXVpcmUoJy4vZmluZGVycy9CaURpamtzdHJhRmluZGVyJyksXG4gICAgJ0lEQVN0YXJGaW5kZXInICAgICAgICAgICAgIDogcmVxdWlyZSgnLi9maW5kZXJzL0lEQVN0YXJGaW5kZXInKSxcbiAgICAnSnVtcFBvaW50RmluZGVyJyAgICAgICAgICAgOiByZXF1aXJlKCcuL2ZpbmRlcnMvSnVtcFBvaW50RmluZGVyJyksXG59O1xuIiwidmFyIERpYWdvbmFsTW92ZW1lbnQgPSB7XG4gICAgQWx3YXlzOiAxLFxuICAgIE5ldmVyOiAyLFxuICAgIElmQXRNb3N0T25lT2JzdGFjbGU6IDMsXG4gICAgT25seVdoZW5Ob09ic3RhY2xlczogNFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEaWFnb25hbE1vdmVtZW50OyIsInZhciBOb2RlID0gcmVxdWlyZSgnLi9Ob2RlJyk7XG52YXIgRGlhZ29uYWxNb3ZlbWVudCA9IHJlcXVpcmUoJy4vRGlhZ29uYWxNb3ZlbWVudCcpO1xuXG4vKipcbiAqIFRoZSBHcmlkIGNsYXNzLCB3aGljaCBzZXJ2ZXMgYXMgdGhlIGVuY2Fwc3VsYXRpb24gb2YgdGhlIGxheW91dCBvZiB0aGUgbm9kZXMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfEFycmF5LjxBcnJheS48KG51bWJlcnxib29sZWFuKT4+fSB3aWR0aF9vcl9tYXRyaXggTnVtYmVyIG9mIGNvbHVtbnMgb2YgdGhlIGdyaWQsIG9yIG1hdHJpeFxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBOdW1iZXIgb2Ygcm93cyBvZiB0aGUgZ3JpZC5cbiAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjwobnVtYmVyfGJvb2xlYW4pPj59IFttYXRyaXhdIC0gQSAwLTEgbWF0cml4XG4gKiAgICAgcmVwcmVzZW50aW5nIHRoZSB3YWxrYWJsZSBzdGF0dXMgb2YgdGhlIG5vZGVzKDAgb3IgZmFsc2UgZm9yIHdhbGthYmxlKS5cbiAqICAgICBJZiB0aGUgbWF0cml4IGlzIG5vdCBzdXBwbGllZCwgYWxsIHRoZSBub2RlcyB3aWxsIGJlIHdhbGthYmxlLiBcbiAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjwobnVtYmVyKT4+fSBbY29zdHNdIC0gQSBtYXRyaXhcbiAqICAgICByZXByZXNlbnRpbmcgdGhlIGNvc3Qgb2Ygd2Fsa2luZyB0aGUgbm9kZS5cbiAqICAgICBJZiB0aGUgY29zdHMgaXMgbm90IHN1cHBsaWVkLCBhbGwgdGhlIG5vZGVzIHdpbGwgY29zdCAwLiAgKi9cbmZ1bmN0aW9uIEdyaWQod2lkdGhfb3JfbWF0cml4LCBoZWlnaHQsIG1hdHJpeCwgY29zdHMpIHtcbiAgICB2YXIgd2lkdGg7XG5cbiAgICBpZiAodHlwZW9mIHdpZHRoX29yX21hdHJpeCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgd2lkdGggPSB3aWR0aF9vcl9tYXRyaXg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaGVpZ2h0ID0gd2lkdGhfb3JfbWF0cml4Lmxlbmd0aDtcbiAgICAgICAgd2lkdGggPSB3aWR0aF9vcl9tYXRyaXhbMF0ubGVuZ3RoO1xuICAgICAgICBtYXRyaXggPSB3aWR0aF9vcl9tYXRyaXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBjb2x1bW5zIG9mIHRoZSBncmlkLlxuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqL1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIHJvd3Mgb2YgdGhlIGdyaWQuXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICovXG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAvKipcbiAgICAgKiBBIDJEIGFycmF5IG9mIG5vZGVzLlxuICAgICAqL1xuICAgIHRoaXMubm9kZXMgPSB0aGlzLl9idWlsZE5vZGVzKHdpZHRoLCBoZWlnaHQsIG1hdHJpeCwgY29zdHMpO1xufVxuXG4vKipcbiAqIEJ1aWxkIGFuZCByZXR1cm4gdGhlIG5vZGVzLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aFxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodFxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcnxib29sZWFuPj59IFttYXRyaXhdIC0gQSAwLTEgbWF0cml4IHJlcHJlc2VudGluZ1xuICogICAgIHRoZSB3YWxrYWJsZSBzdGF0dXMgb2YgdGhlIG5vZGVzLlxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBbY29zdHNdIC0gQSBtYXRyaXggcmVwcmVzZW50aW5nXG4gKiAgICAgdGhlIGNvc3RzIHRvIHdhbGsgdGhlIG5vZGVzLlxuICogQHNlZSBHcmlkXG4gKi9cbkdyaWQucHJvdG90eXBlLl9idWlsZE5vZGVzID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgbWF0cml4LCBjb3N0cykge1xuICAgIHZhciBpLCBqLFxuICAgICAgICBub2RlcyA9IG5ldyBBcnJheShoZWlnaHQpLFxuICAgICAgICByb3c7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgaGVpZ2h0OyArK2kpIHtcbiAgICAgICAgbm9kZXNbaV0gPSBuZXcgQXJyYXkod2lkdGgpO1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgd2lkdGg7ICsraikge1xuICAgICAgICAgICAgbm9kZXNbaV1bal0gPSBuZXcgTm9kZShqLCBpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtYXRyaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuXG4gICAgaWYgKG1hdHJpeC5sZW5ndGggIT09IGhlaWdodCB8fCBtYXRyaXhbMF0ubGVuZ3RoICE9PSB3aWR0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hdHJpeCBzaXplIGRvZXMgbm90IGZpdCcpO1xuICAgIH1cblxuICAgIGlmIChjb3N0cyAhPT0gdW5kZWZpbmVkICYmIChjb3N0cy5sZW5ndGggIT09IGhlaWdodCB8fCBjb3N0c1swXS5sZW5ndGggIT09IHdpZHRoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nvc3RzIHNpemUgZG9lcyBub3QgZml0Jyk7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGhlaWdodDsgKytpKSB7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCB3aWR0aDsgKytqKSB7XG4gICAgICAgICAgICBpZiAobWF0cml4W2ldW2pdKSB7XG4gICAgICAgICAgICAgICAgLy8gMCwgZmFsc2UsIG51bGwgd2lsbCBiZSB3YWxrYWJsZVxuICAgICAgICAgICAgICAgIC8vIHdoaWxlIG90aGVycyB3aWxsIGJlIHVuLXdhbGthYmxlXG4gICAgICAgICAgICAgICAgbm9kZXNbaV1bal0ud2Fsa2FibGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb3N0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbm9kZXNbaV1bal0uY29zdD1jb3N0c1tpXVtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBub2Rlcztcbn07XG5cblxuR3JpZC5wcm90b3R5cGUuZ2V0Tm9kZUF0ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHJldHVybiB0aGlzLm5vZGVzW3ldW3hdO1xufTtcblxuXG4vKipcbiAqIERldGVybWluZSB3aGV0aGVyIHRoZSBub2RlIGF0IHRoZSBnaXZlbiBwb3NpdGlvbiBpcyB3YWxrYWJsZS5cbiAqIChBbHNvIHJldHVybnMgZmFsc2UgaWYgdGhlIHBvc2l0aW9uIGlzIG91dHNpZGUgdGhlIGdyaWQuKVxuICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBub2RlLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgeSBjb29yZGluYXRlIG9mIHRoZSBub2RlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gLSBUaGUgd2Fsa2FiaWxpdHkgb2YgdGhlIG5vZGUuXG4gKi9cbkdyaWQucHJvdG90eXBlLmlzV2Fsa2FibGVBdCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy5pc0luc2lkZSh4LCB5KSAmJiB0aGlzLm5vZGVzW3ldW3hdLndhbGthYmxlO1xufTtcblxuXG4vKipcbiAqIEdldCBjb3N0IHRvIHdhbGsgdGhlIG5vZGUgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICogKEFsc28gcmV0dXJucyBmYWxzZSBpZiB0aGUgcG9zaXRpb24gaXMgb3V0c2lkZSB0aGUgZ3JpZC4pXG4gKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIG5vZGUuXG4gKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIG5vZGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IC0gQ29zdCB0byB3YWxrIG5vZGUuXG4gKi9cbkdyaWQucHJvdG90eXBlLmdldENvc3RBdCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICBpZiAoIXRoaXMuaXNJbnNpZGUoeCwgeSkpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5ub2Rlc1t5XVt4XS5jb3N0O1xufTtcblxuXG4vKipcbiAqIERldGVybWluZSB3aGV0aGVyIHRoZSBwb3NpdGlvbiBpcyBpbnNpZGUgdGhlIGdyaWQuXG4gKiBYWFg6IGBncmlkLmlzSW5zaWRlKHgsIHkpYCBpcyB3aWVyZCB0byByZWFkLlxuICogSXQgc2hvdWxkIGJlIGAoeCwgeSkgaXMgaW5zaWRlIGdyaWRgLCBidXQgSSBmYWlsZWQgdG8gZmluZCBhIGJldHRlclxuICogbmFtZSBmb3IgdGhpcyBtZXRob2QuXG4gKiBAcGFyYW0ge251bWJlcn0geFxuICogQHBhcmFtIHtudW1iZXJ9IHlcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbkdyaWQucHJvdG90eXBlLmlzSW5zaWRlID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHJldHVybiAoeCA+PSAwICYmIHggPCB0aGlzLndpZHRoKSAmJiAoeSA+PSAwICYmIHkgPCB0aGlzLmhlaWdodCk7XG59O1xuXG5cbi8qKlxuICogU2V0IHdoZXRoZXIgdGhlIG5vZGUgb24gdGhlIGdpdmVuIHBvc2l0aW9uIGlzIHdhbGthYmxlLlxuICogTk9URTogdGhyb3dzIGV4Y2VwdGlvbiBpZiB0aGUgY29vcmRpbmF0ZSBpcyBub3QgaW5zaWRlIHRoZSBncmlkLlxuICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBub2RlLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgeSBjb29yZGluYXRlIG9mIHRoZSBub2RlLlxuICogQHBhcmFtIHtib29sZWFufSB3YWxrYWJsZSAtIFdoZXRoZXIgdGhlIHBvc2l0aW9uIGlzIHdhbGthYmxlLlxuICovXG5HcmlkLnByb3RvdHlwZS5zZXRXYWxrYWJsZUF0ID0gZnVuY3Rpb24oeCwgeSwgd2Fsa2FibGUpIHtcbiAgICB0aGlzLm5vZGVzW3ldW3hdLndhbGthYmxlID0gd2Fsa2FibGU7XG59O1xuXG5cbi8qKlxuICogU2V0IGNvc3Qgb2YgdGhlIG5vZGUgb24gdGhlIGdpdmVuIHBvc2l0aW9uXG4gKiBOT1RFOiB0aHJvd3MgZXhjZXB0aW9uIGlmIHRoZSBjb29yZGluYXRlIGlzIG5vdCBpbnNpZGUgdGhlIGdyaWQuXG4gKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIG5vZGUuXG4gKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIG5vZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gY29zdCAtIENvc3QgdG8gd2FsayB0aGUgbm9kZS5cbiAqL1xuR3JpZC5wcm90b3R5cGUuc2V0Q29zdEF0ID0gZnVuY3Rpb24oeCwgeSwgY29zdCkge1xuICAgIHRoaXMubm9kZXNbeV1beF0uY29zdCA9IGNvc3Q7XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSBuZWlnaGJvcnMgb2YgdGhlIGdpdmVuIG5vZGUuXG4gKlxuICogICAgIG9mZnNldHMgICAgICBkaWFnb25hbE9mZnNldHM6XG4gKiAgKy0tLSstLS0rLS0tKyAgICArLS0tKy0tLSstLS0rXG4gKiAgfCAgIHwgMCB8ICAgfCAgICB8IDAgfCAgIHwgMSB8XG4gKiAgKy0tLSstLS0rLS0tKyAgICArLS0tKy0tLSstLS0rXG4gKiAgfCAzIHwgICB8IDEgfCAgICB8ICAgfCAgIHwgICB8XG4gKiAgKy0tLSstLS0rLS0tKyAgICArLS0tKy0tLSstLS0rXG4gKiAgfCAgIHwgMiB8ICAgfCAgICB8IDMgfCAgIHwgMiB8XG4gKiAgKy0tLSstLS0rLS0tKyAgICArLS0tKy0tLSstLS0rXG4gKlxuICogIFdoZW4gYWxsb3dEaWFnb25hbCBpcyB0cnVlLCBpZiBvZmZzZXRzW2ldIGlzIHZhbGlkLCB0aGVuXG4gKiAgZGlhZ29uYWxPZmZzZXRzW2ldIGFuZFxuICogIGRpYWdvbmFsT2Zmc2V0c1soaSArIDEpICUgNF0gaXMgdmFsaWQuXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEBwYXJhbSB7RGlhZ29uYWxNb3ZlbWVudH0gZGlhZ29uYWxNb3ZlbWVudFxuICovXG5HcmlkLnByb3RvdHlwZS5nZXROZWlnaGJvcnMgPSBmdW5jdGlvbihub2RlLCBkaWFnb25hbE1vdmVtZW50KSB7XG4gICAgdmFyIHggPSBub2RlLngsXG4gICAgICAgIHkgPSBub2RlLnksXG4gICAgICAgIG5laWdoYm9ycyA9IFtdLFxuICAgICAgICBzMCA9IGZhbHNlLCBkMCA9IGZhbHNlLFxuICAgICAgICBzMSA9IGZhbHNlLCBkMSA9IGZhbHNlLFxuICAgICAgICBzMiA9IGZhbHNlLCBkMiA9IGZhbHNlLFxuICAgICAgICBzMyA9IGZhbHNlLCBkMyA9IGZhbHNlLFxuICAgICAgICBub2RlcyA9IHRoaXMubm9kZXM7XG5cbiAgICAvLyDihpFcbiAgICBpZiAodGhpcy5pc1dhbGthYmxlQXQoeCwgeSAtIDEpKSB7XG4gICAgICAgIG5laWdoYm9ycy5wdXNoKG5vZGVzW3kgLSAxXVt4XSk7XG4gICAgICAgIHMwID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8g4oaSXG4gICAgaWYgKHRoaXMuaXNXYWxrYWJsZUF0KHggKyAxLCB5KSkge1xuICAgICAgICBuZWlnaGJvcnMucHVzaChub2Rlc1t5XVt4ICsgMV0pO1xuICAgICAgICBzMSA9IHRydWU7XG4gICAgfVxuICAgIC8vIOKGk1xuICAgIGlmICh0aGlzLmlzV2Fsa2FibGVBdCh4LCB5ICsgMSkpIHtcbiAgICAgICAgbmVpZ2hib3JzLnB1c2gobm9kZXNbeSArIDFdW3hdKTtcbiAgICAgICAgczIgPSB0cnVlO1xuICAgIH1cbiAgICAvLyDihpBcbiAgICBpZiAodGhpcy5pc1dhbGthYmxlQXQoeCAtIDEsIHkpKSB7XG4gICAgICAgIG5laWdoYm9ycy5wdXNoKG5vZGVzW3ldW3ggLSAxXSk7XG4gICAgICAgIHMzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoZGlhZ29uYWxNb3ZlbWVudCA9PT0gRGlhZ29uYWxNb3ZlbWVudC5OZXZlcikge1xuICAgICAgICByZXR1cm4gbmVpZ2hib3JzO1xuICAgIH1cblxuICAgIGlmIChkaWFnb25hbE1vdmVtZW50ID09PSBEaWFnb25hbE1vdmVtZW50Lk9ubHlXaGVuTm9PYnN0YWNsZXMpIHtcbiAgICAgICAgZDAgPSBzMyAmJiBzMDtcbiAgICAgICAgZDEgPSBzMCAmJiBzMTtcbiAgICAgICAgZDIgPSBzMSAmJiBzMjtcbiAgICAgICAgZDMgPSBzMiAmJiBzMztcbiAgICB9IGVsc2UgaWYgKGRpYWdvbmFsTW92ZW1lbnQgPT09IERpYWdvbmFsTW92ZW1lbnQuSWZBdE1vc3RPbmVPYnN0YWNsZSkge1xuICAgICAgICBkMCA9IHMzIHx8IHMwO1xuICAgICAgICBkMSA9IHMwIHx8IHMxO1xuICAgICAgICBkMiA9IHMxIHx8IHMyO1xuICAgICAgICBkMyA9IHMyIHx8IHMzO1xuICAgIH0gZWxzZSBpZiAoZGlhZ29uYWxNb3ZlbWVudCA9PT0gRGlhZ29uYWxNb3ZlbWVudC5BbHdheXMpIHtcbiAgICAgICAgZDAgPSB0cnVlO1xuICAgICAgICBkMSA9IHRydWU7XG4gICAgICAgIGQyID0gdHJ1ZTtcbiAgICAgICAgZDMgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0IHZhbHVlIG9mIGRpYWdvbmFsTW92ZW1lbnQnKTtcbiAgICB9XG5cbiAgICAvLyDihpZcbiAgICBpZiAoZDAgJiYgdGhpcy5pc1dhbGthYmxlQXQoeCAtIDEsIHkgLSAxKSkge1xuICAgICAgICBuZWlnaGJvcnMucHVzaChub2Rlc1t5IC0gMV1beCAtIDFdKTtcbiAgICB9XG4gICAgLy8g4oaXXG4gICAgaWYgKGQxICYmIHRoaXMuaXNXYWxrYWJsZUF0KHggKyAxLCB5IC0gMSkpIHtcbiAgICAgICAgbmVpZ2hib3JzLnB1c2gobm9kZXNbeSAtIDFdW3ggKyAxXSk7XG4gICAgfVxuICAgIC8vIOKGmFxuICAgIGlmIChkMiAmJiB0aGlzLmlzV2Fsa2FibGVBdCh4ICsgMSwgeSArIDEpKSB7XG4gICAgICAgIG5laWdoYm9ycy5wdXNoKG5vZGVzW3kgKyAxXVt4ICsgMV0pO1xuICAgIH1cbiAgICAvLyDihplcbiAgICBpZiAoZDMgJiYgdGhpcy5pc1dhbGthYmxlQXQoeCAtIDEsIHkgKyAxKSkge1xuICAgICAgICBuZWlnaGJvcnMucHVzaChub2Rlc1t5ICsgMV1beCAtIDFdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmVpZ2hib3JzO1xufTtcblxuXG4vKipcbiAqIEdldCBhIGNsb25lIG9mIHRoaXMgZ3JpZC5cbiAqIEByZXR1cm4ge0dyaWR9IENsb25lZCBncmlkLlxuICovXG5HcmlkLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpLCBqLFxuXG4gICAgICAgIHdpZHRoID0gdGhpcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gdGhpcy5oZWlnaHQsXG4gICAgICAgIHRoaXNOb2RlcyA9IHRoaXMubm9kZXMsXG5cbiAgICAgICAgbmV3R3JpZCA9IG5ldyBHcmlkKHdpZHRoLCBoZWlnaHQpLFxuICAgICAgICBuZXdOb2RlcyA9IG5ldyBBcnJheShoZWlnaHQpLFxuICAgICAgICByb3c7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgaGVpZ2h0OyArK2kpIHtcbiAgICAgICAgbmV3Tm9kZXNbaV0gPSBuZXcgQXJyYXkod2lkdGgpO1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgd2lkdGg7ICsraikge1xuICAgICAgICAgICAgbmV3Tm9kZXNbaV1bal0gPSBuZXcgTm9kZShqLCBpLCB0aGlzTm9kZXNbaV1bal0ud2Fsa2FibGUsIHRoaXNOb2Rlc1tpXVtqXS5jb3N0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5ld0dyaWQubm9kZXMgPSBuZXdOb2RlcztcblxuICAgIHJldHVybiBuZXdHcmlkO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHcmlkO1xuIiwiLyoqXG4gKiBAbmFtZXNwYWNlIFBGLkhldXJpc3RpY1xuICogQGRlc2NyaXB0aW9uIEEgY29sbGVjdGlvbiBvZiBoZXVyaXN0aWMgZnVuY3Rpb25zLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAvKipcbiAgICogTWFuaGF0dGFuIGRpc3RhbmNlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZHggLSBEaWZmZXJlbmNlIGluIHguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkeSAtIERpZmZlcmVuY2UgaW4geS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBkeCArIGR5XG4gICAqL1xuICBtYW5oYXR0YW46IGZ1bmN0aW9uKGR4LCBkeSkge1xuICAgICAgcmV0dXJuIGR4ICsgZHk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV1Y2xpZGVhbiBkaXN0YW5jZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGR4IC0gRGlmZmVyZW5jZSBpbiB4LlxuICAgKiBAcGFyYW0ge251bWJlcn0gZHkgLSBEaWZmZXJlbmNlIGluIHkuXG4gICAqIEByZXR1cm4ge251bWJlcn0gc3FydChkeCAqIGR4ICsgZHkgKiBkeSlcbiAgICovXG4gIGV1Y2xpZGVhbjogZnVuY3Rpb24oZHgsIGR5KSB7XG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgfSxcblxuICAvKipcbiAgICogT2N0aWxlIGRpc3RhbmNlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZHggLSBEaWZmZXJlbmNlIGluIHguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkeSAtIERpZmZlcmVuY2UgaW4geS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBzcXJ0KGR4ICogZHggKyBkeSAqIGR5KSBmb3IgZ3JpZHNcbiAgICovXG4gIG9jdGlsZTogZnVuY3Rpb24oZHgsIGR5KSB7XG4gICAgICB2YXIgRiA9IE1hdGguU1FSVDIgLSAxO1xuICAgICAgcmV0dXJuIChkeCA8IGR5KSA/IEYgKiBkeCArIGR5IDogRiAqIGR5ICsgZHg7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWJ5c2hldiBkaXN0YW5jZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGR4IC0gRGlmZmVyZW5jZSBpbiB4LlxuICAgKiBAcGFyYW0ge251bWJlcn0gZHkgLSBEaWZmZXJlbmNlIGluIHkuXG4gICAqIEByZXR1cm4ge251bWJlcn0gbWF4KGR4LCBkeSlcbiAgICovXG4gIGNoZWJ5c2hldjogZnVuY3Rpb24oZHgsIGR5KSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgoZHgsIGR5KTtcbiAgfVxuXG59O1xuIiwiLyoqXG4gKiBBIG5vZGUgaW4gZ3JpZC4gXG4gKiBUaGlzIGNsYXNzIGhvbGRzIHNvbWUgYmFzaWMgaW5mb3JtYXRpb24gYWJvdXQgYSBub2RlIGFuZCBjdXN0b20gXG4gKiBhdHRyaWJ1dGVzIG1heSBiZSBhZGRlZCwgZGVwZW5kaW5nIG9uIHRoZSBhbGdvcml0aG1zJyBuZWVkcy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBub2RlIG9uIHRoZSBncmlkLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgeSBjb29yZGluYXRlIG9mIHRoZSBub2RlIG9uIHRoZSBncmlkLlxuICogQHBhcmFtIHtib29sZWFufSBbd2Fsa2FibGVdIC0gV2hldGhlciB0aGlzIG5vZGUgaXMgd2Fsa2FibGUuXG4gKiBAcGFyYW0ge251bWJlcn0gW2Nvc3RdIC0gbm9kZSBjb3N0IHVzZWQgYnkgZmluZGVycyB0aGF0IGFsbG93IG5vbi11bmlmb3JtIG5vZGUgY29zdHNcbiAqL1xuZnVuY3Rpb24gTm9kZSh4LCB5LCB3YWxrYWJsZSwgY29zdCkge1xuICAgIC8qKlxuICAgICAqIFRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIG5vZGUgb24gdGhlIGdyaWQuXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICovXG4gICAgdGhpcy54ID0geDtcbiAgICAvKipcbiAgICAgKiBUaGUgeSBjb29yZGluYXRlIG9mIHRoZSBub2RlIG9uIHRoZSBncmlkLlxuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqL1xuICAgIHRoaXMueSA9IHk7XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGlzIG5vZGUgY2FuIGJlIHdhbGtlZCB0aHJvdWdoLlxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKi9cbiAgICB0aGlzLndhbGthYmxlID0gKHdhbGthYmxlID09PSB1bmRlZmluZWQgPyB0cnVlIDogd2Fsa2FibGUpO1xuICAgIC8qKlxuICAgICAqIENvc3QgdG8gd2FsayB0aGlzIG5vZGUgaWYgaXRzIHdhbGthYmxlXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICovXG4gICAgdGhpcy5jb3N0ID0gKGNvc3QgPT09IHVuZGVmaW5lZCkgPyAwIDogY29zdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBOb2RlO1xuIiwiLyoqXG4gKiBCYWNrdHJhY2UgYWNjb3JkaW5nIHRvIHRoZSBwYXJlbnQgcmVjb3JkcyBhbmQgcmV0dXJuIHRoZSBwYXRoLlxuICogKGluY2x1ZGluZyBib3RoIHN0YXJ0IGFuZCBlbmQgbm9kZXMpXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgRW5kIG5vZGVcbiAqIEByZXR1cm4ge0FycmF5LjxBcnJheS48bnVtYmVyPj59IHRoZSBwYXRoXG4gKi9cbmZ1bmN0aW9uIGJhY2t0cmFjZShub2RlKSB7XG4gICAgdmFyIHBhdGggPSBbW25vZGUueCwgbm9kZS55XV07XG4gICAgd2hpbGUgKG5vZGUucGFyZW50KSB7XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICAgICAgcGF0aC5wdXNoKFtub2RlLngsIG5vZGUueV0pO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aC5yZXZlcnNlKCk7XG59XG5leHBvcnRzLmJhY2t0cmFjZSA9IGJhY2t0cmFjZTtcblxuLyoqXG4gKiBCYWNrdHJhY2UgZnJvbSBzdGFydCBhbmQgZW5kIG5vZGUsIGFuZCByZXR1cm4gdGhlIHBhdGguXG4gKiAoaW5jbHVkaW5nIGJvdGggc3RhcnQgYW5kIGVuZCBub2RlcylcbiAqIEBwYXJhbSB7Tm9kZX1cbiAqIEBwYXJhbSB7Tm9kZX1cbiAqL1xuZnVuY3Rpb24gYmlCYWNrdHJhY2Uobm9kZUEsIG5vZGVCKSB7XG4gICAgdmFyIHBhdGhBID0gYmFja3RyYWNlKG5vZGVBKSxcbiAgICAgICAgcGF0aEIgPSBiYWNrdHJhY2Uobm9kZUIpO1xuICAgIHJldHVybiBwYXRoQS5jb25jYXQocGF0aEIucmV2ZXJzZSgpKTtcbn1cbmV4cG9ydHMuYmlCYWNrdHJhY2UgPSBiaUJhY2t0cmFjZTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBsZW5ndGggb2YgdGhlIHBhdGguXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyPj59IHBhdGggVGhlIHBhdGhcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGxlbmd0aCBvZiB0aGUgcGF0aFxuICovXG5mdW5jdGlvbiBwYXRoTGVuZ3RoKHBhdGgpIHtcbiAgICB2YXIgaSwgc3VtID0gMCwgYSwgYiwgZHgsIGR5O1xuICAgIGZvciAoaSA9IDE7IGkgPCBwYXRoLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGEgPSBwYXRoW2kgLSAxXTtcbiAgICAgICAgYiA9IHBhdGhbaV07XG4gICAgICAgIGR4ID0gYVswXSAtIGJbMF07XG4gICAgICAgIGR5ID0gYVsxXSAtIGJbMV07XG4gICAgICAgIHN1bSArPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgIH1cbiAgICByZXR1cm4gc3VtO1xufVxuZXhwb3J0cy5wYXRoTGVuZ3RoID0gcGF0aExlbmd0aDtcblxuXG4vKipcbiAqIEdpdmVuIHRoZSBzdGFydCBhbmQgZW5kIGNvb3JkaW5hdGVzLCByZXR1cm4gYWxsIHRoZSBjb29yZGluYXRlcyBseWluZ1xuICogb24gdGhlIGxpbmUgZm9ybWVkIGJ5IHRoZXNlIGNvb3JkaW5hdGVzLCBiYXNlZCBvbiBCcmVzZW5oYW0ncyBhbGdvcml0aG0uXG4gKiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0JyZXNlbmhhbSdzX2xpbmVfYWxnb3JpdGhtI1NpbXBsaWZpY2F0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0geDAgU3RhcnQgeCBjb29yZGluYXRlXG4gKiBAcGFyYW0ge251bWJlcn0geTAgU3RhcnQgeSBjb29yZGluYXRlXG4gKiBAcGFyYW0ge251bWJlcn0geDEgRW5kIHggY29vcmRpbmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHkxIEVuZCB5IGNvb3JkaW5hdGVcbiAqIEByZXR1cm4ge0FycmF5LjxBcnJheS48bnVtYmVyPj59IFRoZSBjb29yZGluYXRlcyBvbiB0aGUgbGluZVxuICovXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZSh4MCwgeTAsIHgxLCB5MSkge1xuICAgIHZhciBhYnMgPSBNYXRoLmFicyxcbiAgICAgICAgbGluZSA9IFtdLFxuICAgICAgICBzeCwgc3ksIGR4LCBkeSwgZXJyLCBlMjtcblxuICAgIGR4ID0gYWJzKHgxIC0geDApO1xuICAgIGR5ID0gYWJzKHkxIC0geTApO1xuXG4gICAgc3ggPSAoeDAgPCB4MSkgPyAxIDogLTE7XG4gICAgc3kgPSAoeTAgPCB5MSkgPyAxIDogLTE7XG5cbiAgICBlcnIgPSBkeCAtIGR5O1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgbGluZS5wdXNoKFt4MCwgeTBdKTtcblxuICAgICAgICBpZiAoeDAgPT09IHgxICYmIHkwID09PSB5MSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGUyID0gMiAqIGVycjtcbiAgICAgICAgaWYgKGUyID4gLWR5KSB7XG4gICAgICAgICAgICBlcnIgPSBlcnIgLSBkeTtcbiAgICAgICAgICAgIHgwID0geDAgKyBzeDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZTIgPCBkeCkge1xuICAgICAgICAgICAgZXJyID0gZXJyICsgZHg7XG4gICAgICAgICAgICB5MCA9IHkwICsgc3k7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbGluZTtcbn1cbmV4cG9ydHMuaW50ZXJwb2xhdGUgPSBpbnRlcnBvbGF0ZTtcblxuXG4vKipcbiAqIEdpdmVuIGEgY29tcHJlc3NlZCBwYXRoLCByZXR1cm4gYSBuZXcgcGF0aCB0aGF0IGhhcyBhbGwgdGhlIHNlZ21lbnRzXG4gKiBpbiBpdCBpbnRlcnBvbGF0ZWQuXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyPj59IHBhdGggVGhlIHBhdGhcbiAqIEByZXR1cm4ge0FycmF5LjxBcnJheS48bnVtYmVyPj59IGV4cGFuZGVkIHBhdGhcbiAqL1xuZnVuY3Rpb24gZXhwYW5kUGF0aChwYXRoKSB7XG4gICAgdmFyIGV4cGFuZGVkID0gW10sXG4gICAgICAgIGxlbiA9IHBhdGgubGVuZ3RoLFxuICAgICAgICBjb29yZDAsIGNvb3JkMSxcbiAgICAgICAgaW50ZXJwb2xhdGVkLFxuICAgICAgICBpbnRlcnBvbGF0ZWRMZW4sXG4gICAgICAgIGksIGo7XG5cbiAgICBpZiAobGVuIDwgMikge1xuICAgICAgICByZXR1cm4gZXhwYW5kZWQ7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbiAtIDE7ICsraSkge1xuICAgICAgICBjb29yZDAgPSBwYXRoW2ldO1xuICAgICAgICBjb29yZDEgPSBwYXRoW2kgKyAxXTtcblxuICAgICAgICBpbnRlcnBvbGF0ZWQgPSBpbnRlcnBvbGF0ZShjb29yZDBbMF0sIGNvb3JkMFsxXSwgY29vcmQxWzBdLCBjb29yZDFbMV0pO1xuICAgICAgICBpbnRlcnBvbGF0ZWRMZW4gPSBpbnRlcnBvbGF0ZWQubGVuZ3RoO1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgaW50ZXJwb2xhdGVkTGVuIC0gMTsgKytqKSB7XG4gICAgICAgICAgICBleHBhbmRlZC5wdXNoKGludGVycG9sYXRlZFtqXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXhwYW5kZWQucHVzaChwYXRoW2xlbiAtIDFdKTtcblxuICAgIHJldHVybiBleHBhbmRlZDtcbn1cbmV4cG9ydHMuZXhwYW5kUGF0aCA9IGV4cGFuZFBhdGg7XG5cblxuLyoqXG4gKiBTbW9vdGhlbiB0aGUgZ2l2ZSBwYXRoLlxuICogVGhlIG9yaWdpbmFsIHBhdGggd2lsbCBub3QgYmUgbW9kaWZpZWQ7IGEgbmV3IHBhdGggd2lsbCBiZSByZXR1cm5lZC5cbiAqIEBwYXJhbSB7UEYuR3JpZH0gZ3JpZFxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBwYXRoIFRoZSBwYXRoXG4gKi9cbmZ1bmN0aW9uIHNtb290aGVuUGF0aChncmlkLCBwYXRoKSB7XG4gICAgdmFyIGxlbiA9IHBhdGgubGVuZ3RoLFxuICAgICAgICB4MCA9IHBhdGhbMF1bMF0sICAgICAgICAvLyBwYXRoIHN0YXJ0IHhcbiAgICAgICAgeTAgPSBwYXRoWzBdWzFdLCAgICAgICAgLy8gcGF0aCBzdGFydCB5XG4gICAgICAgIHgxID0gcGF0aFtsZW4gLSAxXVswXSwgIC8vIHBhdGggZW5kIHhcbiAgICAgICAgeTEgPSBwYXRoW2xlbiAtIDFdWzFdLCAgLy8gcGF0aCBlbmQgeVxuICAgICAgICBzeCwgc3ksICAgICAgICAgICAgICAgICAvLyBjdXJyZW50IHN0YXJ0IGNvb3JkaW5hdGVcbiAgICAgICAgZXgsIGV5LCAgICAgICAgICAgICAgICAgLy8gY3VycmVudCBlbmQgY29vcmRpbmF0ZVxuICAgICAgICBuZXdQYXRoLFxuICAgICAgICBpLCBqLCBjb29yZCwgbGluZSwgdGVzdENvb3JkLCBibG9ja2VkO1xuXG4gICAgc3ggPSB4MDtcbiAgICBzeSA9IHkwO1xuICAgIG5ld1BhdGggPSBbW3N4LCBzeV1dO1xuXG4gICAgZm9yIChpID0gMjsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGNvb3JkID0gcGF0aFtpXTtcbiAgICAgICAgZXggPSBjb29yZFswXTtcbiAgICAgICAgZXkgPSBjb29yZFsxXTtcbiAgICAgICAgbGluZSA9IGludGVycG9sYXRlKHN4LCBzeSwgZXgsIGV5KTtcblxuICAgICAgICBibG9ja2VkID0gZmFsc2U7XG4gICAgICAgIGZvciAoaiA9IDE7IGogPCBsaW5lLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICB0ZXN0Q29vcmQgPSBsaW5lW2pdO1xuXG4gICAgICAgICAgICBpZiAoIWdyaWQuaXNXYWxrYWJsZUF0KHRlc3RDb29yZFswXSwgdGVzdENvb3JkWzFdKSkge1xuICAgICAgICAgICAgICAgIGJsb2NrZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChibG9ja2VkKSB7XG4gICAgICAgICAgICBsYXN0VmFsaWRDb29yZCA9IHBhdGhbaSAtIDFdO1xuICAgICAgICAgICAgbmV3UGF0aC5wdXNoKGxhc3RWYWxpZENvb3JkKTtcbiAgICAgICAgICAgIHN4ID0gbGFzdFZhbGlkQ29vcmRbMF07XG4gICAgICAgICAgICBzeSA9IGxhc3RWYWxpZENvb3JkWzFdO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5ld1BhdGgucHVzaChbeDEsIHkxXSk7XG5cbiAgICByZXR1cm4gbmV3UGF0aDtcbn1cbmV4cG9ydHMuc21vb3RoZW5QYXRoID0gc21vb3RoZW5QYXRoO1xuXG5cbi8qKlxuICogQ29tcHJlc3MgYSBwYXRoLCByZW1vdmUgcmVkdW5kYW50IG5vZGVzIHdpdGhvdXQgYWx0ZXJpbmcgdGhlIHNoYXBlXG4gKiBUaGUgb3JpZ2luYWwgcGF0aCBpcyBub3QgbW9kaWZpZWRcbiAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxudW1iZXI+Pn0gcGF0aCBUaGUgcGF0aFxuICogQHJldHVybiB7QXJyYXkuPEFycmF5LjxudW1iZXI+Pn0gVGhlIGNvbXByZXNzZWQgcGF0aFxuICovXG5mdW5jdGlvbiBjb21wcmVzc1BhdGgocGF0aCkge1xuXG4gICAgLy8gbm90aGluZyB0byBjb21wcmVzc1xuICAgIGlmKHBhdGgubGVuZ3RoIDwgMykge1xuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG5cbiAgICB2YXIgY29tcHJlc3NlZCA9IFtdLFxuICAgICAgICBzeCA9IHBhdGhbMF1bMF0sIC8vIHN0YXJ0IHhcbiAgICAgICAgc3kgPSBwYXRoWzBdWzFdLCAvLyBzdGFydCB5XG4gICAgICAgIHB4ID0gcGF0aFsxXVswXSwgLy8gc2Vjb25kIHBvaW50IHhcbiAgICAgICAgcHkgPSBwYXRoWzFdWzFdLCAvLyBzZWNvbmQgcG9pbnQgeVxuICAgICAgICBkeCA9IHB4IC0gc3gsIC8vIGRpcmVjdGlvbiBiZXR3ZWVuIHRoZSB0d28gcG9pbnRzXG4gICAgICAgIGR5ID0gcHkgLSBzeSwgLy8gZGlyZWN0aW9uIGJldHdlZW4gdGhlIHR3byBwb2ludHNcbiAgICAgICAgbHgsIGx5LFxuICAgICAgICBsZHgsIGxkeSxcbiAgICAgICAgc3EsIGk7XG5cbiAgICAvLyBub3JtYWxpemUgdGhlIGRpcmVjdGlvblxuICAgIHNxID0gTWF0aC5zcXJ0KGR4KmR4ICsgZHkqZHkpO1xuICAgIGR4IC89IHNxO1xuICAgIGR5IC89IHNxO1xuXG4gICAgLy8gc3RhcnQgdGhlIG5ldyBwYXRoXG4gICAgY29tcHJlc3NlZC5wdXNoKFtzeCxzeV0pO1xuXG4gICAgZm9yKGkgPSAyOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgIC8vIHN0b3JlIHRoZSBsYXN0IHBvaW50XG4gICAgICAgIGx4ID0gcHg7XG4gICAgICAgIGx5ID0gcHk7XG5cbiAgICAgICAgLy8gc3RvcmUgdGhlIGxhc3QgZGlyZWN0aW9uXG4gICAgICAgIGxkeCA9IGR4O1xuICAgICAgICBsZHkgPSBkeTtcblxuICAgICAgICAvLyBuZXh0IHBvaW50XG4gICAgICAgIHB4ID0gcGF0aFtpXVswXTtcbiAgICAgICAgcHkgPSBwYXRoW2ldWzFdO1xuXG4gICAgICAgIC8vIG5leHQgZGlyZWN0aW9uXG4gICAgICAgIGR4ID0gcHggLSBseDtcbiAgICAgICAgZHkgPSBweSAtIGx5O1xuXG4gICAgICAgIC8vIG5vcm1hbGl6ZVxuICAgICAgICBzcSA9IE1hdGguc3FydChkeCpkeCArIGR5KmR5KTtcbiAgICAgICAgZHggLz0gc3E7XG4gICAgICAgIGR5IC89IHNxO1xuXG4gICAgICAgIC8vIGlmIHRoZSBkaXJlY3Rpb24gaGFzIGNoYW5nZWQsIHN0b3JlIHRoZSBwb2ludFxuICAgICAgICBpZiAoIGR4ICE9PSBsZHggfHwgZHkgIT09IGxkeSApIHtcbiAgICAgICAgICAgIGNvbXByZXNzZWQucHVzaChbbHgsbHldKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHN0b3JlIHRoZSBsYXN0IHBvaW50XG4gICAgY29tcHJlc3NlZC5wdXNoKFtweCxweV0pO1xuXG4gICAgcmV0dXJuIGNvbXByZXNzZWQ7XG59XG5leHBvcnRzLmNvbXByZXNzUGF0aCA9IGNvbXByZXNzUGF0aDtcbiIsInZhciBIZWFwICAgICAgID0gcmVxdWlyZSgnaGVhcCcpO1xudmFyIFV0aWwgICAgICAgPSByZXF1aXJlKCcuLi9jb3JlL1V0aWwnKTtcbnZhciBIZXVyaXN0aWMgID0gcmVxdWlyZSgnLi4vY29yZS9IZXVyaXN0aWMnKTtcbnZhciBEaWFnb25hbE1vdmVtZW50ID0gcmVxdWlyZSgnLi4vY29yZS9EaWFnb25hbE1vdmVtZW50Jyk7XG5cbi8qKlxuICogQSogcGF0aC1maW5kZXIuXG4gKiBiYXNlZCB1cG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9iZ3JpbnMvamF2YXNjcmlwdC1hc3RhclxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdC5hbGxvd0RpYWdvbmFsIFdoZXRoZXIgZGlhZ29uYWwgbW92ZW1lbnQgaXMgYWxsb3dlZC4gRGVwcmVjYXRlZCwgdXNlIGRpYWdvbmFsTW92ZW1lbnQgaW5zdGVhZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0LmRvbnRDcm9zc0Nvcm5lcnMgRGlzYWxsb3cgZGlhZ29uYWwgbW92ZW1lbnQgdG91Y2hpbmcgYmxvY2sgY29ybmVycy4gRGVwcmVjYXRlZCwgdXNlIGRpYWdvbmFsTW92ZW1lbnQgaW5zdGVhZC5cbiAqIEBwYXJhbSB7RGlhZ29uYWxNb3ZlbWVudH0gb3B0LmRpYWdvbmFsTW92ZW1lbnQgQWxsb3dlZCBkaWFnb25hbCBtb3ZlbWVudC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9wdC5oZXVyaXN0aWMgSGV1cmlzdGljIGZ1bmN0aW9uIHRvIGVzdGltYXRlIHRoZSBkaXN0YW5jZVxuICogICAgIChkZWZhdWx0cyB0byBtYW5oYXR0YW4pLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBvcHQud2VpZ2h0IFdlaWdodCB0byBhcHBseSB0byB0aGUgaGV1cmlzdGljIHRvIGFsbG93IGZvciBzdWJvcHRpbWFsIHBhdGhzLCBcbiAqICAgICBpbiBvcmRlciB0byBzcGVlZCB1cCB0aGUgc2VhcmNoLlxuICovXG5mdW5jdGlvbiBBU3RhckZpbmRlcihvcHQpIHtcbiAgICBvcHQgPSBvcHQgfHwge307XG4gICAgdGhpcy5hbGxvd0RpYWdvbmFsID0gb3B0LmFsbG93RGlhZ29uYWw7XG4gICAgdGhpcy5kb250Q3Jvc3NDb3JuZXJzID0gb3B0LmRvbnRDcm9zc0Nvcm5lcnM7XG4gICAgdGhpcy5oZXVyaXN0aWMgPSBvcHQuaGV1cmlzdGljIHx8IEhldXJpc3RpYy5tYW5oYXR0YW47XG4gICAgdGhpcy53ZWlnaHQgPSBvcHQud2VpZ2h0IHx8IDE7XG4gICAgdGhpcy5kaWFnb25hbE1vdmVtZW50ID0gb3B0LmRpYWdvbmFsTW92ZW1lbnQ7XG5cbiAgICBpZiAoIXRoaXMuZGlhZ29uYWxNb3ZlbWVudCkge1xuICAgICAgICBpZiAoIXRoaXMuYWxsb3dEaWFnb25hbCkge1xuICAgICAgICAgICAgdGhpcy5kaWFnb25hbE1vdmVtZW50ID0gRGlhZ29uYWxNb3ZlbWVudC5OZXZlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbnRDcm9zc0Nvcm5lcnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpYWdvbmFsTW92ZW1lbnQgPSBEaWFnb25hbE1vdmVtZW50Lk9ubHlXaGVuTm9PYnN0YWNsZXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlhZ29uYWxNb3ZlbWVudCA9IERpYWdvbmFsTW92ZW1lbnQuSWZBdE1vc3RPbmVPYnN0YWNsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vV2hlbiBkaWFnb25hbCBtb3ZlbWVudCBpcyBhbGxvd2VkIHRoZSBtYW5oYXR0YW4gaGV1cmlzdGljIGlzIG5vdCBhZG1pc3NpYmxlXG4gICAgLy9JdCBzaG91bGQgYmUgb2N0aWxlIGluc3RlYWRcbiAgICBpZiAodGhpcy5kaWFnb25hbE1vdmVtZW50ID09PSBEaWFnb25hbE1vdmVtZW50Lk5ldmVyKSB7XG4gICAgICAgIHRoaXMuaGV1cmlzdGljID0gb3B0LmhldXJpc3RpYyB8fCBIZXVyaXN0aWMubWFuaGF0dGFuO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGV1cmlzdGljID0gb3B0LmhldXJpc3RpYyB8fCBIZXVyaXN0aWMub2N0aWxlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBGaW5kIGFuZCByZXR1cm4gdGhlIHRoZSBwYXRoLlxuICogQHJldHVybiB7QXJyYXkuPFtudW1iZXIsIG51bWJlcl0+fSBUaGUgcGF0aCwgaW5jbHVkaW5nIGJvdGggc3RhcnQgYW5kXG4gKiAgICAgZW5kIHBvc2l0aW9ucy5cbiAqL1xuQVN0YXJGaW5kZXIucHJvdG90eXBlLmZpbmRQYXRoID0gZnVuY3Rpb24oc3RhcnRYLCBzdGFydFksIGVuZFgsIGVuZFksIGdyaWQpIHtcbiAgICB2YXIgb3Blbkxpc3QgPSBuZXcgSGVhcChmdW5jdGlvbihub2RlQSwgbm9kZUIpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlQS5mIC0gbm9kZUIuZjtcbiAgICAgICAgfSksXG4gICAgICAgIHN0YXJ0Tm9kZSA9IGdyaWQuZ2V0Tm9kZUF0KHN0YXJ0WCwgc3RhcnRZKSxcbiAgICAgICAgZW5kTm9kZSA9IGdyaWQuZ2V0Tm9kZUF0KGVuZFgsIGVuZFkpLFxuICAgICAgICBoZXVyaXN0aWMgPSB0aGlzLmhldXJpc3RpYyxcbiAgICAgICAgZGlhZ29uYWxNb3ZlbWVudCA9IHRoaXMuZGlhZ29uYWxNb3ZlbWVudCxcbiAgICAgICAgd2VpZ2h0ID0gdGhpcy53ZWlnaHQsXG4gICAgICAgIGFicyA9IE1hdGguYWJzLCBTUVJUMiA9IE1hdGguU1FSVDIsXG4gICAgICAgIG5vZGUsIG5laWdoYm9ycywgbmVpZ2hib3IsIGksIGwsIHgsIHksIG5nO1xuXG4gICAgLy8gc2V0IHRoZSBgZ2AgYW5kIGBmYCB2YWx1ZSBvZiB0aGUgc3RhcnQgbm9kZSB0byBiZSAwXG4gICAgc3RhcnROb2RlLmcgPSAwO1xuICAgIHN0YXJ0Tm9kZS5mID0gMDtcblxuICAgIC8vIHB1c2ggdGhlIHN0YXJ0IG5vZGUgaW50byB0aGUgb3BlbiBsaXN0XG4gICAgb3Blbkxpc3QucHVzaChzdGFydE5vZGUpO1xuICAgIHN0YXJ0Tm9kZS5vcGVuZWQgPSB0cnVlO1xuXG4gICAgLy8gd2hpbGUgdGhlIG9wZW4gbGlzdCBpcyBub3QgZW1wdHlcbiAgICB3aGlsZSAoIW9wZW5MaXN0LmVtcHR5KCkpIHtcbiAgICAgICAgLy8gcG9wIHRoZSBwb3NpdGlvbiBvZiBub2RlIHdoaWNoIGhhcyB0aGUgbWluaW11bSBgZmAgdmFsdWUuXG4gICAgICAgIG5vZGUgPSBvcGVuTGlzdC5wb3AoKTtcbiAgICAgICAgbm9kZS5jbG9zZWQgPSB0cnVlO1xuXG4gICAgICAgIC8vIGlmIHJlYWNoZWQgdGhlIGVuZCBwb3NpdGlvbiwgY29uc3RydWN0IHRoZSBwYXRoIGFuZCByZXR1cm4gaXRcbiAgICAgICAgaWYgKG5vZGUgPT09IGVuZE5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBVdGlsLmJhY2t0cmFjZShlbmROb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCBuZWlnYm91cnMgb2YgdGhlIGN1cnJlbnQgbm9kZVxuICAgICAgICBuZWlnaGJvcnMgPSBncmlkLmdldE5laWdoYm9ycyhub2RlLCBkaWFnb25hbE1vdmVtZW50KTtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IG5laWdoYm9ycy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIG5laWdoYm9yID0gbmVpZ2hib3JzW2ldO1xuXG4gICAgICAgICAgICBpZiAobmVpZ2hib3IuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHggPSBuZWlnaGJvci54O1xuICAgICAgICAgICAgeSA9IG5laWdoYm9yLnk7XG5cbiAgICAgICAgICAgIC8vIGdldCB0aGUgZGlzdGFuY2UgYmV0d2VlbiBjdXJyZW50IG5vZGUgYW5kIHRoZSBuZWlnaGJvclxuICAgICAgICAgICAgLy8gYW5kIGNhbGN1bGF0ZSB0aGUgbmV4dCBnIHNjb3JlXG4gICAgICAgICAgICBuZyA9IG5vZGUuZyArIG5laWdoYm9yLmNvc3QgKyAoKHggLSBub2RlLnggPT09IDAgfHwgeSAtIG5vZGUueSA9PT0gMCkgPyAxIDogU1FSVDIpO1xuXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgbmVpZ2hib3IgaGFzIG5vdCBiZWVuIGluc3BlY3RlZCB5ZXQsIG9yXG4gICAgICAgICAgICAvLyBjYW4gYmUgcmVhY2hlZCB3aXRoIHNtYWxsZXIgY29zdCBmcm9tIHRoZSBjdXJyZW50IG5vZGVcbiAgICAgICAgICAgIGlmICghbmVpZ2hib3Iub3BlbmVkIHx8IG5nIDwgbmVpZ2hib3IuZykge1xuICAgICAgICAgICAgICAgIG5laWdoYm9yLmcgPSBuZztcbiAgICAgICAgICAgICAgICBuZWlnaGJvci5oID0gbmVpZ2hib3IuaCB8fCB3ZWlnaHQgKiBoZXVyaXN0aWMoYWJzKHggLSBlbmRYKSwgYWJzKHkgLSBlbmRZKSk7XG4gICAgICAgICAgICAgICAgbmVpZ2hib3IuZiA9IG5laWdoYm9yLmcgKyBuZWlnaGJvci5oO1xuICAgICAgICAgICAgICAgIG5laWdoYm9yLnBhcmVudCA9IG5vZGU7XG5cbiAgICAgICAgICAgICAgICBpZiAoIW5laWdoYm9yLm9wZW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBvcGVuTGlzdC5wdXNoKG5laWdoYm9yKTtcbiAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3Iub3BlbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgbmVpZ2hib3IgY2FuIGJlIHJlYWNoZWQgd2l0aCBzbWFsbGVyIGNvc3QuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNpbmNlIGl0cyBmIHZhbHVlIGhhcyBiZWVuIHVwZGF0ZWQsIHdlIGhhdmUgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIGl0cyBwb3NpdGlvbiBpbiB0aGUgb3BlbiBsaXN0XG4gICAgICAgICAgICAgICAgICAgIG9wZW5MaXN0LnVwZGF0ZUl0ZW0obmVpZ2hib3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBlbmQgZm9yIGVhY2ggbmVpZ2hib3JcbiAgICB9IC8vIGVuZCB3aGlsZSBub3Qgb3BlbiBsaXN0IGVtcHR5XG5cbiAgICAvLyBmYWlsIHRvIGZpbmQgdGhlIHBhdGhcbiAgICByZXR1cm4gW107XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFTdGFyRmluZGVyO1xuIiwidmFyIEFTdGFyRmluZGVyID0gcmVxdWlyZSgnLi9BU3RhckZpbmRlcicpO1xuXG4vKipcbiAqIEJlc3QtRmlyc3QtU2VhcmNoIHBhdGgtZmluZGVyLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBBU3RhckZpbmRlclxuICogQHBhcmFtIHtvYmplY3R9IG9wdFxuICogQHBhcmFtIHtib29sZWFufSBvcHQuYWxsb3dEaWFnb25hbCBXaGV0aGVyIGRpYWdvbmFsIG1vdmVtZW50IGlzIGFsbG93ZWQuIERlcHJlY2F0ZWQsIHVzZSBkaWFnb25hbE1vdmVtZW50IGluc3RlYWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdC5kb250Q3Jvc3NDb3JuZXJzIERpc2FsbG93IGRpYWdvbmFsIG1vdmVtZW50IHRvdWNoaW5nIGJsb2NrIGNvcm5lcnMuIERlcHJlY2F0ZWQsIHVzZSBkaWFnb25hbE1vdmVtZW50IGluc3RlYWQuXG4gKiBAcGFyYW0ge0RpYWdvbmFsTW92ZW1lbnR9IG9wdC5kaWFnb25hbE1vdmVtZW50IEFsbG93ZWQgZGlhZ29uYWwgbW92ZW1lbnQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBvcHQuaGV1cmlzdGljIEhldXJpc3RpYyBmdW5jdGlvbiB0byBlc3RpbWF0ZSB0aGUgZGlzdGFuY2VcbiAqICAgICAoZGVmYXVsdHMgdG8gbWFuaGF0dGFuKS5cbiAqL1xuZnVuY3Rpb24gQmVzdEZpcnN0RmluZGVyKG9wdCkge1xuICAgIEFTdGFyRmluZGVyLmNhbGwodGhpcywgb3B0KTtcblxuICAgIHZhciBvcmlnID0gdGhpcy5oZXVyaXN0aWM7XG4gICAgdGhpcy5oZXVyaXN0aWMgPSBmdW5jdGlvbihkeCwgZHkpIHtcbiAgICAgICAgcmV0dXJuIG9yaWcoZHgsIGR5KSAqIDEwMDAwMDA7XG4gICAgfTtcbn1cblxuQmVzdEZpcnN0RmluZGVyLnByb3RvdHlwZSA9IG5ldyBBU3RhckZpbmRlcigpO1xuQmVzdEZpcnN0RmluZGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJlc3RGaXJzdEZpbmRlcjtcblxubW9kdWxlLmV4cG9ydHMgPSBCZXN0Rmlyc3RGaW5kZXI7XG4iLCJ2YXIgSGVhcCAgICAgICA9IHJlcXVpcmUoJ2hlYXAnKTtcbnZhciBVdGlsICAgICAgID0gcmVxdWlyZSgnLi4vY29yZS9VdGlsJyk7XG52YXIgSGV1cmlzdGljICA9IHJlcXVpcmUoJy4uL2NvcmUvSGV1cmlzdGljJyk7XG52YXIgRGlhZ29uYWxNb3ZlbWVudCA9IHJlcXVpcmUoJy4uL2NvcmUvRGlhZ29uYWxNb3ZlbWVudCcpO1xuXG4vKipcbiAqIEEqIHBhdGgtZmluZGVyLlxuICogYmFzZWQgdXBvbiBodHRwczovL2dpdGh1Yi5jb20vYmdyaW5zL2phdmFzY3JpcHQtYXN0YXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IG9wdFxuICogQHBhcmFtIHtib29sZWFufSBvcHQuYWxsb3dEaWFnb25hbCBXaGV0aGVyIGRpYWdvbmFsIG1vdmVtZW50IGlzIGFsbG93ZWQuIERlcHJlY2F0ZWQsIHVzZSBkaWFnb25hbE1vdmVtZW50IGluc3RlYWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdC5kb250Q3Jvc3NDb3JuZXJzIERpc2FsbG93IGRpYWdvbmFsIG1vdmVtZW50IHRvdWNoaW5nIGJsb2NrIGNvcm5lcnMuIERlcHJlY2F0ZWQsIHVzZSBkaWFnb25hbE1vdmVtZW50IGluc3RlYWQuXG4gKiBAcGFyYW0ge0RpYWdvbmFsTW92ZW1lbnR9IG9wdC5kaWFnb25hbE1vdmVtZW50IEFsbG93ZWQgZGlhZ29uYWwgbW92ZW1lbnQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBvcHQuaGV1cmlzdGljIEhldXJpc3RpYyBmdW5jdGlvbiB0byBlc3RpbWF0ZSB0aGUgZGlzdGFuY2VcbiAqICAgICAoZGVmYXVsdHMgdG8gbWFuaGF0dGFuKS5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gb3B0LndlaWdodCBXZWlnaHQgdG8gYXBwbHkgdG8gdGhlIGhldXJpc3RpYyB0byBhbGxvdyBmb3Igc3Vib3B0aW1hbCBwYXRocywgXG4gKiAgICAgaW4gb3JkZXIgdG8gc3BlZWQgdXAgdGhlIHNlYXJjaC5cbiAqL1xuZnVuY3Rpb24gQmlBU3RhckZpbmRlcihvcHQpIHtcbiAgICBvcHQgPSBvcHQgfHwge307XG4gICAgdGhpcy5hbGxvd0RpYWdvbmFsID0gb3B0LmFsbG93RGlhZ29uYWw7XG4gICAgdGhpcy5kb250Q3Jvc3NDb3JuZXJzID0gb3B0LmRvbnRDcm9zc0Nvcm5lcnM7XG4gICAgdGhpcy5kaWFnb25hbE1vdmVtZW50ID0gb3B0LmRpYWdvbmFsTW92ZW1lbnQ7XG4gICAgdGhpcy5oZXVyaXN0aWMgPSBvcHQuaGV1cmlzdGljIHx8IEhldXJpc3RpYy5tYW5oYXR0YW47XG4gICAgdGhpcy53ZWlnaHQgPSBvcHQud2VpZ2h0IHx8IDE7XG5cbiAgICBpZiAoIXRoaXMuZGlhZ29uYWxNb3ZlbWVudCkge1xuICAgICAgICBpZiAoIXRoaXMuYWxsb3dEaWFnb25hbCkge1xuICAgICAgICAgICAgdGhpcy5kaWFnb25hbE1vdmVtZW50ID0gRGlhZ29uYWxNb3ZlbWVudC5OZXZlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbnRDcm9zc0Nvcm5lcnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpYWdvbmFsTW92ZW1lbnQgPSBEaWFnb25hbE1vdmVtZW50Lk9ubHlXaGVuTm9PYnN0YWNsZXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlhZ29uYWxNb3ZlbWVudCA9IERpYWdvbmFsTW92ZW1lbnQuSWZBdE1vc3RPbmVPYnN0YWNsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vV2hlbiBkaWFnb25hbCBtb3ZlbWVudCBpcyBhbGxvd2VkIHRoZSBtYW5oYXR0YW4gaGV1cmlzdGljIGlzIG5vdCBhZG1pc3NpYmxlXG4gICAgLy9JdCBzaG91bGQgYmUgb2N0aWxlIGluc3RlYWRcbiAgICBpZiAodGhpcy5kaWFnb25hbE1vdmVtZW50ID09PSBEaWFnb25hbE1vdmVtZW50Lk5ldmVyKSB7XG4gICAgICAgIHRoaXMuaGV1cmlzdGljID0gb3B0LmhldXJpc3RpYyB8fCBIZXVyaXN0aWMubWFuaGF0dGFuO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGV1cmlzdGljID0gb3B0LmhldXJpc3RpYyB8fCBIZXVyaXN0aWMub2N0aWxlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBGaW5kIGFuZCByZXR1cm4gdGhlIHRoZSBwYXRoLlxuICogQHJldHVybiB7QXJyYXkuPFtudW1iZXIsIG51bWJlcl0+fSBUaGUgcGF0aCwgaW5jbHVkaW5nIGJvdGggc3RhcnQgYW5kXG4gKiAgICAgZW5kIHBvc2l0aW9ucy5cbiAqL1xuQmlBU3RhckZpbmRlci5wcm90b3R5cGUuZmluZFBhdGggPSBmdW5jdGlvbihzdGFydFgsIHN0YXJ0WSwgZW5kWCwgZW5kWSwgZ3JpZCkge1xuICAgIHZhciBjbXAgPSBmdW5jdGlvbihub2RlQSwgbm9kZUIpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlQS5mIC0gbm9kZUIuZjtcbiAgICAgICAgfSxcbiAgICAgICAgc3RhcnRPcGVuTGlzdCA9IG5ldyBIZWFwKGNtcCksXG4gICAgICAgIGVuZE9wZW5MaXN0ID0gbmV3IEhlYXAoY21wKSxcbiAgICAgICAgc3RhcnROb2RlID0gZ3JpZC5nZXROb2RlQXQoc3RhcnRYLCBzdGFydFkpLFxuICAgICAgICBlbmROb2RlID0gZ3JpZC5nZXROb2RlQXQoZW5kWCwgZW5kWSksXG4gICAgICAgIGhldXJpc3RpYyA9IHRoaXMuaGV1cmlzdGljLFxuICAgICAgICBkaWFnb25hbE1vdmVtZW50ID0gdGhpcy5kaWFnb25hbE1vdmVtZW50LFxuICAgICAgICB3ZWlnaHQgPSB0aGlzLndlaWdodCxcbiAgICAgICAgYWJzID0gTWF0aC5hYnMsIFNRUlQyID0gTWF0aC5TUVJUMixcbiAgICAgICAgbm9kZSwgbmVpZ2hib3JzLCBuZWlnaGJvciwgaSwgbCwgeCwgeSwgbmcsXG4gICAgICAgIEJZX1NUQVJUID0gMSwgQllfRU5EID0gMjtcblxuICAgIC8vIHNldCB0aGUgYGdgIGFuZCBgZmAgdmFsdWUgb2YgdGhlIHN0YXJ0IG5vZGUgdG8gYmUgMFxuICAgIC8vIGFuZCBwdXNoIGl0IGludG8gdGhlIHN0YXJ0IG9wZW4gbGlzdFxuICAgIHN0YXJ0Tm9kZS5nID0gMDtcbiAgICBzdGFydE5vZGUuZiA9IDA7XG4gICAgc3RhcnRPcGVuTGlzdC5wdXNoKHN0YXJ0Tm9kZSk7XG4gICAgc3RhcnROb2RlLm9wZW5lZCA9IEJZX1NUQVJUO1xuXG4gICAgLy8gc2V0IHRoZSBgZ2AgYW5kIGBmYCB2YWx1ZSBvZiB0aGUgZW5kIG5vZGUgdG8gYmUgMFxuICAgIC8vIGFuZCBwdXNoIGl0IGludG8gdGhlIG9wZW4gb3BlbiBsaXN0XG4gICAgZW5kTm9kZS5nID0gMDtcbiAgICBlbmROb2RlLmYgPSAwO1xuICAgIGVuZE9wZW5MaXN0LnB1c2goZW5kTm9kZSk7XG4gICAgZW5kTm9kZS5vcGVuZWQgPSBCWV9FTkQ7XG5cbiAgICAvLyB3aGlsZSBib3RoIHRoZSBvcGVuIGxpc3RzIGFyZSBub3QgZW1wdHlcbiAgICB3aGlsZSAoIXN0YXJ0T3Blbkxpc3QuZW1wdHkoKSAmJiAhZW5kT3Blbkxpc3QuZW1wdHkoKSkge1xuXG4gICAgICAgIC8vIHBvcCB0aGUgcG9zaXRpb24gb2Ygc3RhcnQgbm9kZSB3aGljaCBoYXMgdGhlIG1pbmltdW0gYGZgIHZhbHVlLlxuICAgICAgICBub2RlID0gc3RhcnRPcGVuTGlzdC5wb3AoKTtcbiAgICAgICAgbm9kZS5jbG9zZWQgPSB0cnVlO1xuXG4gICAgICAgIC8vIGdldCBuZWlnYm91cnMgb2YgdGhlIGN1cnJlbnQgbm9kZVxuICAgICAgICBuZWlnaGJvcnMgPSBncmlkLmdldE5laWdoYm9ycyhub2RlLCBkaWFnb25hbE1vdmVtZW50KTtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IG5laWdoYm9ycy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIG5laWdoYm9yID0gbmVpZ2hib3JzW2ldO1xuXG4gICAgICAgICAgICBpZiAobmVpZ2hib3IuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmVpZ2hib3Iub3BlbmVkID09PSBCWV9FTkQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRpbC5iaUJhY2t0cmFjZShub2RlLCBuZWlnaGJvcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHggPSBuZWlnaGJvci54O1xuICAgICAgICAgICAgeSA9IG5laWdoYm9yLnk7XG5cbiAgICAgICAgICAgIC8vIGdldCB0aGUgZGlzdGFuY2UgYmV0d2VlbiBjdXJyZW50IG5vZGUgYW5kIHRoZSBuZWlnaGJvclxuICAgICAgICAgICAgLy8gYW5kIGNhbGN1bGF0ZSB0aGUgbmV4dCBnIHNjb3JlXG4gICAgICAgICAgICBuZyA9IG5vZGUuZyArIG5laWdoYm9yLmNvc3QgKyAoKHggLSBub2RlLnggPT09IDAgfHwgeSAtIG5vZGUueSA9PT0gMCkgPyAxIDogU1FSVDIpO1xuXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgbmVpZ2hib3IgaGFzIG5vdCBiZWVuIGluc3BlY3RlZCB5ZXQsIG9yXG4gICAgICAgICAgICAvLyBjYW4gYmUgcmVhY2hlZCB3aXRoIHNtYWxsZXIgY29zdCBmcm9tIHRoZSBjdXJyZW50IG5vZGVcbiAgICAgICAgICAgIGlmICghbmVpZ2hib3Iub3BlbmVkIHx8IG5nIDwgbmVpZ2hib3IuZykge1xuICAgICAgICAgICAgICAgIG5laWdoYm9yLmcgPSBuZztcbiAgICAgICAgICAgICAgICBuZWlnaGJvci5oID0gbmVpZ2hib3IuaCB8fCB3ZWlnaHQgKiBoZXVyaXN0aWMoYWJzKHggLSBlbmRYKSwgYWJzKHkgLSBlbmRZKSk7XG4gICAgICAgICAgICAgICAgbmVpZ2hib3IuZiA9IG5laWdoYm9yLmcgKyBuZWlnaGJvci5oO1xuICAgICAgICAgICAgICAgIG5laWdoYm9yLnBhcmVudCA9IG5vZGU7XG5cbiAgICAgICAgICAgICAgICBpZiAoIW5laWdoYm9yLm9wZW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydE9wZW5MaXN0LnB1c2gobmVpZ2hib3IpO1xuICAgICAgICAgICAgICAgICAgICBuZWlnaGJvci5vcGVuZWQgPSBCWV9TVEFSVDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgbmVpZ2hib3IgY2FuIGJlIHJlYWNoZWQgd2l0aCBzbWFsbGVyIGNvc3QuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNpbmNlIGl0cyBmIHZhbHVlIGhhcyBiZWVuIHVwZGF0ZWQsIHdlIGhhdmUgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIGl0cyBwb3NpdGlvbiBpbiB0aGUgb3BlbiBsaXN0XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0T3Blbkxpc3QudXBkYXRlSXRlbShuZWlnaGJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IC8vIGVuZCBmb3IgZWFjaCBuZWlnaGJvclxuXG5cbiAgICAgICAgLy8gcG9wIHRoZSBwb3NpdGlvbiBvZiBlbmQgbm9kZSB3aGljaCBoYXMgdGhlIG1pbmltdW0gYGZgIHZhbHVlLlxuICAgICAgICBub2RlID0gZW5kT3Blbkxpc3QucG9wKCk7XG4gICAgICAgIG5vZGUuY2xvc2VkID0gdHJ1ZTtcblxuICAgICAgICAvLyBnZXQgbmVpZ2JvdXJzIG9mIHRoZSBjdXJyZW50IG5vZGVcbiAgICAgICAgbmVpZ2hib3JzID0gZ3JpZC5nZXROZWlnaGJvcnMobm9kZSwgZGlhZ29uYWxNb3ZlbWVudCk7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBuZWlnaGJvcnMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBuZWlnaGJvciA9IG5laWdoYm9yc1tpXTtcblxuICAgICAgICAgICAgaWYgKG5laWdoYm9yLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5laWdoYm9yLm9wZW5lZCA9PT0gQllfU1RBUlQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRpbC5iaUJhY2t0cmFjZShuZWlnaGJvciwgbm9kZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHggPSBuZWlnaGJvci54O1xuICAgICAgICAgICAgeSA9IG5laWdoYm9yLnk7XG5cbiAgICAgICAgICAgIC8vIGdldCB0aGUgZGlzdGFuY2UgYmV0d2VlbiBjdXJyZW50IG5vZGUgYW5kIHRoZSBuZWlnaGJvclxuICAgICAgICAgICAgLy8gYW5kIGNhbGN1bGF0ZSB0aGUgbmV4dCBnIHNjb3JlXG4gICAgICAgICAgICBuZyA9IG5vZGUuZyArIG5laWdoYm9yLmNvc3QgKyAoKHggLSBub2RlLnggPT09IDAgfHwgeSAtIG5vZGUueSA9PT0gMCkgPyAxIDogU1FSVDIpO1xuXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgbmVpZ2hib3IgaGFzIG5vdCBiZWVuIGluc3BlY3RlZCB5ZXQsIG9yXG4gICAgICAgICAgICAvLyBjYW4gYmUgcmVhY2hlZCB3aXRoIHNtYWxsZXIgY29zdCBmcm9tIHRoZSBjdXJyZW50IG5vZGVcbiAgICAgICAgICAgIGlmICghbmVpZ2hib3Iub3BlbmVkIHx8IG5nIDwgbmVpZ2hib3IuZykge1xuICAgICAgICAgICAgICAgIG5laWdoYm9yLmcgPSBuZztcbiAgICAgICAgICAgICAgICBuZWlnaGJvci5oID0gbmVpZ2hib3IuaCB8fCB3ZWlnaHQgKiBoZXVyaXN0aWMoYWJzKHggLSBzdGFydFgpLCBhYnMoeSAtIHN0YXJ0WSkpO1xuICAgICAgICAgICAgICAgIG5laWdoYm9yLmYgPSBuZWlnaGJvci5nICsgbmVpZ2hib3IuaDtcbiAgICAgICAgICAgICAgICBuZWlnaGJvci5wYXJlbnQgPSBub2RlO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFuZWlnaGJvci5vcGVuZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kT3Blbkxpc3QucHVzaChuZWlnaGJvcik7XG4gICAgICAgICAgICAgICAgICAgIG5laWdoYm9yLm9wZW5lZCA9IEJZX0VORDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgbmVpZ2hib3IgY2FuIGJlIHJlYWNoZWQgd2l0aCBzbWFsbGVyIGNvc3QuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNpbmNlIGl0cyBmIHZhbHVlIGhhcyBiZWVuIHVwZGF0ZWQsIHdlIGhhdmUgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIGl0cyBwb3NpdGlvbiBpbiB0aGUgb3BlbiBsaXN0XG4gICAgICAgICAgICAgICAgICAgIGVuZE9wZW5MaXN0LnVwZGF0ZUl0ZW0obmVpZ2hib3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBlbmQgZm9yIGVhY2ggbmVpZ2hib3JcbiAgICB9IC8vIGVuZCB3aGlsZSBub3Qgb3BlbiBsaXN0IGVtcHR5XG5cbiAgICAvLyBmYWlsIHRvIGZpbmQgdGhlIHBhdGhcbiAgICByZXR1cm4gW107XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJpQVN0YXJGaW5kZXI7XG4iLCJ2YXIgQmlBU3RhckZpbmRlciA9IHJlcXVpcmUoJy4vQmlBU3RhckZpbmRlcicpO1xuXG4vKipcbiAqIEJpLWRpcmVjaXRpb25hbCBCZXN0LUZpcnN0LVNlYXJjaCBwYXRoLWZpbmRlci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQmlBU3RhckZpbmRlclxuICogQHBhcmFtIHtvYmplY3R9IG9wdFxuICogQHBhcmFtIHtib29sZWFufSBvcHQuYWxsb3dEaWFnb25hbCBXaGV0aGVyIGRpYWdvbmFsIG1vdmVtZW50IGlzIGFsbG93ZWQuIERlcHJlY2F0ZWQsIHVzZSBkaWFnb25hbE1vdmVtZW50IGluc3RlYWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdC5kb250Q3Jvc3NDb3JuZXJzIERpc2FsbG93IGRpYWdvbmFsIG1vdmVtZW50IHRvdWNoaW5nIGJsb2NrIGNvcm5lcnMuIERlcHJlY2F0ZWQsIHVzZSBkaWFnb25hbE1vdmVtZW50IGluc3RlYWQuXG4gKiBAcGFyYW0ge0RpYWdvbmFsTW92ZW1lbnR9IG9wdC5kaWFnb25hbE1vdmVtZW50IEFsbG93ZWQgZGlhZ29uYWwgbW92ZW1lbnQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBvcHQuaGV1cmlzdGljIEhldXJpc3RpYyBmdW5jdGlvbiB0byBlc3RpbWF0ZSB0aGUgZGlzdGFuY2VcbiAqICAgICAoZGVmYXVsdHMgdG8gbWFuaGF0dGFuKS5cbiAqL1xuZnVuY3Rpb24gQmlCZXN0Rmlyc3RGaW5kZXIob3B0KSB7XG4gICAgQmlBU3RhckZpbmRlci5jYWxsKHRoaXMsIG9wdCk7XG5cbiAgICB2YXIgb3JpZyA9IHRoaXMuaGV1cmlzdGljO1xuICAgIHRoaXMuaGV1cmlzdGljID0gZnVuY3Rpb24oZHgsIGR5KSB7XG4gICAgICAgIHJldHVybiBvcmlnKGR4LCBkeSkgKiAxMDAwMDAwO1xuICAgIH07XG59XG5cbkJpQmVzdEZpcnN0RmluZGVyLnByb3RvdHlwZSA9IG5ldyBCaUFTdGFyRmluZGVyKCk7XG5CaUJlc3RGaXJzdEZpbmRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCaUJlc3RGaXJzdEZpbmRlcjtcblxubW9kdWxlLmV4cG9ydHMgPSBCaUJlc3RGaXJzdEZpbmRlcjtcbiIsInZhciBVdGlsID0gcmVxdWlyZSgnLi4vY29yZS9VdGlsJyk7XG52YXIgRGlhZ29uYWxNb3ZlbWVudCA9IHJlcXVpcmUoJy4uL2NvcmUvRGlhZ29uYWxNb3ZlbWVudCcpO1xuXG4vKipcbiAqIEJpLWRpcmVjdGlvbmFsIEJyZWFkdGgtRmlyc3QtU2VhcmNoIHBhdGggZmluZGVyLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdC5hbGxvd0RpYWdvbmFsIFdoZXRoZXIgZGlhZ29uYWwgbW92ZW1lbnQgaXMgYWxsb3dlZC4gRGVwcmVjYXRlZCwgdXNlIGRpYWdvbmFsTW92ZW1lbnQgaW5zdGVhZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0LmRvbnRDcm9zc0Nvcm5lcnMgRGlzYWxsb3cgZGlhZ29uYWwgbW92ZW1lbnQgdG91Y2hpbmcgYmxvY2sgY29ybmVycy4gRGVwcmVjYXRlZCwgdXNlIGRpYWdvbmFsTW92ZW1lbnQgaW5zdGVhZC5cbiAqIEBwYXJhbSB7RGlhZ29uYWxNb3ZlbWVudH0gb3B0LmRpYWdvbmFsTW92ZW1lbnQgQWxsb3dlZCBkaWFnb25hbCBtb3ZlbWVudC5cbiAqL1xuZnVuY3Rpb24gQmlCcmVhZHRoRmlyc3RGaW5kZXIob3B0KSB7XG4gICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgIHRoaXMuYWxsb3dEaWFnb25hbCA9IG9wdC5hbGxvd0RpYWdvbmFsO1xuICAgIHRoaXMuZG9udENyb3NzQ29ybmVycyA9IG9wdC5kb250Q3Jvc3NDb3JuZXJzO1xuICAgIHRoaXMuZGlhZ29uYWxNb3ZlbWVudCA9IG9wdC5kaWFnb25hbE1vdmVtZW50O1xuXG4gICAgaWYgKCF0aGlzLmRpYWdvbmFsTW92ZW1lbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFsbG93RGlhZ29uYWwpIHtcbiAgICAgICAgICAgIHRoaXMuZGlhZ29uYWxNb3ZlbWVudCA9IERpYWdvbmFsTW92ZW1lbnQuTmV2ZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kb250Q3Jvc3NDb3JuZXJzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaWFnb25hbE1vdmVtZW50ID0gRGlhZ29uYWxNb3ZlbWVudC5Pbmx5V2hlbk5vT2JzdGFjbGVzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpYWdvbmFsTW92ZW1lbnQgPSBEaWFnb25hbE1vdmVtZW50LklmQXRNb3N0T25lT2JzdGFjbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuLyoqXG4gKiBGaW5kIGFuZCByZXR1cm4gdGhlIHRoZSBwYXRoLlxuICogQHJldHVybiB7QXJyYXkuPFtudW1iZXIsIG51bWJlcl0+fSBUaGUgcGF0aCwgaW5jbHVkaW5nIGJvdGggc3RhcnQgYW5kXG4gKiAgICAgZW5kIHBvc2l0aW9ucy5cbiAqL1xuQmlCcmVhZHRoRmlyc3RGaW5kZXIucHJvdG90eXBlLmZpbmRQYXRoID0gZnVuY3Rpb24oc3RhcnRYLCBzdGFydFksIGVuZFgsIGVuZFksIGdyaWQpIHtcbiAgICB2YXIgc3RhcnROb2RlID0gZ3JpZC5nZXROb2RlQXQoc3RhcnRYLCBzdGFydFkpLFxuICAgICAgICBlbmROb2RlID0gZ3JpZC5nZXROb2RlQXQoZW5kWCwgZW5kWSksXG4gICAgICAgIHN0YXJ0T3Blbkxpc3QgPSBbXSwgZW5kT3Blbkxpc3QgPSBbXSxcbiAgICAgICAgbmVpZ2hib3JzLCBuZWlnaGJvciwgbm9kZSxcbiAgICAgICAgZGlhZ29uYWxNb3ZlbWVudCA9IHRoaXMuZGlhZ29uYWxNb3ZlbWVudCxcbiAgICAgICAgQllfU1RBUlQgPSAwLCBCWV9FTkQgPSAxLFxuICAgICAgICBpLCBsO1xuXG4gICAgLy8gcHVzaCB0aGUgc3RhcnQgYW5kIGVuZCBub2RlcyBpbnRvIHRoZSBxdWV1ZXNcbiAgICBzdGFydE9wZW5MaXN0LnB1c2goc3RhcnROb2RlKTtcbiAgICBzdGFydE5vZGUub3BlbmVkID0gdHJ1ZTtcbiAgICBzdGFydE5vZGUuYnkgPSBCWV9TVEFSVDtcblxuICAgIGVuZE9wZW5MaXN0LnB1c2goZW5kTm9kZSk7XG4gICAgZW5kTm9kZS5vcGVuZWQgPSB0cnVlO1xuICAgIGVuZE5vZGUuYnkgPSBCWV9FTkQ7XG5cbiAgICAvLyB3aGlsZSBib3RoIHRoZSBxdWV1ZXMgYXJlIG5vdCBlbXB0eVxuICAgIHdoaWxlIChzdGFydE9wZW5MaXN0Lmxlbmd0aCAmJiBlbmRPcGVuTGlzdC5sZW5ndGgpIHtcblxuICAgICAgICAvLyBleHBhbmQgc3RhcnQgb3BlbiBsaXN0XG5cbiAgICAgICAgbm9kZSA9IHN0YXJ0T3Blbkxpc3Quc2hpZnQoKTtcbiAgICAgICAgbm9kZS5jbG9zZWQgPSB0cnVlO1xuXG4gICAgICAgIG5laWdoYm9ycyA9IGdyaWQuZ2V0TmVpZ2hib3JzKG5vZGUsIGRpYWdvbmFsTW92ZW1lbnQpO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gbmVpZ2hib3JzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgbmVpZ2hib3IgPSBuZWlnaGJvcnNbaV07XG5cbiAgICAgICAgICAgIGlmIChuZWlnaGJvci5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZWlnaGJvci5vcGVuZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIG5vZGUgaGFzIGJlZW4gaW5zcGVjdGVkIGJ5IHRoZSByZXZlcnNlZCBzZWFyY2gsXG4gICAgICAgICAgICAgICAgLy8gdGhlbiBhIHBhdGggaXMgZm91bmQuXG4gICAgICAgICAgICAgICAgaWYgKG5laWdoYm9yLmJ5ID09PSBCWV9FTkQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFV0aWwuYmlCYWNrdHJhY2Uobm9kZSwgbmVpZ2hib3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXJ0T3Blbkxpc3QucHVzaChuZWlnaGJvcik7XG4gICAgICAgICAgICBuZWlnaGJvci5wYXJlbnQgPSBub2RlO1xuICAgICAgICAgICAgbmVpZ2hib3Iub3BlbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIG5laWdoYm9yLmJ5ID0gQllfU1RBUlQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBleHBhbmQgZW5kIG9wZW4gbGlzdFxuXG4gICAgICAgIG5vZGUgPSBlbmRPcGVuTGlzdC5zaGlmdCgpO1xuICAgICAgICBub2RlLmNsb3NlZCA9IHRydWU7XG5cbiAgICAgICAgbmVpZ2hib3JzID0gZ3JpZC5nZXROZWlnaGJvcnMobm9kZSwgZGlhZ29uYWxNb3ZlbWVudCk7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBuZWlnaGJvcnMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBuZWlnaGJvciA9IG5laWdoYm9yc1tpXTtcblxuICAgICAgICAgICAgaWYgKG5laWdoYm9yLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5laWdoYm9yLm9wZW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChuZWlnaGJvci5ieSA9PT0gQllfU1RBUlQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFV0aWwuYmlCYWNrdHJhY2UobmVpZ2hib3IsIG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVuZE9wZW5MaXN0LnB1c2gobmVpZ2hib3IpO1xuICAgICAgICAgICAgbmVpZ2hib3IucGFyZW50ID0gbm9kZTtcbiAgICAgICAgICAgIG5laWdoYm9yLm9wZW5lZCA9IHRydWU7XG4gICAgICAgICAgICBuZWlnaGJvci5ieSA9IEJZX0VORDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGZhaWwgdG8gZmluZCB0aGUgcGF0aFxuICAgIHJldHVybiBbXTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmlCcmVhZHRoRmlyc3RGaW5kZXI7XG4iLCJ2YXIgQmlBU3RhckZpbmRlciA9IHJlcXVpcmUoJy4vQmlBU3RhckZpbmRlcicpO1xuXG4vKipcbiAqIEJpLWRpcmVjdGlvbmFsIERpamtzdHJhIHBhdGgtZmluZGVyLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBCaUFTdGFyRmluZGVyXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdC5hbGxvd0RpYWdvbmFsIFdoZXRoZXIgZGlhZ29uYWwgbW92ZW1lbnQgaXMgYWxsb3dlZC4gRGVwcmVjYXRlZCwgdXNlIGRpYWdvbmFsTW92ZW1lbnQgaW5zdGVhZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0LmRvbnRDcm9zc0Nvcm5lcnMgRGlzYWxsb3cgZGlhZ29uYWwgbW92ZW1lbnQgdG91Y2hpbmcgYmxvY2sgY29ybmVycy4gRGVwcmVjYXRlZCwgdXNlIGRpYWdvbmFsTW92ZW1lbnQgaW5zdGVhZC5cbiAqIEBwYXJhbSB7RGlhZ29uYWxNb3ZlbWVudH0gb3B0LmRpYWdvbmFsTW92ZW1lbnQgQWxsb3dlZCBkaWFnb25hbCBtb3ZlbWVudC5cbiAqL1xuZnVuY3Rpb24gQmlEaWprc3RyYUZpbmRlcihvcHQpIHtcbiAgICBCaUFTdGFyRmluZGVyLmNhbGwodGhpcywgb3B0KTtcbiAgICB0aGlzLmhldXJpc3RpYyA9IGZ1bmN0aW9uKGR4LCBkeSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9O1xufVxuXG5CaURpamtzdHJhRmluZGVyLnByb3RvdHlwZSA9IG5ldyBCaUFTdGFyRmluZGVyKCk7XG5CaURpamtzdHJhRmluZGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJpRGlqa3N0cmFGaW5kZXI7XG5cbm1vZHVsZS5leHBvcnRzID0gQmlEaWprc3RyYUZpbmRlcjtcbiIsInZhciBVdGlsID0gcmVxdWlyZSgnLi4vY29yZS9VdGlsJyk7XG52YXIgRGlhZ29uYWxNb3ZlbWVudCA9IHJlcXVpcmUoJy4uL2NvcmUvRGlhZ29uYWxNb3ZlbWVudCcpO1xuXG4vKipcbiAqIEJyZWFkdGgtRmlyc3QtU2VhcmNoIHBhdGggZmluZGVyLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdC5hbGxvd0RpYWdvbmFsIFdoZXRoZXIgZGlhZ29uYWwgbW92ZW1lbnQgaXMgYWxsb3dlZC4gRGVwcmVjYXRlZCwgdXNlIGRpYWdvbmFsTW92ZW1lbnQgaW5zdGVhZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0LmRvbnRDcm9zc0Nvcm5lcnMgRGlzYWxsb3cgZGlhZ29uYWwgbW92ZW1lbnQgdG91Y2hpbmcgYmxvY2sgY29ybmVycy4gRGVwcmVjYXRlZCwgdXNlIGRpYWdvbmFsTW92ZW1lbnQgaW5zdGVhZC5cbiAqIEBwYXJhbSB7RGlhZ29uYWxNb3ZlbWVudH0gb3B0LmRpYWdvbmFsTW92ZW1lbnQgQWxsb3dlZCBkaWFnb25hbCBtb3ZlbWVudC5cbiAqL1xuZnVuY3Rpb24gQnJlYWR0aEZpcnN0RmluZGVyKG9wdCkge1xuICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICB0aGlzLmFsbG93RGlhZ29uYWwgPSBvcHQuYWxsb3dEaWFnb25hbDtcbiAgICB0aGlzLmRvbnRDcm9zc0Nvcm5lcnMgPSBvcHQuZG9udENyb3NzQ29ybmVycztcbiAgICB0aGlzLmRpYWdvbmFsTW92ZW1lbnQgPSBvcHQuZGlhZ29uYWxNb3ZlbWVudDtcblxuICAgIGlmICghdGhpcy5kaWFnb25hbE1vdmVtZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5hbGxvd0RpYWdvbmFsKSB7XG4gICAgICAgICAgICB0aGlzLmRpYWdvbmFsTW92ZW1lbnQgPSBEaWFnb25hbE1vdmVtZW50Lk5ldmVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuZG9udENyb3NzQ29ybmVycykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlhZ29uYWxNb3ZlbWVudCA9IERpYWdvbmFsTW92ZW1lbnQuT25seVdoZW5Ob09ic3RhY2xlcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaWFnb25hbE1vdmVtZW50ID0gRGlhZ29uYWxNb3ZlbWVudC5JZkF0TW9zdE9uZU9ic3RhY2xlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEZpbmQgYW5kIHJldHVybiB0aGUgdGhlIHBhdGguXG4gKiBAcmV0dXJuIHtBcnJheS48W251bWJlciwgbnVtYmVyXT59IFRoZSBwYXRoLCBpbmNsdWRpbmcgYm90aCBzdGFydCBhbmRcbiAqICAgICBlbmQgcG9zaXRpb25zLlxuICovXG5CcmVhZHRoRmlyc3RGaW5kZXIucHJvdG90eXBlLmZpbmRQYXRoID0gZnVuY3Rpb24oc3RhcnRYLCBzdGFydFksIGVuZFgsIGVuZFksIGdyaWQpIHtcbiAgICB2YXIgb3Blbkxpc3QgPSBbXSxcbiAgICAgICAgZGlhZ29uYWxNb3ZlbWVudCA9IHRoaXMuZGlhZ29uYWxNb3ZlbWVudCxcbiAgICAgICAgc3RhcnROb2RlID0gZ3JpZC5nZXROb2RlQXQoc3RhcnRYLCBzdGFydFkpLFxuICAgICAgICBlbmROb2RlID0gZ3JpZC5nZXROb2RlQXQoZW5kWCwgZW5kWSksXG4gICAgICAgIG5laWdoYm9ycywgbmVpZ2hib3IsIG5vZGUsIGksIGw7XG5cbiAgICAvLyBwdXNoIHRoZSBzdGFydCBwb3MgaW50byB0aGUgcXVldWVcbiAgICBvcGVuTGlzdC5wdXNoKHN0YXJ0Tm9kZSk7XG4gICAgc3RhcnROb2RlLm9wZW5lZCA9IHRydWU7XG5cbiAgICAvLyB3aGlsZSB0aGUgcXVldWUgaXMgbm90IGVtcHR5XG4gICAgd2hpbGUgKG9wZW5MaXN0Lmxlbmd0aCkge1xuICAgICAgICAvLyB0YWtlIHRoZSBmcm9udCBub2RlIGZyb20gdGhlIHF1ZXVlXG4gICAgICAgIG5vZGUgPSBvcGVuTGlzdC5zaGlmdCgpO1xuICAgICAgICBub2RlLmNsb3NlZCA9IHRydWU7XG5cbiAgICAgICAgLy8gcmVhY2hlZCB0aGUgZW5kIHBvc2l0aW9uXG4gICAgICAgIGlmIChub2RlID09PSBlbmROb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gVXRpbC5iYWNrdHJhY2UoZW5kTm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBuZWlnaGJvcnMgPSBncmlkLmdldE5laWdoYm9ycyhub2RlLCBkaWFnb25hbE1vdmVtZW50KTtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IG5laWdoYm9ycy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIG5laWdoYm9yID0gbmVpZ2hib3JzW2ldO1xuXG4gICAgICAgICAgICAvLyBza2lwIHRoaXMgbmVpZ2hib3IgaWYgaXQgaGFzIGJlZW4gaW5zcGVjdGVkIGJlZm9yZVxuICAgICAgICAgICAgaWYgKG5laWdoYm9yLmNsb3NlZCB8fCBuZWlnaGJvci5vcGVuZWQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3Blbkxpc3QucHVzaChuZWlnaGJvcik7XG4gICAgICAgICAgICBuZWlnaGJvci5vcGVuZWQgPSB0cnVlO1xuICAgICAgICAgICAgbmVpZ2hib3IucGFyZW50ID0gbm9kZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBmYWlsIHRvIGZpbmQgdGhlIHBhdGhcbiAgICByZXR1cm4gW107XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJyZWFkdGhGaXJzdEZpbmRlcjtcbiIsInZhciBBU3RhckZpbmRlciA9IHJlcXVpcmUoJy4vQVN0YXJGaW5kZXInKTtcblxuLyoqXG4gKiBEaWprc3RyYSBwYXRoLWZpbmRlci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQVN0YXJGaW5kZXJcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0LmFsbG93RGlhZ29uYWwgV2hldGhlciBkaWFnb25hbCBtb3ZlbWVudCBpcyBhbGxvd2VkLiBEZXByZWNhdGVkLCB1c2UgZGlhZ29uYWxNb3ZlbWVudCBpbnN0ZWFkLlxuICogQHBhcmFtIHtib29sZWFufSBvcHQuZG9udENyb3NzQ29ybmVycyBEaXNhbGxvdyBkaWFnb25hbCBtb3ZlbWVudCB0b3VjaGluZyBibG9jayBjb3JuZXJzLiBEZXByZWNhdGVkLCB1c2UgZGlhZ29uYWxNb3ZlbWVudCBpbnN0ZWFkLlxuICogQHBhcmFtIHtEaWFnb25hbE1vdmVtZW50fSBvcHQuZGlhZ29uYWxNb3ZlbWVudCBBbGxvd2VkIGRpYWdvbmFsIG1vdmVtZW50LlxuICovXG5mdW5jdGlvbiBEaWprc3RyYUZpbmRlcihvcHQpIHtcbiAgICBBU3RhckZpbmRlci5jYWxsKHRoaXMsIG9wdCk7XG4gICAgdGhpcy5oZXVyaXN0aWMgPSBmdW5jdGlvbihkeCwgZHkpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbn1cblxuRGlqa3N0cmFGaW5kZXIucHJvdG90eXBlID0gbmV3IEFTdGFyRmluZGVyKCk7XG5EaWprc3RyYUZpbmRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEaWprc3RyYUZpbmRlcjtcblxubW9kdWxlLmV4cG9ydHMgPSBEaWprc3RyYUZpbmRlcjtcbiIsInZhciBVdGlsICAgICAgID0gcmVxdWlyZSgnLi4vY29yZS9VdGlsJyk7XG52YXIgSGV1cmlzdGljICA9IHJlcXVpcmUoJy4uL2NvcmUvSGV1cmlzdGljJyk7XG52YXIgTm9kZSAgICAgICA9IHJlcXVpcmUoJy4uL2NvcmUvTm9kZScpO1xudmFyIERpYWdvbmFsTW92ZW1lbnQgPSByZXF1aXJlKCcuLi9jb3JlL0RpYWdvbmFsTW92ZW1lbnQnKTtcblxuLyoqXG4gKiBJdGVyYXRpdmUgRGVlcGluZyBBIFN0YXIgKElEQSopIHBhdGgtZmluZGVyLlxuICpcbiAqIFJlY3Vyc2lvbiBiYXNlZCBvbjpcbiAqICAgaHR0cDovL3d3dy5hcGwuamh1LmVkdS9+aGFsbC9BSS1Qcm9ncmFtbWluZy9JREEtU3Rhci5odG1sXG4gKlxuICogUGF0aCByZXRyYWNpbmcgYmFzZWQgb246XG4gKiAgVi4gTmFnZXNod2FyYSBSYW8sIFZpcGluIEt1bWFyIGFuZCBLLiBSYW1lc2hcbiAqICBcIkEgUGFyYWxsZWwgSW1wbGVtZW50YXRpb24gb2YgSXRlcmF0aXZlLURlZXBpbmctQSpcIiwgSmFudWFyeSAxOTg3LlxuICogIGZ0cDovL2Z0cC5jcy51dGV4YXMuZWR1Ly5zbmFwc2hvdC9ob3VybHkuMS9wdWIvQUktTGFiL3RlY2gtcmVwb3J0cy9VVC1BSS1UUi04Ny00Ni5wZGZcbiAqXG4gKiBAYXV0aG9yIEdlcmFyZCBNZWllciAod3d3LmdlcmFyZG1laWVyLmNvbSlcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0LmFsbG93RGlhZ29uYWwgV2hldGhlciBkaWFnb25hbCBtb3ZlbWVudCBpcyBhbGxvd2VkLiBEZXByZWNhdGVkLCB1c2UgZGlhZ29uYWxNb3ZlbWVudCBpbnN0ZWFkLlxuICogQHBhcmFtIHtib29sZWFufSBvcHQuZG9udENyb3NzQ29ybmVycyBEaXNhbGxvdyBkaWFnb25hbCBtb3ZlbWVudCB0b3VjaGluZyBibG9jayBjb3JuZXJzLiBEZXByZWNhdGVkLCB1c2UgZGlhZ29uYWxNb3ZlbWVudCBpbnN0ZWFkLlxuICogQHBhcmFtIHtEaWFnb25hbE1vdmVtZW50fSBvcHQuZGlhZ29uYWxNb3ZlbWVudCBBbGxvd2VkIGRpYWdvbmFsIG1vdmVtZW50LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0LmhldXJpc3RpYyBIZXVyaXN0aWMgZnVuY3Rpb24gdG8gZXN0aW1hdGUgdGhlIGRpc3RhbmNlXG4gKiAgICAgKGRlZmF1bHRzIHRvIG1hbmhhdHRhbikuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IG9wdC53ZWlnaHQgV2VpZ2h0IHRvIGFwcGx5IHRvIHRoZSBoZXVyaXN0aWMgdG8gYWxsb3cgZm9yIHN1Ym9wdGltYWwgcGF0aHMsXG4gKiAgICAgaW4gb3JkZXIgdG8gc3BlZWQgdXAgdGhlIHNlYXJjaC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHQudHJhY2tSZWN1cnNpb24gV2hldGhlciB0byB0cmFjayByZWN1cnNpb24gZm9yIHN0YXRpc3RpY2FsIHB1cnBvc2VzLlxuICogQHBhcmFtIHtvYmplY3R9IG9wdC50aW1lTGltaXQgTWF4aW11bSBleGVjdXRpb24gdGltZS4gVXNlIDw9IDAgZm9yIGluZmluaXRlLlxuICovXG5cbmZ1bmN0aW9uIElEQVN0YXJGaW5kZXIob3B0KSB7XG4gICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgIHRoaXMuYWxsb3dEaWFnb25hbCA9IG9wdC5hbGxvd0RpYWdvbmFsO1xuICAgIHRoaXMuZG9udENyb3NzQ29ybmVycyA9IG9wdC5kb250Q3Jvc3NDb3JuZXJzO1xuICAgIHRoaXMuZGlhZ29uYWxNb3ZlbWVudCA9IG9wdC5kaWFnb25hbE1vdmVtZW50O1xuICAgIHRoaXMuaGV1cmlzdGljID0gb3B0LmhldXJpc3RpYyB8fCBIZXVyaXN0aWMubWFuaGF0dGFuO1xuICAgIHRoaXMud2VpZ2h0ID0gb3B0LndlaWdodCB8fCAxO1xuICAgIHRoaXMudHJhY2tSZWN1cnNpb24gPSBvcHQudHJhY2tSZWN1cnNpb24gfHwgZmFsc2U7XG4gICAgdGhpcy50aW1lTGltaXQgPSBvcHQudGltZUxpbWl0IHx8IEluZmluaXR5OyAvLyBEZWZhdWx0OiBubyB0aW1lIGxpbWl0LlxuXG4gICAgaWYgKCF0aGlzLmRpYWdvbmFsTW92ZW1lbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFsbG93RGlhZ29uYWwpIHtcbiAgICAgICAgICAgIHRoaXMuZGlhZ29uYWxNb3ZlbWVudCA9IERpYWdvbmFsTW92ZW1lbnQuTmV2ZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kb250Q3Jvc3NDb3JuZXJzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaWFnb25hbE1vdmVtZW50ID0gRGlhZ29uYWxNb3ZlbWVudC5Pbmx5V2hlbk5vT2JzdGFjbGVzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpYWdvbmFsTW92ZW1lbnQgPSBEaWFnb25hbE1vdmVtZW50LklmQXRNb3N0T25lT2JzdGFjbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvL1doZW4gZGlhZ29uYWwgbW92ZW1lbnQgaXMgYWxsb3dlZCB0aGUgbWFuaGF0dGFuIGhldXJpc3RpYyBpcyBub3QgYWRtaXNzaWJsZVxuICAgIC8vSXQgc2hvdWxkIGJlIG9jdGlsZSBpbnN0ZWFkXG4gICAgaWYgKHRoaXMuZGlhZ29uYWxNb3ZlbWVudCA9PT0gRGlhZ29uYWxNb3ZlbWVudC5OZXZlcikge1xuICAgICAgICB0aGlzLmhldXJpc3RpYyA9IG9wdC5oZXVyaXN0aWMgfHwgSGV1cmlzdGljLm1hbmhhdHRhbjtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhldXJpc3RpYyA9IG9wdC5oZXVyaXN0aWMgfHwgSGV1cmlzdGljLm9jdGlsZTtcbiAgICB9XG59XG5cbi8qKlxuICogRmluZCBhbmQgcmV0dXJuIHRoZSB0aGUgcGF0aC4gV2hlbiBhbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZCwgZWl0aGVyXG4gKiBubyBwYXRoIGlzIHBvc3NpYmxlLCBvciB0aGUgbWF4aW11bSBleGVjdXRpb24gdGltZSBpcyByZWFjaGVkLlxuICpcbiAqIEByZXR1cm4ge0FycmF5LjxbbnVtYmVyLCBudW1iZXJdPn0gVGhlIHBhdGgsIGluY2x1ZGluZyBib3RoIHN0YXJ0IGFuZFxuICogICAgIGVuZCBwb3NpdGlvbnMuXG4gKi9cbklEQVN0YXJGaW5kZXIucHJvdG90eXBlLmZpbmRQYXRoID0gZnVuY3Rpb24oc3RhcnRYLCBzdGFydFksIGVuZFgsIGVuZFksIGdyaWQpIHtcbiAgICAvLyBVc2VkIGZvciBzdGF0aXN0aWNzOlxuICAgIHZhciBub2Rlc1Zpc2l0ZWQgPSAwO1xuXG4gICAgLy8gRXhlY3V0aW9uIHRpbWUgbGltaXRhdGlvbjpcbiAgICB2YXIgc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgICAvLyBIZXVyaXN0aWMgaGVscGVyOlxuICAgIHZhciBoID0gZnVuY3Rpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gdGhpcy5oZXVyaXN0aWMoTWF0aC5hYnMoYi54IC0gYS54KSwgTWF0aC5hYnMoYi55IC0gYS55KSk7XG4gICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgLy8gU3RlcCBjb3N0IGZyb20gYSB0byBiOlxuICAgIHZhciBjb3N0ID0gZnVuY3Rpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gKGEueCA9PT0gYi54IHx8IGEueSA9PT0gYi55KSA/IDEgOiBNYXRoLlNRUlQyO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJREEqIHNlYXJjaCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gVGhlIG5vZGUgY3VycmVudGx5IGV4cGFuZGluZyBmcm9tLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBDb3N0IHRvIHJlYWNoIHRoZSBnaXZlbiBub2RlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBNYXhpbXVtIHNlYXJjaCBkZXB0aCAoY3V0LW9mZiB2YWx1ZSkuXG4gICAgICogQHBhcmFtIHt7QXJyYXkuPFtudW1iZXIsIG51bWJlcl0+fX0gVGhlIGZvdW5kIHJvdXRlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBSZWN1cnNpb24gZGVwdGguXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGVpdGhlciBhIG51bWJlciB3aXRoIHRoZSBuZXcgb3B0aW1hbCBjdXQtb2ZmIGRlcHRoLFxuICAgICAqIG9yIGEgdmFsaWQgbm9kZSBpbnN0YW5jZSwgaW4gd2hpY2ggY2FzZSBhIHBhdGggd2FzIGZvdW5kLlxuICAgICAqL1xuICAgIHZhciBzZWFyY2ggPSBmdW5jdGlvbihub2RlLCBnLCBjdXRvZmYsIHJvdXRlLCBkZXB0aCkge1xuICAgICAgICBub2Rlc1Zpc2l0ZWQrKztcblxuICAgICAgICAvLyBFbmZvcmNlIHRpbWVsaW1pdDpcbiAgICAgICAgaWYodGhpcy50aW1lTGltaXQgPiAwICYmIG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gc3RhcnRUaW1lID4gdGhpcy50aW1lTGltaXQgKiAxMDAwKSB7XG4gICAgICAgICAgICAvLyBFbmZvcmNlZCBhcyBcInBhdGgtbm90LWZvdW5kXCIuXG4gICAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZiA9IGcgKyBoKG5vZGUsIGVuZCkgKiB0aGlzLndlaWdodDtcblxuICAgICAgICAvLyBXZSd2ZSBzZWFyY2hlZCB0b28gZGVlcCBmb3IgdGhpcyBpdGVyYXRpb24uXG4gICAgICAgIGlmKGYgPiBjdXRvZmYpIHtcbiAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYobm9kZSA9PSBlbmQpIHtcbiAgICAgICAgICAgIHJvdXRlW2RlcHRoXSA9IFtub2RlLngsIG5vZGUueV07XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtaW4sIHQsIGssIG5laWdoYm91cjtcblxuICAgICAgICB2YXIgbmVpZ2hib3VycyA9IGdyaWQuZ2V0TmVpZ2hib3JzKG5vZGUsIHRoaXMuZGlhZ29uYWxNb3ZlbWVudCk7XG5cbiAgICAgICAgLy8gU29ydCB0aGUgbmVpZ2hib3VycywgZ2l2ZXMgbmljZXIgcGF0aHMuIEJ1dCwgdGhpcyBkZXZpYXRlc1xuICAgICAgICAvLyBmcm9tIHRoZSBvcmlnaW5hbCBhbGdvcml0aG0gLSBzbyBJIGxlZnQgaXQgb3V0LlxuICAgICAgICAvL25laWdoYm91cnMuc29ydChmdW5jdGlvbihhLCBiKXtcbiAgICAgICAgLy8gICAgcmV0dXJuIGgoYSwgZW5kKSAtIGgoYiwgZW5kKTtcbiAgICAgICAgLy99KTtcblxuICAgICAgICBcbiAgICAgICAgLypqc2hpbnQgLVcwODQgKi8vL0Rpc2FibGUgd2FybmluZzogRXhwZWN0ZWQgYSBjb25kaXRpb25hbCBleHByZXNzaW9uIGFuZCBpbnN0ZWFkIHNhdyBhbiBhc3NpZ25tZW50XG4gICAgICAgIGZvcihrID0gMCwgbWluID0gSW5maW5pdHk7IG5laWdoYm91ciA9IG5laWdoYm91cnNba107ICsraykge1xuICAgICAgICAvKmpzaGludCArVzA4NCAqLy8vRW5hYmxlIHdhcm5pbmc6IEV4cGVjdGVkIGEgY29uZGl0aW9uYWwgZXhwcmVzc2lvbiBhbmQgaW5zdGVhZCBzYXcgYW4gYXNzaWdubWVudFxuICAgICAgICAgICAgaWYodGhpcy50cmFja1JlY3Vyc2lvbikge1xuICAgICAgICAgICAgICAgIC8vIFJldGFpbiBhIGNvcHkgZm9yIHZpc3VhbGlzYXRpb24uIER1ZSB0byByZWN1cnNpb24sIHRoaXNcbiAgICAgICAgICAgICAgICAvLyBub2RlIG1heSBiZSBwYXJ0IG9mIG90aGVyIHBhdGhzIHRvby5cbiAgICAgICAgICAgICAgICBuZWlnaGJvdXIucmV0YWluQ291bnQgPSBuZWlnaGJvdXIucmV0YWluQ291bnQgKyAxIHx8IDE7XG5cbiAgICAgICAgICAgICAgICBpZihuZWlnaGJvdXIudGVzdGVkICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5laWdoYm91ci50ZXN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdCA9IHNlYXJjaChuZWlnaGJvdXIsIGcgKyBjb3N0KG5vZGUsIG5laWdoYm91ciksIGN1dG9mZiwgcm91dGUsIGRlcHRoICsgMSk7XG5cbiAgICAgICAgICAgIGlmKHQgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICAgICAgICAgICAgcm91dGVbZGVwdGhdID0gW25vZGUueCwgbm9kZS55XTtcblxuICAgICAgICAgICAgICAgIC8vIEZvciBhIHR5cGljYWwgQSogbGlua2VkIGxpc3QsIHRoaXMgd291bGQgd29yazpcbiAgICAgICAgICAgICAgICAvLyBuZWlnaGJvdXIucGFyZW50ID0gbm9kZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRGVjcmVtZW50IGNvdW50LCB0aGVuIGRldGVybWluZSB3aGV0aGVyIGl0J3MgYWN0dWFsbHkgY2xvc2VkLlxuICAgICAgICAgICAgaWYodGhpcy50cmFja1JlY3Vyc2lvbiAmJiAoLS1uZWlnaGJvdXIucmV0YWluQ291bnQpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbmVpZ2hib3VyLnRlc3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZih0IDwgbWluKSB7XG4gICAgICAgICAgICAgICAgbWluID0gdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtaW47XG5cbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAvLyBOb2RlIGluc3RhbmNlIGxvb2t1cHM6XG4gICAgdmFyIHN0YXJ0ID0gZ3JpZC5nZXROb2RlQXQoc3RhcnRYLCBzdGFydFkpO1xuICAgIHZhciBlbmQgICA9IGdyaWQuZ2V0Tm9kZUF0KGVuZFgsIGVuZFkpO1xuXG4gICAgLy8gSW5pdGlhbCBzZWFyY2ggZGVwdGgsIGdpdmVuIHRoZSB0eXBpY2FsIGhldXJpc3RpYyBjb250cmFpbnRzLFxuICAgIC8vIHRoZXJlIHNob3VsZCBiZSBubyBjaGVhcGVyIHJvdXRlIHBvc3NpYmxlLlxuICAgIHZhciBjdXRPZmYgPSBoKHN0YXJ0LCBlbmQpO1xuXG4gICAgdmFyIGosIHJvdXRlLCB0O1xuXG4gICAgLy8gV2l0aCBhbiBvdmVyZmxvdyBwcm90ZWN0aW9uLlxuICAgIGZvcihqID0gMDsgdHJ1ZTsgKytqKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJJdGVyYXRpb246IFwiICsgaiArIFwiLCBzZWFyY2ggY3V0LW9mZiB2YWx1ZTogXCIgKyBjdXRPZmYgKyBcIiwgbm9kZXMgdmlzaXRlZCB0aHVzIGZhcjogXCIgKyBub2Rlc1Zpc2l0ZWQgKyBcIi5cIik7XG5cbiAgICAgICAgcm91dGUgPSBbXTtcblxuICAgICAgICAvLyBTZWFyY2ggdGlsbCBjdXQtb2ZmIGRlcHRoOlxuICAgICAgICB0ID0gc2VhcmNoKHN0YXJ0LCAwLCBjdXRPZmYsIHJvdXRlLCAwKTtcblxuICAgICAgICAvLyBSb3V0ZSBub3QgcG9zc2libGUsIG9yIG5vdCBmb3VuZCBpbiB0aW1lIGxpbWl0LlxuICAgICAgICBpZih0ID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdCBpcyBhIG5vZGUsIGl0J3MgYWxzbyB0aGUgZW5kIG5vZGUuIFJvdXRlIGlzIG5vd1xuICAgICAgICAvLyBwb3B1bGF0ZWQgd2l0aCBhIHZhbGlkIHBhdGggdG8gdGhlIGVuZCBub2RlLlxuICAgICAgICBpZih0IGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkZpbmlzaGVkIGF0IGl0ZXJhdGlvbjogXCIgKyBqICsgXCIsIHNlYXJjaCBjdXQtb2ZmIHZhbHVlOiBcIiArIGN1dE9mZiArIFwiLCBub2RlcyB2aXNpdGVkOiBcIiArIG5vZGVzVmlzaXRlZCArIFwiLlwiKTtcbiAgICAgICAgICAgIHJldHVybiByb3V0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRyeSBhZ2FpbiwgdGhpcyB0aW1lIHdpdGggYSBkZWVwZXIgY3V0LW9mZi4gVGhlIHQgc2NvcmVcbiAgICAgICAgLy8gaXMgdGhlIGNsb3Nlc3Qgd2UgZ290IHRvIHRoZSBlbmQgbm9kZS5cbiAgICAgICAgY3V0T2ZmID0gdDtcbiAgICB9XG5cbiAgICAvLyBUaGlzIF9zaG91bGRfIG5ldmVyIHRvIGJlIHJlYWNoZWQuXG4gICAgcmV0dXJuIFtdO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJREFTdGFyRmluZGVyO1xuIiwiLyoqXG4gKiBAYXV0aG9yIGltb3IgLyBodHRwczovL2dpdGh1Yi5jb20vaW1vclxuICovXG52YXIgSnVtcFBvaW50RmluZGVyQmFzZSA9IHJlcXVpcmUoJy4vSnVtcFBvaW50RmluZGVyQmFzZScpO1xudmFyIERpYWdvbmFsTW92ZW1lbnQgPSByZXF1aXJlKCcuLi9jb3JlL0RpYWdvbmFsTW92ZW1lbnQnKTtcblxuLyoqXG4gKiBQYXRoIGZpbmRlciB1c2luZyB0aGUgSnVtcCBQb2ludCBTZWFyY2ggYWxnb3JpdGhtIHdoaWNoIGFsd2F5cyBtb3Zlc1xuICogZGlhZ29uYWxseSBpcnJlc3BlY3RpdmUgb2YgdGhlIG51bWJlciBvZiBvYnN0YWNsZXMuXG4gKi9cbmZ1bmN0aW9uIEpQRkFsd2F5c01vdmVEaWFnb25hbGx5KG9wdCkge1xuICAgIEp1bXBQb2ludEZpbmRlckJhc2UuY2FsbCh0aGlzLCBvcHQpO1xufVxuXG5KUEZBbHdheXNNb3ZlRGlhZ29uYWxseS5wcm90b3R5cGUgPSBuZXcgSnVtcFBvaW50RmluZGVyQmFzZSgpO1xuSlBGQWx3YXlzTW92ZURpYWdvbmFsbHkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSlBGQWx3YXlzTW92ZURpYWdvbmFsbHk7XG5cbi8qKlxuICogU2VhcmNoIHJlY3Vyc2l2ZWx5IGluIHRoZSBkaXJlY3Rpb24gKHBhcmVudCAtPiBjaGlsZCksIHN0b3BwaW5nIG9ubHkgd2hlbiBhXG4gKiBqdW1wIHBvaW50IGlzIGZvdW5kLlxuICogQHByb3RlY3RlZFxuICogQHJldHVybiB7QXJyYXkuPFtudW1iZXIsIG51bWJlcl0+fSBUaGUgeCwgeSBjb29yZGluYXRlIG9mIHRoZSBqdW1wIHBvaW50XG4gKiAgICAgZm91bmQsIG9yIG51bGwgaWYgbm90IGZvdW5kXG4gKi9cbkpQRkFsd2F5c01vdmVEaWFnb25hbGx5LnByb3RvdHlwZS5fanVtcCA9IGZ1bmN0aW9uKHgsIHksIHB4LCBweSkge1xuICAgIHZhciBncmlkID0gdGhpcy5ncmlkLFxuICAgICAgICBkeCA9IHggLSBweCwgZHkgPSB5IC0gcHk7XG5cbiAgICBpZiAoIWdyaWQuaXNXYWxrYWJsZUF0KHgsIHkpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmKHRoaXMudHJhY2tKdW1wUmVjdXJzaW9uID09PSB0cnVlKSB7XG4gICAgICAgIGdyaWQuZ2V0Tm9kZUF0KHgsIHkpLnRlc3RlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGdyaWQuZ2V0Tm9kZUF0KHgsIHkpID09PSB0aGlzLmVuZE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBmb3IgZm9yY2VkIG5laWdoYm9yc1xuICAgIC8vIGFsb25nIHRoZSBkaWFnb25hbFxuICAgIGlmIChkeCAhPT0gMCAmJiBkeSAhPT0gMCkge1xuICAgICAgICBpZiAoKGdyaWQuaXNXYWxrYWJsZUF0KHggLSBkeCwgeSArIGR5KSAmJiAhZ3JpZC5pc1dhbGthYmxlQXQoeCAtIGR4LCB5KSkgfHxcbiAgICAgICAgICAgIChncmlkLmlzV2Fsa2FibGVBdCh4ICsgZHgsIHkgLSBkeSkgJiYgIWdyaWQuaXNXYWxrYWJsZUF0KHgsIHkgLSBkeSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gW3gsIHldO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdoZW4gbW92aW5nIGRpYWdvbmFsbHksIG11c3QgY2hlY2sgZm9yIHZlcnRpY2FsL2hvcml6b250YWwganVtcCBwb2ludHNcbiAgICAgICAgaWYgKHRoaXMuX2p1bXAoeCArIGR4LCB5LCB4LCB5KSB8fCB0aGlzLl9qdW1wKHgsIHkgKyBkeSwgeCwgeSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbeCwgeV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gaG9yaXpvbnRhbGx5L3ZlcnRpY2FsbHlcbiAgICBlbHNlIHtcbiAgICAgICAgaWYoIGR4ICE9PSAwICkgeyAvLyBtb3ZpbmcgYWxvbmcgeFxuICAgICAgICAgICAgaWYoKGdyaWQuaXNXYWxrYWJsZUF0KHggKyBkeCwgeSArIDEpICYmICFncmlkLmlzV2Fsa2FibGVBdCh4LCB5ICsgMSkpIHx8XG4gICAgICAgICAgICAgICAoZ3JpZC5pc1dhbGthYmxlQXQoeCArIGR4LCB5IC0gMSkgJiYgIWdyaWQuaXNXYWxrYWJsZUF0KHgsIHkgLSAxKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3gsIHldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYoKGdyaWQuaXNXYWxrYWJsZUF0KHggKyAxLCB5ICsgZHkpICYmICFncmlkLmlzV2Fsa2FibGVBdCh4ICsgMSwgeSkpIHx8XG4gICAgICAgICAgICAgICAoZ3JpZC5pc1dhbGthYmxlQXQoeCAtIDEsIHkgKyBkeSkgJiYgIWdyaWQuaXNXYWxrYWJsZUF0KHggLSAxLCB5KSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3gsIHldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2p1bXAoeCArIGR4LCB5ICsgZHksIHgsIHkpO1xufTtcblxuLyoqXG4gKiBGaW5kIHRoZSBuZWlnaGJvcnMgZm9yIHRoZSBnaXZlbiBub2RlLiBJZiB0aGUgbm9kZSBoYXMgYSBwYXJlbnQsXG4gKiBwcnVuZSB0aGUgbmVpZ2hib3JzIGJhc2VkIG9uIHRoZSBqdW1wIHBvaW50IHNlYXJjaCBhbGdvcml0aG0sIG90aGVyd2lzZVxuICogcmV0dXJuIGFsbCBhdmFpbGFibGUgbmVpZ2hib3JzLlxuICogQHJldHVybiB7QXJyYXkuPFtudW1iZXIsIG51bWJlcl0+fSBUaGUgbmVpZ2hib3JzIGZvdW5kLlxuICovXG5KUEZBbHdheXNNb3ZlRGlhZ29uYWxseS5wcm90b3R5cGUuX2ZpbmROZWlnaGJvcnMgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50LFxuICAgICAgICB4ID0gbm9kZS54LCB5ID0gbm9kZS55LFxuICAgICAgICBncmlkID0gdGhpcy5ncmlkLFxuICAgICAgICBweCwgcHksIG54LCBueSwgZHgsIGR5LFxuICAgICAgICBuZWlnaGJvcnMgPSBbXSwgbmVpZ2hib3JOb2RlcywgbmVpZ2hib3JOb2RlLCBpLCBsO1xuXG4gICAgLy8gZGlyZWN0ZWQgcHJ1bmluZzogY2FuIGlnbm9yZSBtb3N0IG5laWdoYm9ycywgdW5sZXNzIGZvcmNlZC5cbiAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIHB4ID0gcGFyZW50Lng7XG4gICAgICAgIHB5ID0gcGFyZW50Lnk7XG4gICAgICAgIC8vIGdldCB0aGUgbm9ybWFsaXplZCBkaXJlY3Rpb24gb2YgdHJhdmVsXG4gICAgICAgIGR4ID0gKHggLSBweCkgLyBNYXRoLm1heChNYXRoLmFicyh4IC0gcHgpLCAxKTtcbiAgICAgICAgZHkgPSAoeSAtIHB5KSAvIE1hdGgubWF4KE1hdGguYWJzKHkgLSBweSksIDEpO1xuXG4gICAgICAgIC8vIHNlYXJjaCBkaWFnb25hbGx5XG4gICAgICAgIGlmIChkeCAhPT0gMCAmJiBkeSAhPT0gMCkge1xuICAgICAgICAgICAgaWYgKGdyaWQuaXNXYWxrYWJsZUF0KHgsIHkgKyBkeSkpIHtcbiAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCwgeSArIGR5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JpZC5pc1dhbGthYmxlQXQoeCArIGR4LCB5KSkge1xuICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKFt4ICsgZHgsIHldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncmlkLmlzV2Fsa2FibGVBdCh4ICsgZHgsIHkgKyBkeSkpIHtcbiAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCArIGR4LCB5ICsgZHldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZ3JpZC5pc1dhbGthYmxlQXQoeCAtIGR4LCB5KSkge1xuICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKFt4IC0gZHgsIHkgKyBkeV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFncmlkLmlzV2Fsa2FibGVBdCh4LCB5IC0gZHkpKSB7XG4gICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3ggKyBkeCwgeSAtIGR5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2VhcmNoIGhvcml6b250YWxseS92ZXJ0aWNhbGx5XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYoZHggPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoZ3JpZC5pc1dhbGthYmxlQXQoeCwgeSArIGR5KSkge1xuICAgICAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCwgeSArIGR5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZ3JpZC5pc1dhbGthYmxlQXQoeCArIDEsIHkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKFt4ICsgMSwgeSArIGR5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZ3JpZC5pc1dhbGthYmxlQXQoeCAtIDEsIHkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKFt4IC0gMSwgeSArIGR5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGdyaWQuaXNXYWxrYWJsZUF0KHggKyBkeCwgeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3ggKyBkeCwgeV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWdyaWQuaXNXYWxrYWJsZUF0KHgsIHkgKyAxKSkge1xuICAgICAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCArIGR4LCB5ICsgMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWdyaWQuaXNXYWxrYWJsZUF0KHgsIHkgLSAxKSkge1xuICAgICAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCArIGR4LCB5IC0gMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyByZXR1cm4gYWxsIG5laWdoYm9yc1xuICAgIGVsc2Uge1xuICAgICAgICBuZWlnaGJvck5vZGVzID0gZ3JpZC5nZXROZWlnaGJvcnMobm9kZSwgRGlhZ29uYWxNb3ZlbWVudC5BbHdheXMpO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gbmVpZ2hib3JOb2Rlcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIG5laWdoYm9yTm9kZSA9IG5laWdoYm9yTm9kZXNbaV07XG4gICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbbmVpZ2hib3JOb2RlLngsIG5laWdoYm9yTm9kZS55XSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmVpZ2hib3JzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBKUEZBbHdheXNNb3ZlRGlhZ29uYWxseTtcbiIsIi8qKlxuICogQGF1dGhvciBpbW9yIC8gaHR0cHM6Ly9naXRodWIuY29tL2ltb3JcbiAqL1xudmFyIEp1bXBQb2ludEZpbmRlckJhc2UgPSByZXF1aXJlKCcuL0p1bXBQb2ludEZpbmRlckJhc2UnKTtcbnZhciBEaWFnb25hbE1vdmVtZW50ID0gcmVxdWlyZSgnLi4vY29yZS9EaWFnb25hbE1vdmVtZW50Jyk7XG5cbi8qKlxuICogUGF0aCBmaW5kZXIgdXNpbmcgdGhlIEp1bXAgUG9pbnQgU2VhcmNoIGFsZ29yaXRobSB3aGljaCBtb3Zlc1xuICogZGlhZ29uYWxseSBvbmx5IHdoZW4gdGhlcmUgaXMgYXQgbW9zdCBvbmUgb2JzdGFjbGUuXG4gKi9cbmZ1bmN0aW9uIEpQRk1vdmVEaWFnb25hbGx5SWZBdE1vc3RPbmVPYnN0YWNsZShvcHQpIHtcbiAgICBKdW1wUG9pbnRGaW5kZXJCYXNlLmNhbGwodGhpcywgb3B0KTtcbn1cblxuSlBGTW92ZURpYWdvbmFsbHlJZkF0TW9zdE9uZU9ic3RhY2xlLnByb3RvdHlwZSA9IG5ldyBKdW1wUG9pbnRGaW5kZXJCYXNlKCk7XG5KUEZNb3ZlRGlhZ29uYWxseUlmQXRNb3N0T25lT2JzdGFjbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSlBGTW92ZURpYWdvbmFsbHlJZkF0TW9zdE9uZU9ic3RhY2xlO1xuXG4vKipcbiAqIFNlYXJjaCByZWN1cnNpdmVseSBpbiB0aGUgZGlyZWN0aW9uIChwYXJlbnQgLT4gY2hpbGQpLCBzdG9wcGluZyBvbmx5IHdoZW4gYVxuICoganVtcCBwb2ludCBpcyBmb3VuZC5cbiAqIEBwcm90ZWN0ZWRcbiAqIEByZXR1cm4ge0FycmF5LjxbbnVtYmVyLCBudW1iZXJdPn0gVGhlIHgsIHkgY29vcmRpbmF0ZSBvZiB0aGUganVtcCBwb2ludFxuICogICAgIGZvdW5kLCBvciBudWxsIGlmIG5vdCBmb3VuZFxuICovXG5KUEZNb3ZlRGlhZ29uYWxseUlmQXRNb3N0T25lT2JzdGFjbGUucHJvdG90eXBlLl9qdW1wID0gZnVuY3Rpb24oeCwgeSwgcHgsIHB5KSB7XG4gICAgdmFyIGdyaWQgPSB0aGlzLmdyaWQsXG4gICAgICAgIGR4ID0geCAtIHB4LCBkeSA9IHkgLSBweTtcblxuICAgIGlmICghZ3JpZC5pc1dhbGthYmxlQXQoeCwgeSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYodGhpcy50cmFja0p1bXBSZWN1cnNpb24gPT09IHRydWUpIHtcbiAgICAgICAgZ3JpZC5nZXROb2RlQXQoeCwgeSkudGVzdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoZ3JpZC5nZXROb2RlQXQoeCwgeSkgPT09IHRoaXMuZW5kTm9kZSkge1xuICAgICAgICByZXR1cm4gW3gsIHldO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGZvciBmb3JjZWQgbmVpZ2hib3JzXG4gICAgLy8gYWxvbmcgdGhlIGRpYWdvbmFsXG4gICAgaWYgKGR4ICE9PSAwICYmIGR5ICE9PSAwKSB7XG4gICAgICAgIGlmICgoZ3JpZC5pc1dhbGthYmxlQXQoeCAtIGR4LCB5ICsgZHkpICYmICFncmlkLmlzV2Fsa2FibGVBdCh4IC0gZHgsIHkpKSB8fFxuICAgICAgICAgICAgKGdyaWQuaXNXYWxrYWJsZUF0KHggKyBkeCwgeSAtIGR5KSAmJiAhZ3JpZC5pc1dhbGthYmxlQXQoeCwgeSAtIGR5KSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbeCwgeV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2hlbiBtb3ZpbmcgZGlhZ29uYWxseSwgbXVzdCBjaGVjayBmb3IgdmVydGljYWwvaG9yaXpvbnRhbCBqdW1wIHBvaW50c1xuICAgICAgICBpZiAodGhpcy5fanVtcCh4ICsgZHgsIHksIHgsIHkpIHx8IHRoaXMuX2p1bXAoeCwgeSArIGR5LCB4LCB5KSkge1xuICAgICAgICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBob3Jpem9udGFsbHkvdmVydGljYWxseVxuICAgIGVsc2Uge1xuICAgICAgICBpZiggZHggIT09IDAgKSB7IC8vIG1vdmluZyBhbG9uZyB4XG4gICAgICAgICAgICBpZigoZ3JpZC5pc1dhbGthYmxlQXQoeCArIGR4LCB5ICsgMSkgJiYgIWdyaWQuaXNXYWxrYWJsZUF0KHgsIHkgKyAxKSkgfHxcbiAgICAgICAgICAgICAgIChncmlkLmlzV2Fsa2FibGVBdCh4ICsgZHgsIHkgLSAxKSAmJiAhZ3JpZC5pc1dhbGthYmxlQXQoeCwgeSAtIDEpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbeCwgeV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZigoZ3JpZC5pc1dhbGthYmxlQXQoeCArIDEsIHkgKyBkeSkgJiYgIWdyaWQuaXNXYWxrYWJsZUF0KHggKyAxLCB5KSkgfHxcbiAgICAgICAgICAgICAgIChncmlkLmlzV2Fsa2FibGVBdCh4IC0gMSwgeSArIGR5KSAmJiAhZ3JpZC5pc1dhbGthYmxlQXQoeCAtIDEsIHkpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbeCwgeV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBtb3ZpbmcgZGlhZ29uYWxseSwgbXVzdCBtYWtlIHN1cmUgb25lIG9mIHRoZSB2ZXJ0aWNhbC9ob3Jpem9udGFsXG4gICAgLy8gbmVpZ2hib3JzIGlzIG9wZW4gdG8gYWxsb3cgdGhlIHBhdGhcbiAgICBpZiAoZ3JpZC5pc1dhbGthYmxlQXQoeCArIGR4LCB5KSB8fCBncmlkLmlzV2Fsa2FibGVBdCh4LCB5ICsgZHkpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9qdW1wKHggKyBkeCwgeSArIGR5LCB4LCB5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuXG4vKipcbiAqIEZpbmQgdGhlIG5laWdoYm9ycyBmb3IgdGhlIGdpdmVuIG5vZGUuIElmIHRoZSBub2RlIGhhcyBhIHBhcmVudCxcbiAqIHBydW5lIHRoZSBuZWlnaGJvcnMgYmFzZWQgb24gdGhlIGp1bXAgcG9pbnQgc2VhcmNoIGFsZ29yaXRobSwgb3RoZXJ3aXNlXG4gKiByZXR1cm4gYWxsIGF2YWlsYWJsZSBuZWlnaGJvcnMuXG4gKiBAcmV0dXJuIHtBcnJheS48W251bWJlciwgbnVtYmVyXT59IFRoZSBuZWlnaGJvcnMgZm91bmQuXG4gKi9cbkpQRk1vdmVEaWFnb25hbGx5SWZBdE1vc3RPbmVPYnN0YWNsZS5wcm90b3R5cGUuX2ZpbmROZWlnaGJvcnMgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50LFxuICAgICAgICB4ID0gbm9kZS54LCB5ID0gbm9kZS55LFxuICAgICAgICBncmlkID0gdGhpcy5ncmlkLFxuICAgICAgICBweCwgcHksIG54LCBueSwgZHgsIGR5LFxuICAgICAgICBuZWlnaGJvcnMgPSBbXSwgbmVpZ2hib3JOb2RlcywgbmVpZ2hib3JOb2RlLCBpLCBsO1xuXG4gICAgLy8gZGlyZWN0ZWQgcHJ1bmluZzogY2FuIGlnbm9yZSBtb3N0IG5laWdoYm9ycywgdW5sZXNzIGZvcmNlZC5cbiAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIHB4ID0gcGFyZW50Lng7XG4gICAgICAgIHB5ID0gcGFyZW50Lnk7XG4gICAgICAgIC8vIGdldCB0aGUgbm9ybWFsaXplZCBkaXJlY3Rpb24gb2YgdHJhdmVsXG4gICAgICAgIGR4ID0gKHggLSBweCkgLyBNYXRoLm1heChNYXRoLmFicyh4IC0gcHgpLCAxKTtcbiAgICAgICAgZHkgPSAoeSAtIHB5KSAvIE1hdGgubWF4KE1hdGguYWJzKHkgLSBweSksIDEpO1xuXG4gICAgICAgIC8vIHNlYXJjaCBkaWFnb25hbGx5XG4gICAgICAgIGlmIChkeCAhPT0gMCAmJiBkeSAhPT0gMCkge1xuICAgICAgICAgICAgaWYgKGdyaWQuaXNXYWxrYWJsZUF0KHgsIHkgKyBkeSkpIHtcbiAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCwgeSArIGR5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JpZC5pc1dhbGthYmxlQXQoeCArIGR4LCB5KSkge1xuICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKFt4ICsgZHgsIHldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncmlkLmlzV2Fsa2FibGVBdCh4LCB5ICsgZHkpIHx8IGdyaWQuaXNXYWxrYWJsZUF0KHggKyBkeCwgeSkpIHtcbiAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCArIGR4LCB5ICsgZHldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZ3JpZC5pc1dhbGthYmxlQXQoeCAtIGR4LCB5KSAmJiBncmlkLmlzV2Fsa2FibGVBdCh4LCB5ICsgZHkpKSB7XG4gICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3ggLSBkeCwgeSArIGR5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWdyaWQuaXNXYWxrYWJsZUF0KHgsIHkgLSBkeSkgJiYgZ3JpZC5pc1dhbGthYmxlQXQoeCArIGR4LCB5KSkge1xuICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKFt4ICsgZHgsIHkgLSBkeV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHNlYXJjaCBob3Jpem9udGFsbHkvdmVydGljYWxseVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmKGR4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdyaWQuaXNXYWxrYWJsZUF0KHgsIHkgKyBkeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3gsIHkgKyBkeV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWdyaWQuaXNXYWxrYWJsZUF0KHggKyAxLCB5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3ggKyAxLCB5ICsgZHldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWdyaWQuaXNXYWxrYWJsZUF0KHggLSAxLCB5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3ggLSAxLCB5ICsgZHldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChncmlkLmlzV2Fsa2FibGVBdCh4ICsgZHgsIHkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKFt4ICsgZHgsIHldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFncmlkLmlzV2Fsa2FibGVBdCh4LCB5ICsgMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKFt4ICsgZHgsIHkgKyAxXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFncmlkLmlzV2Fsa2FibGVBdCh4LCB5IC0gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKFt4ICsgZHgsIHkgLSAxXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gcmV0dXJuIGFsbCBuZWlnaGJvcnNcbiAgICBlbHNlIHtcbiAgICAgICAgbmVpZ2hib3JOb2RlcyA9IGdyaWQuZ2V0TmVpZ2hib3JzKG5vZGUsIERpYWdvbmFsTW92ZW1lbnQuSWZBdE1vc3RPbmVPYnN0YWNsZSk7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBuZWlnaGJvck5vZGVzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgbmVpZ2hib3JOb2RlID0gbmVpZ2hib3JOb2Rlc1tpXTtcbiAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKFtuZWlnaGJvck5vZGUueCwgbmVpZ2hib3JOb2RlLnldKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZWlnaGJvcnM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpQRk1vdmVEaWFnb25hbGx5SWZBdE1vc3RPbmVPYnN0YWNsZTtcbiIsIi8qKlxuICogQGF1dGhvciBpbW9yIC8gaHR0cHM6Ly9naXRodWIuY29tL2ltb3JcbiAqL1xudmFyIEp1bXBQb2ludEZpbmRlckJhc2UgPSByZXF1aXJlKCcuL0p1bXBQb2ludEZpbmRlckJhc2UnKTtcbnZhciBEaWFnb25hbE1vdmVtZW50ID0gcmVxdWlyZSgnLi4vY29yZS9EaWFnb25hbE1vdmVtZW50Jyk7XG5cbi8qKlxuICogUGF0aCBmaW5kZXIgdXNpbmcgdGhlIEp1bXAgUG9pbnQgU2VhcmNoIGFsZ29yaXRobSB3aGljaCBtb3Zlc1xuICogZGlhZ29uYWxseSBvbmx5IHdoZW4gdGhlcmUgYXJlIG5vIG9ic3RhY2xlcy5cbiAqL1xuZnVuY3Rpb24gSlBGTW92ZURpYWdvbmFsbHlJZk5vT2JzdGFjbGVzKG9wdCkge1xuICAgIEp1bXBQb2ludEZpbmRlckJhc2UuY2FsbCh0aGlzLCBvcHQpO1xufVxuXG5KUEZNb3ZlRGlhZ29uYWxseUlmTm9PYnN0YWNsZXMucHJvdG90eXBlID0gbmV3IEp1bXBQb2ludEZpbmRlckJhc2UoKTtcbkpQRk1vdmVEaWFnb25hbGx5SWZOb09ic3RhY2xlcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBKUEZNb3ZlRGlhZ29uYWxseUlmTm9PYnN0YWNsZXM7XG5cbi8qKlxuICogU2VhcmNoIHJlY3Vyc2l2ZWx5IGluIHRoZSBkaXJlY3Rpb24gKHBhcmVudCAtPiBjaGlsZCksIHN0b3BwaW5nIG9ubHkgd2hlbiBhXG4gKiBqdW1wIHBvaW50IGlzIGZvdW5kLlxuICogQHByb3RlY3RlZFxuICogQHJldHVybiB7QXJyYXkuPFtudW1iZXIsIG51bWJlcl0+fSBUaGUgeCwgeSBjb29yZGluYXRlIG9mIHRoZSBqdW1wIHBvaW50XG4gKiAgICAgZm91bmQsIG9yIG51bGwgaWYgbm90IGZvdW5kXG4gKi9cbkpQRk1vdmVEaWFnb25hbGx5SWZOb09ic3RhY2xlcy5wcm90b3R5cGUuX2p1bXAgPSBmdW5jdGlvbih4LCB5LCBweCwgcHkpIHtcbiAgICB2YXIgZ3JpZCA9IHRoaXMuZ3JpZCxcbiAgICAgICAgZHggPSB4IC0gcHgsIGR5ID0geSAtIHB5O1xuXG4gICAgaWYgKCFncmlkLmlzV2Fsa2FibGVBdCh4LCB5KSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZih0aGlzLnRyYWNrSnVtcFJlY3Vyc2lvbiA9PT0gdHJ1ZSkge1xuICAgICAgICBncmlkLmdldE5vZGVBdCh4LCB5KS50ZXN0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChncmlkLmdldE5vZGVBdCh4LCB5KSA9PT0gdGhpcy5lbmROb2RlKSB7XG4gICAgICAgIHJldHVybiBbeCwgeV07XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgZm9yIGZvcmNlZCBuZWlnaGJvcnNcbiAgICAvLyBhbG9uZyB0aGUgZGlhZ29uYWxcbiAgICBpZiAoZHggIT09IDAgJiYgZHkgIT09IDApIHtcbiAgICAgICAgLy8gaWYgKChncmlkLmlzV2Fsa2FibGVBdCh4IC0gZHgsIHkgKyBkeSkgJiYgIWdyaWQuaXNXYWxrYWJsZUF0KHggLSBkeCwgeSkpIHx8XG4gICAgICAgICAgICAvLyAoZ3JpZC5pc1dhbGthYmxlQXQoeCArIGR4LCB5IC0gZHkpICYmICFncmlkLmlzV2Fsa2FibGVBdCh4LCB5IC0gZHkpKSkge1xuICAgICAgICAgICAgLy8gcmV0dXJuIFt4LCB5XTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyB3aGVuIG1vdmluZyBkaWFnb25hbGx5LCBtdXN0IGNoZWNrIGZvciB2ZXJ0aWNhbC9ob3Jpem9udGFsIGp1bXAgcG9pbnRzXG4gICAgICAgIGlmICh0aGlzLl9qdW1wKHggKyBkeCwgeSwgeCwgeSkgfHwgdGhpcy5fanVtcCh4LCB5ICsgZHksIHgsIHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gW3gsIHldO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGhvcml6b250YWxseS92ZXJ0aWNhbGx5XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChkeCAhPT0gMCkge1xuICAgICAgICAgICAgaWYgKChncmlkLmlzV2Fsa2FibGVBdCh4LCB5IC0gMSkgJiYgIWdyaWQuaXNXYWxrYWJsZUF0KHggLSBkeCwgeSAtIDEpKSB8fFxuICAgICAgICAgICAgICAgIChncmlkLmlzV2Fsa2FibGVBdCh4LCB5ICsgMSkgJiYgIWdyaWQuaXNXYWxrYWJsZUF0KHggLSBkeCwgeSArIDEpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbeCwgeV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZHkgIT09IDApIHtcbiAgICAgICAgICAgIGlmICgoZ3JpZC5pc1dhbGthYmxlQXQoeCAtIDEsIHkpICYmICFncmlkLmlzV2Fsa2FibGVBdCh4IC0gMSwgeSAtIGR5KSkgfHxcbiAgICAgICAgICAgICAgICAoZ3JpZC5pc1dhbGthYmxlQXQoeCArIDEsIHkpICYmICFncmlkLmlzV2Fsa2FibGVBdCh4ICsgMSwgeSAtIGR5KSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3gsIHldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2hlbiBtb3ZpbmcgdmVydGljYWxseSwgbXVzdCBjaGVjayBmb3IgaG9yaXpvbnRhbCBqdW1wIHBvaW50c1xuICAgICAgICAgICAgLy8gaWYgKHRoaXMuX2p1bXAoeCArIDEsIHksIHgsIHkpIHx8IHRoaXMuX2p1bXAoeCAtIDEsIHksIHgsIHkpKSB7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIFt4LCB5XTtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIG1vdmluZyBkaWFnb25hbGx5LCBtdXN0IG1ha2Ugc3VyZSBvbmUgb2YgdGhlIHZlcnRpY2FsL2hvcml6b250YWxcbiAgICAvLyBuZWlnaGJvcnMgaXMgb3BlbiB0byBhbGxvdyB0aGUgcGF0aFxuICAgIGlmIChncmlkLmlzV2Fsa2FibGVBdCh4ICsgZHgsIHkpICYmIGdyaWQuaXNXYWxrYWJsZUF0KHgsIHkgKyBkeSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2p1bXAoeCArIGR4LCB5ICsgZHksIHgsIHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5cbi8qKlxuICogRmluZCB0aGUgbmVpZ2hib3JzIGZvciB0aGUgZ2l2ZW4gbm9kZS4gSWYgdGhlIG5vZGUgaGFzIGEgcGFyZW50LFxuICogcHJ1bmUgdGhlIG5laWdoYm9ycyBiYXNlZCBvbiB0aGUganVtcCBwb2ludCBzZWFyY2ggYWxnb3JpdGhtLCBvdGhlcndpc2VcbiAqIHJldHVybiBhbGwgYXZhaWxhYmxlIG5laWdoYm9ycy5cbiAqIEByZXR1cm4ge0FycmF5LjxbbnVtYmVyLCBudW1iZXJdPn0gVGhlIG5laWdoYm9ycyBmb3VuZC5cbiAqL1xuSlBGTW92ZURpYWdvbmFsbHlJZk5vT2JzdGFjbGVzLnByb3RvdHlwZS5fZmluZE5laWdoYm9ycyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnQsXG4gICAgICAgIHggPSBub2RlLngsIHkgPSBub2RlLnksXG4gICAgICAgIGdyaWQgPSB0aGlzLmdyaWQsXG4gICAgICAgIHB4LCBweSwgbngsIG55LCBkeCwgZHksXG4gICAgICAgIG5laWdoYm9ycyA9IFtdLCBuZWlnaGJvck5vZGVzLCBuZWlnaGJvck5vZGUsIGksIGw7XG5cbiAgICAvLyBkaXJlY3RlZCBwcnVuaW5nOiBjYW4gaWdub3JlIG1vc3QgbmVpZ2hib3JzLCB1bmxlc3MgZm9yY2VkLlxuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgcHggPSBwYXJlbnQueDtcbiAgICAgICAgcHkgPSBwYXJlbnQueTtcbiAgICAgICAgLy8gZ2V0IHRoZSBub3JtYWxpemVkIGRpcmVjdGlvbiBvZiB0cmF2ZWxcbiAgICAgICAgZHggPSAoeCAtIHB4KSAvIE1hdGgubWF4KE1hdGguYWJzKHggLSBweCksIDEpO1xuICAgICAgICBkeSA9ICh5IC0gcHkpIC8gTWF0aC5tYXgoTWF0aC5hYnMoeSAtIHB5KSwgMSk7XG5cbiAgICAgICAgLy8gc2VhcmNoIGRpYWdvbmFsbHlcbiAgICAgICAgaWYgKGR4ICE9PSAwICYmIGR5ICE9PSAwKSB7XG4gICAgICAgICAgICBpZiAoZ3JpZC5pc1dhbGthYmxlQXQoeCwgeSArIGR5KSkge1xuICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKFt4LCB5ICsgZHldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncmlkLmlzV2Fsa2FibGVBdCh4ICsgZHgsIHkpKSB7XG4gICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3ggKyBkeCwgeV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyaWQuaXNXYWxrYWJsZUF0KHgsIHkgKyBkeSkgJiYgZ3JpZC5pc1dhbGthYmxlQXQoeCArIGR4LCB5KSkge1xuICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKFt4ICsgZHgsIHkgKyBkeV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHNlYXJjaCBob3Jpem9udGFsbHkvdmVydGljYWxseVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpc05leHRXYWxrYWJsZTtcbiAgICAgICAgICAgIGlmIChkeCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGlzTmV4dFdhbGthYmxlID0gZ3JpZC5pc1dhbGthYmxlQXQoeCArIGR4LCB5KTtcbiAgICAgICAgICAgICAgICB2YXIgaXNUb3BXYWxrYWJsZSA9IGdyaWQuaXNXYWxrYWJsZUF0KHgsIHkgKyAxKTtcbiAgICAgICAgICAgICAgICB2YXIgaXNCb3R0b21XYWxrYWJsZSA9IGdyaWQuaXNXYWxrYWJsZUF0KHgsIHkgLSAxKTtcblxuICAgICAgICAgICAgICAgIGlmIChpc05leHRXYWxrYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCArIGR4LCB5XSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1RvcFdhbGthYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCArIGR4LCB5ICsgMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0JvdHRvbVdhbGthYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCArIGR4LCB5IC0gMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc1RvcFdhbGthYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKFt4LCB5ICsgMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNCb3R0b21XYWxrYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCwgeSAtIDFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkeSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGlzTmV4dFdhbGthYmxlID0gZ3JpZC5pc1dhbGthYmxlQXQoeCwgeSArIGR5KTtcbiAgICAgICAgICAgICAgICB2YXIgaXNSaWdodFdhbGthYmxlID0gZ3JpZC5pc1dhbGthYmxlQXQoeCArIDEsIHkpO1xuICAgICAgICAgICAgICAgIHZhciBpc0xlZnRXYWxrYWJsZSA9IGdyaWQuaXNXYWxrYWJsZUF0KHggLSAxLCB5KTtcblxuICAgICAgICAgICAgICAgIGlmIChpc05leHRXYWxrYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCwgeSArIGR5XSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1JpZ2h0V2Fsa2FibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKFt4ICsgMSwgeSArIGR5XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTGVmdFdhbGthYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCAtIDEsIHkgKyBkeV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc1JpZ2h0V2Fsa2FibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3ggKyAxLCB5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc0xlZnRXYWxrYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCAtIDEsIHldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gcmV0dXJuIGFsbCBuZWlnaGJvcnNcbiAgICBlbHNlIHtcbiAgICAgICAgbmVpZ2hib3JOb2RlcyA9IGdyaWQuZ2V0TmVpZ2hib3JzKG5vZGUsIERpYWdvbmFsTW92ZW1lbnQuT25seVdoZW5Ob09ic3RhY2xlcyk7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBuZWlnaGJvck5vZGVzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgbmVpZ2hib3JOb2RlID0gbmVpZ2hib3JOb2Rlc1tpXTtcbiAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKFtuZWlnaGJvck5vZGUueCwgbmVpZ2hib3JOb2RlLnldKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZWlnaGJvcnM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpQRk1vdmVEaWFnb25hbGx5SWZOb09ic3RhY2xlcztcbiIsIi8qKlxuICogQGF1dGhvciBpbW9yIC8gaHR0cHM6Ly9naXRodWIuY29tL2ltb3JcbiAqL1xudmFyIEp1bXBQb2ludEZpbmRlckJhc2UgPSByZXF1aXJlKCcuL0p1bXBQb2ludEZpbmRlckJhc2UnKTtcbnZhciBEaWFnb25hbE1vdmVtZW50ID0gcmVxdWlyZSgnLi4vY29yZS9EaWFnb25hbE1vdmVtZW50Jyk7XG5cbi8qKlxuICogUGF0aCBmaW5kZXIgdXNpbmcgdGhlIEp1bXAgUG9pbnQgU2VhcmNoIGFsZ29yaXRobSBhbGxvd2luZyBvbmx5IGhvcml6b250YWxcbiAqIG9yIHZlcnRpY2FsIG1vdmVtZW50cy5cbiAqL1xuZnVuY3Rpb24gSlBGTmV2ZXJNb3ZlRGlhZ29uYWxseShvcHQpIHtcbiAgICBKdW1wUG9pbnRGaW5kZXJCYXNlLmNhbGwodGhpcywgb3B0KTtcbn1cblxuSlBGTmV2ZXJNb3ZlRGlhZ29uYWxseS5wcm90b3R5cGUgPSBuZXcgSnVtcFBvaW50RmluZGVyQmFzZSgpO1xuSlBGTmV2ZXJNb3ZlRGlhZ29uYWxseS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBKUEZOZXZlck1vdmVEaWFnb25hbGx5O1xuXG4vKipcbiAqIFNlYXJjaCByZWN1cnNpdmVseSBpbiB0aGUgZGlyZWN0aW9uIChwYXJlbnQgLT4gY2hpbGQpLCBzdG9wcGluZyBvbmx5IHdoZW4gYVxuICoganVtcCBwb2ludCBpcyBmb3VuZC5cbiAqIEBwcm90ZWN0ZWRcbiAqIEByZXR1cm4ge0FycmF5LjxbbnVtYmVyLCBudW1iZXJdPn0gVGhlIHgsIHkgY29vcmRpbmF0ZSBvZiB0aGUganVtcCBwb2ludFxuICogICAgIGZvdW5kLCBvciBudWxsIGlmIG5vdCBmb3VuZFxuICovXG5KUEZOZXZlck1vdmVEaWFnb25hbGx5LnByb3RvdHlwZS5fanVtcCA9IGZ1bmN0aW9uKHgsIHksIHB4LCBweSkge1xuICAgIHZhciBncmlkID0gdGhpcy5ncmlkLFxuICAgICAgICBkeCA9IHggLSBweCwgZHkgPSB5IC0gcHk7XG5cbiAgICBpZiAoIWdyaWQuaXNXYWxrYWJsZUF0KHgsIHkpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmKHRoaXMudHJhY2tKdW1wUmVjdXJzaW9uID09PSB0cnVlKSB7XG4gICAgICAgIGdyaWQuZ2V0Tm9kZUF0KHgsIHkpLnRlc3RlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGdyaWQuZ2V0Tm9kZUF0KHgsIHkpID09PSB0aGlzLmVuZE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICB9XG5cbiAgICBpZiAoZHggIT09IDApIHtcbiAgICAgICAgaWYgKChncmlkLmlzV2Fsa2FibGVBdCh4LCB5IC0gMSkgJiYgIWdyaWQuaXNXYWxrYWJsZUF0KHggLSBkeCwgeSAtIDEpKSB8fFxuICAgICAgICAgICAgKGdyaWQuaXNXYWxrYWJsZUF0KHgsIHkgKyAxKSAmJiAhZ3JpZC5pc1dhbGthYmxlQXQoeCAtIGR4LCB5ICsgMSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gW3gsIHldO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGR5ICE9PSAwKSB7XG4gICAgICAgIGlmICgoZ3JpZC5pc1dhbGthYmxlQXQoeCAtIDEsIHkpICYmICFncmlkLmlzV2Fsa2FibGVBdCh4IC0gMSwgeSAtIGR5KSkgfHxcbiAgICAgICAgICAgIChncmlkLmlzV2Fsa2FibGVBdCh4ICsgMSwgeSkgJiYgIWdyaWQuaXNXYWxrYWJsZUF0KHggKyAxLCB5IC0gZHkpKSkge1xuICAgICAgICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICAgICAgfVxuICAgICAgICAvL1doZW4gbW92aW5nIHZlcnRpY2FsbHksIG11c3QgY2hlY2sgZm9yIGhvcml6b250YWwganVtcCBwb2ludHNcbiAgICAgICAgaWYgKHRoaXMuX2p1bXAoeCArIDEsIHksIHgsIHkpIHx8IHRoaXMuX2p1bXAoeCAtIDEsIHksIHgsIHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gW3gsIHldO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IGhvcml6b250YWwgYW5kIHZlcnRpY2FsIG1vdmVtZW50cyBhcmUgYWxsb3dlZFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fanVtcCh4ICsgZHgsIHkgKyBkeSwgeCwgeSk7XG59O1xuXG4vKipcbiAqIEZpbmQgdGhlIG5laWdoYm9ycyBmb3IgdGhlIGdpdmVuIG5vZGUuIElmIHRoZSBub2RlIGhhcyBhIHBhcmVudCxcbiAqIHBydW5lIHRoZSBuZWlnaGJvcnMgYmFzZWQgb24gdGhlIGp1bXAgcG9pbnQgc2VhcmNoIGFsZ29yaXRobSwgb3RoZXJ3aXNlXG4gKiByZXR1cm4gYWxsIGF2YWlsYWJsZSBuZWlnaGJvcnMuXG4gKiBAcmV0dXJuIHtBcnJheS48W251bWJlciwgbnVtYmVyXT59IFRoZSBuZWlnaGJvcnMgZm91bmQuXG4gKi9cbkpQRk5ldmVyTW92ZURpYWdvbmFsbHkucHJvdG90eXBlLl9maW5kTmVpZ2hib3JzID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHZhciBwYXJlbnQgPSBub2RlLnBhcmVudCxcbiAgICAgICAgeCA9IG5vZGUueCwgeSA9IG5vZGUueSxcbiAgICAgICAgZ3JpZCA9IHRoaXMuZ3JpZCxcbiAgICAgICAgcHgsIHB5LCBueCwgbnksIGR4LCBkeSxcbiAgICAgICAgbmVpZ2hib3JzID0gW10sIG5laWdoYm9yTm9kZXMsIG5laWdoYm9yTm9kZSwgaSwgbDtcblxuICAgIC8vIGRpcmVjdGVkIHBydW5pbmc6IGNhbiBpZ25vcmUgbW9zdCBuZWlnaGJvcnMsIHVubGVzcyBmb3JjZWQuXG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgICBweCA9IHBhcmVudC54O1xuICAgICAgICBweSA9IHBhcmVudC55O1xuICAgICAgICAvLyBnZXQgdGhlIG5vcm1hbGl6ZWQgZGlyZWN0aW9uIG9mIHRyYXZlbFxuICAgICAgICBkeCA9ICh4IC0gcHgpIC8gTWF0aC5tYXgoTWF0aC5hYnMoeCAtIHB4KSwgMSk7XG4gICAgICAgIGR5ID0gKHkgLSBweSkgLyBNYXRoLm1heChNYXRoLmFicyh5IC0gcHkpLCAxKTtcblxuICAgICAgICBpZiAoZHggIT09IDApIHtcbiAgICAgICAgICAgIGlmIChncmlkLmlzV2Fsa2FibGVBdCh4LCB5IC0gMSkpIHtcbiAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCwgeSAtIDFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncmlkLmlzV2Fsa2FibGVBdCh4LCB5ICsgMSkpIHtcbiAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCwgeSArIDFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncmlkLmlzV2Fsa2FibGVBdCh4ICsgZHgsIHkpKSB7XG4gICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3ggKyBkeCwgeV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGR5ICE9PSAwKSB7XG4gICAgICAgICAgICBpZiAoZ3JpZC5pc1dhbGthYmxlQXQoeCAtIDEsIHkpKSB7XG4gICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3ggLSAxLCB5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JpZC5pc1dhbGthYmxlQXQoeCArIDEsIHkpKSB7XG4gICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3ggKyAxLCB5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JpZC5pc1dhbGthYmxlQXQoeCwgeSArIGR5KSkge1xuICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKFt4LCB5ICsgZHldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyByZXR1cm4gYWxsIG5laWdoYm9yc1xuICAgIGVsc2Uge1xuICAgICAgICBuZWlnaGJvck5vZGVzID0gZ3JpZC5nZXROZWlnaGJvcnMobm9kZSwgRGlhZ29uYWxNb3ZlbWVudC5OZXZlcik7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBuZWlnaGJvck5vZGVzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgbmVpZ2hib3JOb2RlID0gbmVpZ2hib3JOb2Rlc1tpXTtcbiAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKFtuZWlnaGJvck5vZGUueCwgbmVpZ2hib3JOb2RlLnldKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZWlnaGJvcnM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpQRk5ldmVyTW92ZURpYWdvbmFsbHk7XG4iLCIvKipcbiAqIEBhdXRob3IgYW5pZXJvIC8gaHR0cHM6Ly9naXRodWIuY29tL2FuaWVyb1xuICovXG52YXIgRGlhZ29uYWxNb3ZlbWVudCA9IHJlcXVpcmUoJy4uL2NvcmUvRGlhZ29uYWxNb3ZlbWVudCcpO1xudmFyIEpQRk5ldmVyTW92ZURpYWdvbmFsbHkgPSByZXF1aXJlKCcuL0pQRk5ldmVyTW92ZURpYWdvbmFsbHknKTtcbnZhciBKUEZBbHdheXNNb3ZlRGlhZ29uYWxseSA9IHJlcXVpcmUoJy4vSlBGQWx3YXlzTW92ZURpYWdvbmFsbHknKTtcbnZhciBKUEZNb3ZlRGlhZ29uYWxseUlmTm9PYnN0YWNsZXMgPSByZXF1aXJlKCcuL0pQRk1vdmVEaWFnb25hbGx5SWZOb09ic3RhY2xlcycpO1xudmFyIEpQRk1vdmVEaWFnb25hbGx5SWZBdE1vc3RPbmVPYnN0YWNsZSA9IHJlcXVpcmUoJy4vSlBGTW92ZURpYWdvbmFsbHlJZkF0TW9zdE9uZU9ic3RhY2xlJyk7XG5cbi8qKlxuICogUGF0aCBmaW5kZXIgdXNpbmcgdGhlIEp1bXAgUG9pbnQgU2VhcmNoIGFsZ29yaXRobVxuICogQHBhcmFtIHtvYmplY3R9IG9wdFxuICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0LmhldXJpc3RpYyBIZXVyaXN0aWMgZnVuY3Rpb24gdG8gZXN0aW1hdGUgdGhlIGRpc3RhbmNlXG4gKiAgICAgKGRlZmF1bHRzIHRvIG1hbmhhdHRhbikuXG4gKiBAcGFyYW0ge0RpYWdvbmFsTW92ZW1lbnR9IG9wdC5kaWFnb25hbE1vdmVtZW50IENvbmRpdGlvbiB1bmRlciB3aGljaCBkaWFnb25hbFxuICogICAgICBtb3ZlbWVudCB3aWxsIGJlIGFsbG93ZWQuXG4gKi9cbmZ1bmN0aW9uIEp1bXBQb2ludEZpbmRlcihvcHQpIHtcbiAgICBvcHQgPSBvcHQgfHwge307XG4gICAgaWYgKG9wdC5kaWFnb25hbE1vdmVtZW50ID09PSBEaWFnb25hbE1vdmVtZW50Lk5ldmVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgSlBGTmV2ZXJNb3ZlRGlhZ29uYWxseShvcHQpO1xuICAgIH0gZWxzZSBpZiAob3B0LmRpYWdvbmFsTW92ZW1lbnQgPT09IERpYWdvbmFsTW92ZW1lbnQuQWx3YXlzKSB7XG4gICAgICAgIHJldHVybiBuZXcgSlBGQWx3YXlzTW92ZURpYWdvbmFsbHkob3B0KTtcbiAgICB9IGVsc2UgaWYgKG9wdC5kaWFnb25hbE1vdmVtZW50ID09PSBEaWFnb25hbE1vdmVtZW50Lk9ubHlXaGVuTm9PYnN0YWNsZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBKUEZNb3ZlRGlhZ29uYWxseUlmTm9PYnN0YWNsZXMob3B0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IEpQRk1vdmVEaWFnb25hbGx5SWZBdE1vc3RPbmVPYnN0YWNsZShvcHQpO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBKdW1wUG9pbnRGaW5kZXI7XG4iLCIvKipcbiAqIEBhdXRob3IgaW1vciAvIGh0dHBzOi8vZ2l0aHViLmNvbS9pbW9yXG4gKi9cbnZhciBIZWFwICAgICAgID0gcmVxdWlyZSgnaGVhcCcpO1xudmFyIFV0aWwgICAgICAgPSByZXF1aXJlKCcuLi9jb3JlL1V0aWwnKTtcbnZhciBIZXVyaXN0aWMgID0gcmVxdWlyZSgnLi4vY29yZS9IZXVyaXN0aWMnKTtcbnZhciBEaWFnb25hbE1vdmVtZW50ID0gcmVxdWlyZSgnLi4vY29yZS9EaWFnb25hbE1vdmVtZW50Jyk7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgdGhlIEp1bXAgUG9pbnQgU2VhcmNoIGFsZ29yaXRobVxuICogQHBhcmFtIHtvYmplY3R9IG9wdFxuICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0LmhldXJpc3RpYyBIZXVyaXN0aWMgZnVuY3Rpb24gdG8gZXN0aW1hdGUgdGhlIGRpc3RhbmNlXG4gKiAgICAgKGRlZmF1bHRzIHRvIG1hbmhhdHRhbikuXG4gKi9cbmZ1bmN0aW9uIEp1bXBQb2ludEZpbmRlckJhc2Uob3B0KSB7XG4gICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgIHRoaXMuaGV1cmlzdGljID0gb3B0LmhldXJpc3RpYyB8fCBIZXVyaXN0aWMubWFuaGF0dGFuO1xuICAgIHRoaXMudHJhY2tKdW1wUmVjdXJzaW9uID0gb3B0LnRyYWNrSnVtcFJlY3Vyc2lvbiB8fCBmYWxzZTtcbn1cblxuLyoqXG4gKiBGaW5kIGFuZCByZXR1cm4gdGhlIHBhdGguXG4gKiBAcmV0dXJuIHtBcnJheS48W251bWJlciwgbnVtYmVyXT59IFRoZSBwYXRoLCBpbmNsdWRpbmcgYm90aCBzdGFydCBhbmRcbiAqICAgICBlbmQgcG9zaXRpb25zLlxuICovXG5KdW1wUG9pbnRGaW5kZXJCYXNlLnByb3RvdHlwZS5maW5kUGF0aCA9IGZ1bmN0aW9uKHN0YXJ0WCwgc3RhcnRZLCBlbmRYLCBlbmRZLCBncmlkKSB7XG4gICAgdmFyIG9wZW5MaXN0ID0gdGhpcy5vcGVuTGlzdCA9IG5ldyBIZWFwKGZ1bmN0aW9uKG5vZGVBLCBub2RlQikge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGVBLmYgLSBub2RlQi5mO1xuICAgICAgICB9KSxcbiAgICAgICAgc3RhcnROb2RlID0gdGhpcy5zdGFydE5vZGUgPSBncmlkLmdldE5vZGVBdChzdGFydFgsIHN0YXJ0WSksXG4gICAgICAgIGVuZE5vZGUgPSB0aGlzLmVuZE5vZGUgPSBncmlkLmdldE5vZGVBdChlbmRYLCBlbmRZKSwgbm9kZTtcblxuICAgIHRoaXMuZ3JpZCA9IGdyaWQ7XG5cblxuICAgIC8vIHNldCB0aGUgYGdgIGFuZCBgZmAgdmFsdWUgb2YgdGhlIHN0YXJ0IG5vZGUgdG8gYmUgMFxuICAgIHN0YXJ0Tm9kZS5nID0gMDtcbiAgICBzdGFydE5vZGUuZiA9IDA7XG5cbiAgICAvLyBwdXNoIHRoZSBzdGFydCBub2RlIGludG8gdGhlIG9wZW4gbGlzdFxuICAgIG9wZW5MaXN0LnB1c2goc3RhcnROb2RlKTtcbiAgICBzdGFydE5vZGUub3BlbmVkID0gdHJ1ZTtcblxuICAgIC8vIHdoaWxlIHRoZSBvcGVuIGxpc3QgaXMgbm90IGVtcHR5XG4gICAgd2hpbGUgKCFvcGVuTGlzdC5lbXB0eSgpKSB7XG4gICAgICAgIC8vIHBvcCB0aGUgcG9zaXRpb24gb2Ygbm9kZSB3aGljaCBoYXMgdGhlIG1pbmltdW0gYGZgIHZhbHVlLlxuICAgICAgICBub2RlID0gb3Blbkxpc3QucG9wKCk7XG4gICAgICAgIG5vZGUuY2xvc2VkID0gdHJ1ZTtcblxuICAgICAgICBpZiAobm9kZSA9PT0gZW5kTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIFV0aWwuZXhwYW5kUGF0aChVdGlsLmJhY2t0cmFjZShlbmROb2RlKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9pZGVudGlmeVN1Y2Nlc3NvcnMobm9kZSk7XG4gICAgfVxuXG4gICAgLy8gZmFpbCB0byBmaW5kIHRoZSBwYXRoXG4gICAgcmV0dXJuIFtdO1xufTtcblxuLyoqXG4gKiBJZGVudGlmeSBzdWNjZXNzb3JzIGZvciB0aGUgZ2l2ZW4gbm9kZS4gUnVucyBhIGp1bXAgcG9pbnQgc2VhcmNoIGluIHRoZVxuICogZGlyZWN0aW9uIG9mIGVhY2ggYXZhaWxhYmxlIG5laWdoYm9yLCBhZGRpbmcgYW55IHBvaW50cyBmb3VuZCB0byB0aGUgb3BlblxuICogbGlzdC5cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuSnVtcFBvaW50RmluZGVyQmFzZS5wcm90b3R5cGUuX2lkZW50aWZ5U3VjY2Vzc29ycyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB2YXIgZ3JpZCA9IHRoaXMuZ3JpZCxcbiAgICAgICAgaGV1cmlzdGljID0gdGhpcy5oZXVyaXN0aWMsXG4gICAgICAgIG9wZW5MaXN0ID0gdGhpcy5vcGVuTGlzdCxcbiAgICAgICAgZW5kWCA9IHRoaXMuZW5kTm9kZS54LFxuICAgICAgICBlbmRZID0gdGhpcy5lbmROb2RlLnksXG4gICAgICAgIG5laWdoYm9ycywgbmVpZ2hib3IsXG4gICAgICAgIGp1bXBQb2ludCwgaSwgbCxcbiAgICAgICAgeCA9IG5vZGUueCwgeSA9IG5vZGUueSxcbiAgICAgICAgangsIGp5LCBkeCwgZHksIGQsIG5nLCBqdW1wTm9kZSxcbiAgICAgICAgYWJzID0gTWF0aC5hYnMsIG1heCA9IE1hdGgubWF4O1xuXG4gICAgbmVpZ2hib3JzID0gdGhpcy5fZmluZE5laWdoYm9ycyhub2RlKTtcbiAgICBmb3IoaSA9IDAsIGwgPSBuZWlnaGJvcnMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgIG5laWdoYm9yID0gbmVpZ2hib3JzW2ldO1xuICAgICAgICBqdW1wUG9pbnQgPSB0aGlzLl9qdW1wKG5laWdoYm9yWzBdLCBuZWlnaGJvclsxXSwgeCwgeSk7XG4gICAgICAgIGlmIChqdW1wUG9pbnQpIHtcblxuICAgICAgICAgICAganggPSBqdW1wUG9pbnRbMF07XG4gICAgICAgICAgICBqeSA9IGp1bXBQb2ludFsxXTtcbiAgICAgICAgICAgIGp1bXBOb2RlID0gZ3JpZC5nZXROb2RlQXQoangsIGp5KTtcblxuICAgICAgICAgICAgaWYgKGp1bXBOb2RlLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpbmNsdWRlIGRpc3RhbmNlLCBhcyBwYXJlbnQgbWF5IG5vdCBiZSBpbW1lZGlhdGVseSBhZGphY2VudDpcbiAgICAgICAgICAgIGQgPSBIZXVyaXN0aWMub2N0aWxlKGFicyhqeCAtIHgpLCBhYnMoankgLSB5KSk7XG4gICAgICAgICAgICBuZyA9IG5vZGUuZyArIGQ7IC8vIG5leHQgYGdgIHZhbHVlXG5cbiAgICAgICAgICAgIGlmICghanVtcE5vZGUub3BlbmVkIHx8IG5nIDwganVtcE5vZGUuZykge1xuICAgICAgICAgICAgICAgIGp1bXBOb2RlLmcgPSBuZztcbiAgICAgICAgICAgICAgICBqdW1wTm9kZS5oID0ganVtcE5vZGUuaCB8fCBoZXVyaXN0aWMoYWJzKGp4IC0gZW5kWCksIGFicyhqeSAtIGVuZFkpKTtcbiAgICAgICAgICAgICAgICBqdW1wTm9kZS5mID0ganVtcE5vZGUuZyArIGp1bXBOb2RlLmg7XG4gICAgICAgICAgICAgICAganVtcE5vZGUucGFyZW50ID0gbm9kZTtcblxuICAgICAgICAgICAgICAgIGlmICghanVtcE5vZGUub3BlbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wZW5MaXN0LnB1c2goanVtcE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBqdW1wTm9kZS5vcGVuZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9wZW5MaXN0LnVwZGF0ZUl0ZW0oanVtcE5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSnVtcFBvaW50RmluZGVyQmFzZTtcbiJdfQ=="}