{"version":3,"sources":["node_modules/browser-pack/_prelude.js","dist/lib/gridDistance.js","dist/lib/sortedFood.js","dist/lib/weight.js","dist/web.js","node_modules/heap/index.js","node_modules/heap/lib/heap.js","node_modules/pathfinding/index.js","node_modules/pathfinding/src/PathFinding.js","node_modules/pathfinding/src/core/DiagonalMovement.js","node_modules/pathfinding/src/core/Grid.js","node_modules/pathfinding/src/core/Heuristic.js","node_modules/pathfinding/src/core/Node.js","node_modules/pathfinding/src/core/Util.js","node_modules/pathfinding/src/finders/AStarFinder.js","node_modules/pathfinding/src/finders/BestFirstFinder.js","node_modules/pathfinding/src/finders/BiAStarFinder.js","node_modules/pathfinding/src/finders/BiBestFirstFinder.js","node_modules/pathfinding/src/finders/BiBreadthFirstFinder.js","node_modules/pathfinding/src/finders/BiDijkstraFinder.js","node_modules/pathfinding/src/finders/BreadthFirstFinder.js","node_modules/pathfinding/src/finders/DijkstraFinder.js","node_modules/pathfinding/src/finders/IDAStarFinder.js","node_modules/pathfinding/src/finders/JPFAlwaysMoveDiagonally.js","node_modules/pathfinding/src/finders/JPFMoveDiagonallyIfAtMostOneObstacle.js","node_modules/pathfinding/src/finders/JPFMoveDiagonallyIfNoObstacles.js","node_modules/pathfinding/src/finders/JPFNeverMoveDiagonally.js","node_modules/pathfinding/src/finders/JumpPointFinder.js","node_modules/pathfinding/src/finders/JumpPointFinderBase.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnKA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjXA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"bundle.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction gridDistance(x1, y1, x2, y2) {\n    return Math.abs(x1 - x2) + Math.abs(y1 - y2);\n}\nexports.gridDistance = gridDistance;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst gridDistance_1 = require(\"./gridDistance\");\nfunction sortedFood(data) {\n    const sorted = {\n        food: null,\n        distance: 100000,\n    };\n    if (!data.board.food.length) {\n        return null;\n    }\n    const result = [];\n    for (const food of data.board.food) {\n        result.push({\n            food: food,\n            distance: gridDistance_1.gridDistance(data.you.body[0].x, data.you.body[0].y, food.x, food.y),\n        });\n    }\n    result.sort((a, b) => {\n        return a.distance - b.distance;\n    });\n    return result;\n}\nexports.sortedFood = sortedFood;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst gridDistance_1 = require(\"./gridDistance\");\nfunction weight(data, x, y) {\n    for (const snake of data.board.snakes) {\n        const body = snake.body;\n        // const body = snake.body.filter((p1, i, a) => a.findIndex(p2 => p1.x == p2.x && p1.y == p2.y) === i);\n        for (const [p, part] of body.entries()) {\n            // Is part of snake?\n            if (part.x == x && part.y == y) {\n                // Is end of snake?\n                if (p != body.length - 1) {\n                    return 0;\n                }\n            }\n        }\n    }\n    for (const snake of data.board.snakes) {\n        const body = snake.body;\n        for (const [p, part] of body.entries()) {\n            // Is near head?\n            if (snake.id != data.you.id && p == 0) {\n                const distance = gridDistance_1.gridDistance(x, y, part.x, part.y);\n                if (distance < 4) {\n                    return distance * 10;\n                }\n            }\n        }\n    }\n    return 50;\n}\nexports.weight = weight;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst weight_1 = require(\"./lib/weight\");\nconst sortedFood_1 = require(\"./lib/sortedFood\");\nconst PF = require('pathfinding');\n// const colors = ['#2ecc71', '#3498db', '#9b59b6', '#f1c40f', '#e67e22', '#e74c3c', '#95a5a6', '#34495e'];\nconst grid = $('.grid');\nconst getCol = (x, y) => {\n    return grid.find('.row').eq(y).find('.col').eq(x);\n};\nconst BLOCKED = 1;\nconst FREE = 0;\nconst pf = new PF.AStarFinder({\n    allowDiagonal: false,\n    useCost: true,\n});\nconst drawBoard = (data) => {\n    grid.html('');\n    const matrix = [];\n    const costs = [];\n    for (var y = 0; y < data.board.height; y++) {\n        matrix[y] = [];\n        costs[y] = [];\n        const row = $('<div>').addClass('row').appendTo(grid);\n        for (var x = 0; x < data.board.width; x++) {\n            const w = weight_1.weight(data, x, y);\n            matrix[y][x] = w > 0 ? FREE : BLOCKED;\n            costs[y][x] = 100 - w;\n            const col = $('<div>').addClass('col').css({\n                backgroundColor: `rgba(0, 0, 0, ${(100 - w) / 100})`,\n            }).appendTo(row);\n            $('<div>').addClass('weight').html(x + '/' + y + '<br/>w:' + w + '<br/>' + (matrix[y][x] == FREE ? 'FREE' : 'BLOCKED') + '<br/>c:' + costs[y][x]).css({\n                color: w < 60 ? 'white' : 'black',\n            }).appendTo(col);\n        }\n    }\n    for (const food of data.board.food) {\n        const col = getCol(food.x, food.y);\n        $('<div>').addClass('food').appendTo(col);\n    }\n    for (const snake of data.board.snakes) {\n        const color = snake.id == data.you.id ? '#2ecc71' : '#e74c3c';\n        for (const [p, part] of snake.body.entries()) {\n            const col = getCol(part.x, part.y);\n            $('<div>').addClass('snake').css({\n                backgroundColor: color,\n                borderRadius: p == 0 ? 100 : 0,\n            }).text(' ').appendTo(col);\n        }\n    }\n    const sorted = sortedFood_1.sortedFood(data);\n    if (!sorted.length) {\n        return;\n    }\n    console.log('sorted', sorted);\n    closest: for (const closest of sorted) {\n        console.log('closest', closest);\n        const pfGrid = new PF.Grid(data.board.width, data.board.height, matrix, costs);\n        const path = pf.findPath(data.you.body[0].x, data.you.body[0].y, closest.food.x, closest.food.y, pfGrid.clone());\n        for (let i = 0; i < path.length; i++) {\n            const p = path[i];\n            if (i == 0) {\n                continue;\n            }\n            const col = getCol(p[0], p[1]);\n            $('<div>').addClass('path').appendTo(col);\n        }\n        for (let i = 0; i < path.length; i++) {\n            const p = path[i];\n            if (i === 0) {\n                continue;\n            }\n            if (p[0] == data.you.body[0].x - 1 && p[1] == data.you.body[0].y) {\n                // Left\n                console.log('moveTowardsFoodPf', p, 'left');\n                break closest;\n            }\n            else if (p[0] == data.you.body[0].x + 1 && p[1] == data.you.body[0].y) {\n                // Right\n                console.log('moveTowardsFoodPf', p, 'right');\n                break closest;\n            }\n            else if (p[0] == data.you.body[0].x && p[1] == data.you.body[0].y - 1) {\n                // Up\n                console.log('moveTowardsFoodPf', p, 'up');\n                break closest;\n            }\n            else if (p[0] == data.you.body[0].x && p[1] == data.you.body[0].y + 1) {\n                // Down\n                console.log('moveTowardsFoodPf', p, 'down');\n                break closest;\n            }\n            else {\n                console.log('moveTowardsFoodPf', p, 'no path');\n            }\n        }\n    }\n    // hasWayOut(data, path);\n};\nconst hasWayOut = (data, path) => {\n    const matrix = [];\n    const costs = [];\n    for (var y = 0; y < data.board.height; y++) {\n        matrix[y] = [];\n        costs[y] = [];\n        for (var x = 0; x < data.board.width; x++) {\n            const w = weight_1.weight(data, x, y);\n            matrix[y][x] = w > 0 ? FREE : BLOCKED;\n            costs[y][x] = 100 - w;\n        }\n    }\n    for (const [i, p] of path.entries()) {\n        matrix[p[1]][p[0]] = BLOCKED;\n    }\n    const pfGrid = new PF.Grid(data.board.width, data.board.height, matrix, costs);\n    for (const food of data.board.food) {\n        const wayOutPath = pf.findPath(data.you.body[0].x, data.you.body[0].y, food.x, food.y, pfGrid.clone());\n        console.log(wayOutPath);\n    }\n};\nlet game = null;\nconst loadGame = (gameFile, turn = null) => {\n    $('.moves').html('');\n    $.getJSON('../games/' + gameFile).done((response) => {\n        game = response;\n        if (turn) {\n            drawBoard(game.moves[turn]);\n        }\n        else {\n            drawBoard(game.start);\n        }\n        for (const move of game.moves) {\n            if (!move || !move.turn) {\n                continue;\n            }\n            $('<div>').addClass('move').data('turn', move.turn).text('Move ' + move.turn).appendTo('.moves');\n        }\n    }).fail((xhr, textStatus, errorThrown) => {\n        $('.log').text(textStatus + ': ' + errorThrown);\n        console.error(textStatus, errorThrown);\n    });\n};\n$('.game').click(function () {\n    const gameFile = $(this).data('game');\n    loadGame(gameFile);\n});\nconst urlParams = new URLSearchParams(window.location.search);\nconst queryGame = urlParams.get('game');\nconst queryTurn = urlParams.get('turn');\nif (queryGame) {\n    loadGame(queryGame, queryTurn);\n}\nelse {\n    $('.game:last').click();\n}\n$('.moves').on('click', '.move', function () {\n    const turn = $(this).data('turn');\n    drawBoard(game.moves[turn]);\n    const newUrl = window.location.protocol + \"//\" + window.location.host + window.location.pathname + '?game=' + game.moves[turn].you.id + '&turn=' + turn;\n    window.history.pushState({\n        path: newUrl,\n    }, '', newUrl);\n});\n","module.exports = require('./lib/heap');\n","// Generated by CoffeeScript 1.8.0\n(function() {\n  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n\n  floor = Math.floor, min = Math.min;\n\n\n  /*\n  Default comparison function to be used\n   */\n\n  defaultCmp = function(x, y) {\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    return 0;\n  };\n\n\n  /*\n  Insert item x in list a, and keep it sorted assuming a is sorted.\n  \n  If x is already in a, insert it to the right of the rightmost x.\n  \n  Optional args lo (default 0) and hi (default a.length) bound the slice\n  of a to be searched.\n   */\n\n  insort = function(a, x, lo, hi, cmp) {\n    var mid;\n    if (lo == null) {\n      lo = 0;\n    }\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (lo < 0) {\n      throw new Error('lo must be non-negative');\n    }\n    if (hi == null) {\n      hi = a.length;\n    }\n    while (lo < hi) {\n      mid = floor((lo + hi) / 2);\n      if (cmp(x, a[mid]) < 0) {\n        hi = mid;\n      } else {\n        lo = mid + 1;\n      }\n    }\n    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);\n  };\n\n\n  /*\n  Push item onto heap, maintaining the heap invariant.\n   */\n\n  heappush = function(array, item, cmp) {\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    array.push(item);\n    return _siftdown(array, 0, array.length - 1, cmp);\n  };\n\n\n  /*\n  Pop the smallest item off the heap, maintaining the heap invariant.\n   */\n\n  heappop = function(array, cmp) {\n    var lastelt, returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    lastelt = array.pop();\n    if (array.length) {\n      returnitem = array[0];\n      array[0] = lastelt;\n      _siftup(array, 0, cmp);\n    } else {\n      returnitem = lastelt;\n    }\n    return returnitem;\n  };\n\n\n  /*\n  Pop and return the current smallest value, and add the new item.\n  \n  This is more efficient than heappop() followed by heappush(), and can be\n  more appropriate when using a fixed size heap. Note that the value\n  returned may be larger than item! That constrains reasonable use of\n  this routine unless written as part of a conditional replacement:\n      if item > array[0]\n        item = heapreplace(array, item)\n   */\n\n  heapreplace = function(array, item, cmp) {\n    var returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    returnitem = array[0];\n    array[0] = item;\n    _siftup(array, 0, cmp);\n    return returnitem;\n  };\n\n\n  /*\n  Fast version of a heappush followed by a heappop.\n   */\n\n  heappushpop = function(array, item, cmp) {\n    var _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (array.length && cmp(array[0], item) < 0) {\n      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];\n      _siftup(array, 0, cmp);\n    }\n    return item;\n  };\n\n\n  /*\n  Transform list into a heap, in-place, in O(array.length) time.\n   */\n\n  heapify = function(array, cmp) {\n    var i, _i, _j, _len, _ref, _ref1, _results, _results1;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    _ref1 = (function() {\n      _results1 = [];\n      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }\n      return _results1;\n    }).apply(this).reverse();\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      i = _ref1[_i];\n      _results.push(_siftup(array, i, cmp));\n    }\n    return _results;\n  };\n\n\n  /*\n  Update the position of the given item in the heap.\n  This function should be called every time the item is being modified.\n   */\n\n  updateItem = function(array, item, cmp) {\n    var pos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    pos = array.indexOf(item);\n    if (pos === -1) {\n      return;\n    }\n    _siftdown(array, 0, pos, cmp);\n    return _siftup(array, pos, cmp);\n  };\n\n\n  /*\n  Find the n largest elements in a dataset.\n   */\n\n  nlargest = function(array, n, cmp) {\n    var elem, result, _i, _len, _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    result = array.slice(0, n);\n    if (!result.length) {\n      return result;\n    }\n    heapify(result, cmp);\n    _ref = array.slice(n);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      elem = _ref[_i];\n      heappushpop(result, elem, cmp);\n    }\n    return result.sort(cmp).reverse();\n  };\n\n\n  /*\n  Find the n smallest elements in a dataset.\n   */\n\n  nsmallest = function(array, n, cmp) {\n    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (n * 10 <= array.length) {\n      result = array.slice(0, n).sort(cmp);\n      if (!result.length) {\n        return result;\n      }\n      los = result[result.length - 1];\n      _ref = array.slice(n);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        elem = _ref[_i];\n        if (cmp(elem, los) < 0) {\n          insort(result, elem, 0, null, cmp);\n          result.pop();\n          los = result[result.length - 1];\n        }\n      }\n      return result;\n    }\n    heapify(array, cmp);\n    _results = [];\n    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n      _results.push(heappop(array, cmp));\n    }\n    return _results;\n  };\n\n  _siftdown = function(array, startpos, pos, cmp) {\n    var newitem, parent, parentpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    newitem = array[pos];\n    while (pos > startpos) {\n      parentpos = (pos - 1) >> 1;\n      parent = array[parentpos];\n      if (cmp(newitem, parent) < 0) {\n        array[pos] = parent;\n        pos = parentpos;\n        continue;\n      }\n      break;\n    }\n    return array[pos] = newitem;\n  };\n\n  _siftup = function(array, pos, cmp) {\n    var childpos, endpos, newitem, rightpos, startpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    endpos = array.length;\n    startpos = pos;\n    newitem = array[pos];\n    childpos = 2 * pos + 1;\n    while (childpos < endpos) {\n      rightpos = childpos + 1;\n      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n        childpos = rightpos;\n      }\n      array[pos] = array[childpos];\n      pos = childpos;\n      childpos = 2 * pos + 1;\n    }\n    array[pos] = newitem;\n    return _siftdown(array, startpos, pos, cmp);\n  };\n\n  Heap = (function() {\n    Heap.push = heappush;\n\n    Heap.pop = heappop;\n\n    Heap.replace = heapreplace;\n\n    Heap.pushpop = heappushpop;\n\n    Heap.heapify = heapify;\n\n    Heap.updateItem = updateItem;\n\n    Heap.nlargest = nlargest;\n\n    Heap.nsmallest = nsmallest;\n\n    function Heap(cmp) {\n      this.cmp = cmp != null ? cmp : defaultCmp;\n      this.nodes = [];\n    }\n\n    Heap.prototype.push = function(x) {\n      return heappush(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pop = function() {\n      return heappop(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.peek = function() {\n      return this.nodes[0];\n    };\n\n    Heap.prototype.contains = function(x) {\n      return this.nodes.indexOf(x) !== -1;\n    };\n\n    Heap.prototype.replace = function(x) {\n      return heapreplace(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pushpop = function(x) {\n      return heappushpop(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.heapify = function() {\n      return heapify(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.updateItem = function(x) {\n      return updateItem(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.clear = function() {\n      return this.nodes = [];\n    };\n\n    Heap.prototype.empty = function() {\n      return this.nodes.length === 0;\n    };\n\n    Heap.prototype.size = function() {\n      return this.nodes.length;\n    };\n\n    Heap.prototype.clone = function() {\n      var heap;\n      heap = new Heap();\n      heap.nodes = this.nodes.slice(0);\n      return heap;\n    };\n\n    Heap.prototype.toArray = function() {\n      return this.nodes.slice(0);\n    };\n\n    Heap.prototype.insert = Heap.prototype.push;\n\n    Heap.prototype.top = Heap.prototype.peek;\n\n    Heap.prototype.front = Heap.prototype.peek;\n\n    Heap.prototype.has = Heap.prototype.contains;\n\n    Heap.prototype.copy = Heap.prototype.clone;\n\n    return Heap;\n\n  })();\n\n  if (typeof module !== \"undefined\" && module !== null ? module.exports : void 0) {\n    module.exports = Heap;\n  } else {\n    window.Heap = Heap;\n  }\n\n}).call(this);\n","module.exports = require('./src/PathFinding');\n","module.exports = {\n    'Heap'                      : require('heap'),\n    'Node'                      : require('./core/Node'),\n    'Grid'                      : require('./core/Grid'),\n    'Util'                      : require('./core/Util'),\n\t'DiagonalMovement'          : require('./core/DiagonalMovement'),\n    'Heuristic'                 : require('./core/Heuristic'),\n    'AStarFinder'               : require('./finders/AStarFinder'),\n    'BestFirstFinder'           : require('./finders/BestFirstFinder'),\n    'BreadthFirstFinder'        : require('./finders/BreadthFirstFinder'),\n    'DijkstraFinder'            : require('./finders/DijkstraFinder'),\n    'BiAStarFinder'             : require('./finders/BiAStarFinder'),\n    'BiBestFirstFinder'         : require('./finders/BiBestFirstFinder'),\n    'BiBreadthFirstFinder'      : require('./finders/BiBreadthFirstFinder'),\n    'BiDijkstraFinder'          : require('./finders/BiDijkstraFinder'),\n    'IDAStarFinder'             : require('./finders/IDAStarFinder'),\n    'JumpPointFinder'           : require('./finders/JumpPointFinder'),\n};\n","var DiagonalMovement = {\n    Always: 1,\n    Never: 2,\n    IfAtMostOneObstacle: 3,\n    OnlyWhenNoObstacles: 4\n};\n\nmodule.exports = DiagonalMovement;","var Node = require('./Node');\nvar DiagonalMovement = require('./DiagonalMovement');\n\n/**\n * The Grid class, which serves as the encapsulation of the layout of the nodes.\n * @constructor\n * @param {number|Array.<Array.<(number|boolean)>>} width_or_matrix Number of columns of the grid, or matrix\n * @param {number} height Number of rows of the grid.\n * @param {Array.<Array.<(number|boolean)>>} [matrix] - A 0-1 matrix\n *     representing the walkable status of the nodes(0 or false for walkable).\n *     If the matrix is not supplied, all the nodes will be walkable. \n * @param {Array.<Array.<(number)>>} [costs] - A matrix\n *     representing the cost of walking the node.\n *     If the costs is not supplied, all the nodes will cost 0.  */\nfunction Grid(width_or_matrix, height, matrix, costs) {\n    var width;\n\n    if (typeof width_or_matrix !== 'object') {\n        width = width_or_matrix;\n    } else {\n        height = width_or_matrix.length;\n        width = width_or_matrix[0].length;\n        matrix = width_or_matrix;\n    }\n\n    /**\n     * The number of columns of the grid.\n     * @type number\n     */\n    this.width = width;\n    /**\n     * The number of rows of the grid.\n     * @type number\n     */\n    this.height = height;\n\n    /**\n     * A 2D array of nodes.\n     */\n    this.nodes = this._buildNodes(width, height, matrix, costs);\n}\n\n/**\n * Build and return the nodes.\n * @private\n * @param {number} width\n * @param {number} height\n * @param {Array.<Array.<number|boolean>>} [matrix] - A 0-1 matrix representing\n *     the walkable status of the nodes.\n * @param {Array.<Array.<number>>} [costs] - A matrix representing\n *     the costs to walk the nodes.\n * @see Grid\n */\nGrid.prototype._buildNodes = function(width, height, matrix, costs) {\n    var i, j,\n        nodes = new Array(height),\n        row;\n\n    for (i = 0; i < height; ++i) {\n        nodes[i] = new Array(width);\n        for (j = 0; j < width; ++j) {\n            nodes[i][j] = new Node(j, i);\n        }\n    }\n\n    if (matrix === undefined) {\n        return nodes;\n    }\n\n    if (matrix.length !== height || matrix[0].length !== width) {\n        throw new Error('Matrix size does not fit');\n    }\n\n    if (costs !== undefined && (costs.length !== height || costs[0].length !== width)) {\n        throw new Error('Costs size does not fit');\n    }\n\n    for (i = 0; i < height; ++i) {\n        for (j = 0; j < width; ++j) {\n            if (matrix[i][j]) {\n                // 0, false, null will be walkable\n                // while others will be un-walkable\n                nodes[i][j].walkable = false;\n            }\n            if (costs !== undefined) {\n                nodes[i][j].cost=costs[i][j];\n            }\n        }\n    }\n\n    return nodes;\n};\n\n\nGrid.prototype.getNodeAt = function(x, y) {\n    return this.nodes[y][x];\n};\n\n\n/**\n * Determine whether the node at the given position is walkable.\n * (Also returns false if the position is outside the grid.)\n * @param {number} x - The x coordinate of the node.\n * @param {number} y - The y coordinate of the node.\n * @return {boolean} - The walkability of the node.\n */\nGrid.prototype.isWalkableAt = function(x, y) {\n    return this.isInside(x, y) && this.nodes[y][x].walkable;\n};\n\n\n/**\n * Get cost to walk the node at the given position.\n * (Also returns false if the position is outside the grid.)\n * @param {number} x - The x coordinate of the node.\n * @param {number} y - The y coordinate of the node.\n * @return {number} - Cost to walk node.\n */\nGrid.prototype.getCostAt = function(x, y) {\n    if (!this.isInside(x, y)) return false;\n    return this.nodes[y][x].cost;\n};\n\n\n/**\n * Determine whether the position is inside the grid.\n * XXX: `grid.isInside(x, y)` is wierd to read.\n * It should be `(x, y) is inside grid`, but I failed to find a better\n * name for this method.\n * @param {number} x\n * @param {number} y\n * @return {boolean}\n */\nGrid.prototype.isInside = function(x, y) {\n    return (x >= 0 && x < this.width) && (y >= 0 && y < this.height);\n};\n\n\n/**\n * Set whether the node on the given position is walkable.\n * NOTE: throws exception if the coordinate is not inside the grid.\n * @param {number} x - The x coordinate of the node.\n * @param {number} y - The y coordinate of the node.\n * @param {boolean} walkable - Whether the position is walkable.\n */\nGrid.prototype.setWalkableAt = function(x, y, walkable) {\n    this.nodes[y][x].walkable = walkable;\n};\n\n\n/**\n * Set cost of the node on the given position\n * NOTE: throws exception if the coordinate is not inside the grid.\n * @param {number} x - The x coordinate of the node.\n * @param {number} y - The y coordinate of the node.\n * @param {number} cost - Cost to walk the node.\n */\nGrid.prototype.setCostAt = function(x, y, cost) {\n    this.nodes[y][x].cost = cost;\n};\n\n\n/**\n * Get the neighbors of the given node.\n *\n *     offsets      diagonalOffsets:\n *  +---+---+---+    +---+---+---+\n *  |   | 0 |   |    | 0 |   | 1 |\n *  +---+---+---+    +---+---+---+\n *  | 3 |   | 1 |    |   |   |   |\n *  +---+---+---+    +---+---+---+\n *  |   | 2 |   |    | 3 |   | 2 |\n *  +---+---+---+    +---+---+---+\n *\n *  When allowDiagonal is true, if offsets[i] is valid, then\n *  diagonalOffsets[i] and\n *  diagonalOffsets[(i + 1) % 4] is valid.\n * @param {Node} node\n * @param {DiagonalMovement} diagonalMovement\n */\nGrid.prototype.getNeighbors = function(node, diagonalMovement) {\n    var x = node.x,\n        y = node.y,\n        neighbors = [],\n        s0 = false, d0 = false,\n        s1 = false, d1 = false,\n        s2 = false, d2 = false,\n        s3 = false, d3 = false,\n        nodes = this.nodes;\n\n    // ↑\n    if (this.isWalkableAt(x, y - 1)) {\n        neighbors.push(nodes[y - 1][x]);\n        s0 = true;\n    }\n    // →\n    if (this.isWalkableAt(x + 1, y)) {\n        neighbors.push(nodes[y][x + 1]);\n        s1 = true;\n    }\n    // ↓\n    if (this.isWalkableAt(x, y + 1)) {\n        neighbors.push(nodes[y + 1][x]);\n        s2 = true;\n    }\n    // ←\n    if (this.isWalkableAt(x - 1, y)) {\n        neighbors.push(nodes[y][x - 1]);\n        s3 = true;\n    }\n\n    if (diagonalMovement === DiagonalMovement.Never) {\n        return neighbors;\n    }\n\n    if (diagonalMovement === DiagonalMovement.OnlyWhenNoObstacles) {\n        d0 = s3 && s0;\n        d1 = s0 && s1;\n        d2 = s1 && s2;\n        d3 = s2 && s3;\n    } else if (diagonalMovement === DiagonalMovement.IfAtMostOneObstacle) {\n        d0 = s3 || s0;\n        d1 = s0 || s1;\n        d2 = s1 || s2;\n        d3 = s2 || s3;\n    } else if (diagonalMovement === DiagonalMovement.Always) {\n        d0 = true;\n        d1 = true;\n        d2 = true;\n        d3 = true;\n    } else {\n        throw new Error('Incorrect value of diagonalMovement');\n    }\n\n    // ↖\n    if (d0 && this.isWalkableAt(x - 1, y - 1)) {\n        neighbors.push(nodes[y - 1][x - 1]);\n    }\n    // ↗\n    if (d1 && this.isWalkableAt(x + 1, y - 1)) {\n        neighbors.push(nodes[y - 1][x + 1]);\n    }\n    // ↘\n    if (d2 && this.isWalkableAt(x + 1, y + 1)) {\n        neighbors.push(nodes[y + 1][x + 1]);\n    }\n    // ↙\n    if (d3 && this.isWalkableAt(x - 1, y + 1)) {\n        neighbors.push(nodes[y + 1][x - 1]);\n    }\n\n    return neighbors;\n};\n\n\n/**\n * Get a clone of this grid.\n * @return {Grid} Cloned grid.\n */\nGrid.prototype.clone = function() {\n    var i, j,\n\n        width = this.width,\n        height = this.height,\n        thisNodes = this.nodes,\n\n        newGrid = new Grid(width, height),\n        newNodes = new Array(height),\n        row;\n\n    for (i = 0; i < height; ++i) {\n        newNodes[i] = new Array(width);\n        for (j = 0; j < width; ++j) {\n            newNodes[i][j] = new Node(j, i, thisNodes[i][j].walkable, thisNodes[i][j].cost);\n        }\n    }\n\n    newGrid.nodes = newNodes;\n\n    return newGrid;\n};\n\nmodule.exports = Grid;\n","/**\n * @namespace PF.Heuristic\n * @description A collection of heuristic functions.\n */\nmodule.exports = {\n\n  /**\n   * Manhattan distance.\n   * @param {number} dx - Difference in x.\n   * @param {number} dy - Difference in y.\n   * @return {number} dx + dy\n   */\n  manhattan: function(dx, dy) {\n      return dx + dy;\n  },\n\n  /**\n   * Euclidean distance.\n   * @param {number} dx - Difference in x.\n   * @param {number} dy - Difference in y.\n   * @return {number} sqrt(dx * dx + dy * dy)\n   */\n  euclidean: function(dx, dy) {\n      return Math.sqrt(dx * dx + dy * dy);\n  },\n\n  /**\n   * Octile distance.\n   * @param {number} dx - Difference in x.\n   * @param {number} dy - Difference in y.\n   * @return {number} sqrt(dx * dx + dy * dy) for grids\n   */\n  octile: function(dx, dy) {\n      var F = Math.SQRT2 - 1;\n      return (dx < dy) ? F * dx + dy : F * dy + dx;\n  },\n\n  /**\n   * Chebyshev distance.\n   * @param {number} dx - Difference in x.\n   * @param {number} dy - Difference in y.\n   * @return {number} max(dx, dy)\n   */\n  chebyshev: function(dx, dy) {\n      return Math.max(dx, dy);\n  }\n\n};\n","/**\n * A node in grid. \n * This class holds some basic information about a node and custom \n * attributes may be added, depending on the algorithms' needs.\n * @constructor\n * @param {number} x - The x coordinate of the node on the grid.\n * @param {number} y - The y coordinate of the node on the grid.\n * @param {boolean} [walkable] - Whether this node is walkable.\n * @param {number} [cost] - node cost used by finders that allow non-uniform node costs\n */\nfunction Node(x, y, walkable, cost) {\n    /**\n     * The x coordinate of the node on the grid.\n     * @type number\n     */\n    this.x = x;\n    /**\n     * The y coordinate of the node on the grid.\n     * @type number\n     */\n    this.y = y;\n    /**\n     * Whether this node can be walked through.\n     * @type boolean\n     */\n    this.walkable = (walkable === undefined ? true : walkable);\n    /**\n     * Cost to walk this node if its walkable\n     * @type number\n     */\n    this.cost = (cost === undefined) ? 0 : cost;\n}\n\nmodule.exports = Node;\n","/**\n * Backtrace according to the parent records and return the path.\n * (including both start and end nodes)\n * @param {Node} node End node\n * @return {Array.<Array.<number>>} the path\n */\nfunction backtrace(node) {\n    var path = [[node.x, node.y]];\n    while (node.parent) {\n        node = node.parent;\n        path.push([node.x, node.y]);\n    }\n    return path.reverse();\n}\nexports.backtrace = backtrace;\n\n/**\n * Backtrace from start and end node, and return the path.\n * (including both start and end nodes)\n * @param {Node}\n * @param {Node}\n */\nfunction biBacktrace(nodeA, nodeB) {\n    var pathA = backtrace(nodeA),\n        pathB = backtrace(nodeB);\n    return pathA.concat(pathB.reverse());\n}\nexports.biBacktrace = biBacktrace;\n\n/**\n * Compute the length of the path.\n * @param {Array.<Array.<number>>} path The path\n * @return {number} The length of the path\n */\nfunction pathLength(path) {\n    var i, sum = 0, a, b, dx, dy;\n    for (i = 1; i < path.length; ++i) {\n        a = path[i - 1];\n        b = path[i];\n        dx = a[0] - b[0];\n        dy = a[1] - b[1];\n        sum += Math.sqrt(dx * dx + dy * dy);\n    }\n    return sum;\n}\nexports.pathLength = pathLength;\n\n\n/**\n * Given the start and end coordinates, return all the coordinates lying\n * on the line formed by these coordinates, based on Bresenham's algorithm.\n * http://en.wikipedia.org/wiki/Bresenham's_line_algorithm#Simplification\n * @param {number} x0 Start x coordinate\n * @param {number} y0 Start y coordinate\n * @param {number} x1 End x coordinate\n * @param {number} y1 End y coordinate\n * @return {Array.<Array.<number>>} The coordinates on the line\n */\nfunction interpolate(x0, y0, x1, y1) {\n    var abs = Math.abs,\n        line = [],\n        sx, sy, dx, dy, err, e2;\n\n    dx = abs(x1 - x0);\n    dy = abs(y1 - y0);\n\n    sx = (x0 < x1) ? 1 : -1;\n    sy = (y0 < y1) ? 1 : -1;\n\n    err = dx - dy;\n\n    while (true) {\n        line.push([x0, y0]);\n\n        if (x0 === x1 && y0 === y1) {\n            break;\n        }\n        \n        e2 = 2 * err;\n        if (e2 > -dy) {\n            err = err - dy;\n            x0 = x0 + sx;\n        }\n        if (e2 < dx) {\n            err = err + dx;\n            y0 = y0 + sy;\n        }\n    }\n\n    return line;\n}\nexports.interpolate = interpolate;\n\n\n/**\n * Given a compressed path, return a new path that has all the segments\n * in it interpolated.\n * @param {Array.<Array.<number>>} path The path\n * @return {Array.<Array.<number>>} expanded path\n */\nfunction expandPath(path) {\n    var expanded = [],\n        len = path.length,\n        coord0, coord1,\n        interpolated,\n        interpolatedLen,\n        i, j;\n\n    if (len < 2) {\n        return expanded;\n    }\n\n    for (i = 0; i < len - 1; ++i) {\n        coord0 = path[i];\n        coord1 = path[i + 1];\n\n        interpolated = interpolate(coord0[0], coord0[1], coord1[0], coord1[1]);\n        interpolatedLen = interpolated.length;\n        for (j = 0; j < interpolatedLen - 1; ++j) {\n            expanded.push(interpolated[j]);\n        }\n    }\n    expanded.push(path[len - 1]);\n\n    return expanded;\n}\nexports.expandPath = expandPath;\n\n\n/**\n * Smoothen the give path.\n * The original path will not be modified; a new path will be returned.\n * @param {PF.Grid} grid\n * @param {Array.<Array.<number>>} path The path\n */\nfunction smoothenPath(grid, path) {\n    var len = path.length,\n        x0 = path[0][0],        // path start x\n        y0 = path[0][1],        // path start y\n        x1 = path[len - 1][0],  // path end x\n        y1 = path[len - 1][1],  // path end y\n        sx, sy,                 // current start coordinate\n        ex, ey,                 // current end coordinate\n        newPath,\n        i, j, coord, line, testCoord, blocked;\n\n    sx = x0;\n    sy = y0;\n    newPath = [[sx, sy]];\n\n    for (i = 2; i < len; ++i) {\n        coord = path[i];\n        ex = coord[0];\n        ey = coord[1];\n        line = interpolate(sx, sy, ex, ey);\n\n        blocked = false;\n        for (j = 1; j < line.length; ++j) {\n            testCoord = line[j];\n\n            if (!grid.isWalkableAt(testCoord[0], testCoord[1])) {\n                blocked = true;\n                break;\n            }\n        }\n        if (blocked) {\n            lastValidCoord = path[i - 1];\n            newPath.push(lastValidCoord);\n            sx = lastValidCoord[0];\n            sy = lastValidCoord[1];\n        }\n    }\n    newPath.push([x1, y1]);\n\n    return newPath;\n}\nexports.smoothenPath = smoothenPath;\n\n\n/**\n * Compress a path, remove redundant nodes without altering the shape\n * The original path is not modified\n * @param {Array.<Array.<number>>} path The path\n * @return {Array.<Array.<number>>} The compressed path\n */\nfunction compressPath(path) {\n\n    // nothing to compress\n    if(path.length < 3) {\n        return path;\n    }\n\n    var compressed = [],\n        sx = path[0][0], // start x\n        sy = path[0][1], // start y\n        px = path[1][0], // second point x\n        py = path[1][1], // second point y\n        dx = px - sx, // direction between the two points\n        dy = py - sy, // direction between the two points\n        lx, ly,\n        ldx, ldy,\n        sq, i;\n\n    // normalize the direction\n    sq = Math.sqrt(dx*dx + dy*dy);\n    dx /= sq;\n    dy /= sq;\n\n    // start the new path\n    compressed.push([sx,sy]);\n\n    for(i = 2; i < path.length; i++) {\n\n        // store the last point\n        lx = px;\n        ly = py;\n\n        // store the last direction\n        ldx = dx;\n        ldy = dy;\n\n        // next point\n        px = path[i][0];\n        py = path[i][1];\n\n        // next direction\n        dx = px - lx;\n        dy = py - ly;\n\n        // normalize\n        sq = Math.sqrt(dx*dx + dy*dy);\n        dx /= sq;\n        dy /= sq;\n\n        // if the direction has changed, store the point\n        if ( dx !== ldx || dy !== ldy ) {\n            compressed.push([lx,ly]);\n        }\n    }\n\n    // store the last point\n    compressed.push([px,py]);\n\n    return compressed;\n}\nexports.compressPath = compressPath;\n","var Heap       = require('heap');\nvar Util       = require('../core/Util');\nvar Heuristic  = require('../core/Heuristic');\nvar DiagonalMovement = require('../core/DiagonalMovement');\n\n/**\n * A* path-finder.\n * based upon https://github.com/bgrins/javascript-astar\n * @constructor\n * @param {object} opt\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed. Deprecated, use diagonalMovement instead.\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching block corners. Deprecated, use diagonalMovement instead.\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\n * @param {function} opt.heuristic Heuristic function to estimate the distance\n *     (defaults to manhattan).\n * @param {integer} opt.weight Weight to apply to the heuristic to allow for suboptimal paths, \n *     in order to speed up the search.\n */\nfunction AStarFinder(opt) {\n    opt = opt || {};\n    this.allowDiagonal = opt.allowDiagonal;\n    this.dontCrossCorners = opt.dontCrossCorners;\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\n    this.weight = opt.weight || 1;\n    this.diagonalMovement = opt.diagonalMovement;\n\n    if (!this.diagonalMovement) {\n        if (!this.allowDiagonal) {\n            this.diagonalMovement = DiagonalMovement.Never;\n        } else {\n            if (this.dontCrossCorners) {\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\n            } else {\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\n            }\n        }\n    }\n\n    //When diagonal movement is allowed the manhattan heuristic is not admissible\n    //It should be octile instead\n    if (this.diagonalMovement === DiagonalMovement.Never) {\n        this.heuristic = opt.heuristic || Heuristic.manhattan;\n    } else {\n        this.heuristic = opt.heuristic || Heuristic.octile;\n    }\n}\n\n/**\n * Find and return the the path.\n * @return {Array.<[number, number]>} The path, including both start and\n *     end positions.\n */\nAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\n    var openList = new Heap(function(nodeA, nodeB) {\n            return nodeA.f - nodeB.f;\n        }),\n        startNode = grid.getNodeAt(startX, startY),\n        endNode = grid.getNodeAt(endX, endY),\n        heuristic = this.heuristic,\n        diagonalMovement = this.diagonalMovement,\n        weight = this.weight,\n        abs = Math.abs, SQRT2 = Math.SQRT2,\n        node, neighbors, neighbor, i, l, x, y, ng;\n\n    // set the `g` and `f` value of the start node to be 0\n    startNode.g = 0;\n    startNode.f = 0;\n\n    // push the start node into the open list\n    openList.push(startNode);\n    startNode.opened = true;\n\n    // while the open list is not empty\n    while (!openList.empty()) {\n        // pop the position of node which has the minimum `f` value.\n        node = openList.pop();\n        node.closed = true;\n\n        // if reached the end position, construct the path and return it\n        if (node === endNode) {\n            return Util.backtrace(endNode);\n        }\n\n        // get neigbours of the current node\n        neighbors = grid.getNeighbors(node, diagonalMovement);\n        for (i = 0, l = neighbors.length; i < l; ++i) {\n            neighbor = neighbors[i];\n\n            if (neighbor.closed) {\n                continue;\n            }\n\n            x = neighbor.x;\n            y = neighbor.y;\n\n            // get the distance between current node and the neighbor\n            // and calculate the next g score\n            ng = node.g + neighbor.cost + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);\n\n            // check if the neighbor has not been inspected yet, or\n            // can be reached with smaller cost from the current node\n            if (!neighbor.opened || ng < neighbor.g) {\n                neighbor.g = ng;\n                neighbor.h = neighbor.h || weight * heuristic(abs(x - endX), abs(y - endY));\n                neighbor.f = neighbor.g + neighbor.h;\n                neighbor.parent = node;\n\n                if (!neighbor.opened) {\n                    openList.push(neighbor);\n                    neighbor.opened = true;\n                } else {\n                    // the neighbor can be reached with smaller cost.\n                    // Since its f value has been updated, we have to\n                    // update its position in the open list\n                    openList.updateItem(neighbor);\n                }\n            }\n        } // end for each neighbor\n    } // end while not open list empty\n\n    // fail to find the path\n    return [];\n};\n\nmodule.exports = AStarFinder;\n","var AStarFinder = require('./AStarFinder');\n\n/**\n * Best-First-Search path-finder.\n * @constructor\n * @extends AStarFinder\n * @param {object} opt\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed. Deprecated, use diagonalMovement instead.\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching block corners. Deprecated, use diagonalMovement instead.\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\n * @param {function} opt.heuristic Heuristic function to estimate the distance\n *     (defaults to manhattan).\n */\nfunction BestFirstFinder(opt) {\n    AStarFinder.call(this, opt);\n\n    var orig = this.heuristic;\n    this.heuristic = function(dx, dy) {\n        return orig(dx, dy) * 1000000;\n    };\n}\n\nBestFirstFinder.prototype = new AStarFinder();\nBestFirstFinder.prototype.constructor = BestFirstFinder;\n\nmodule.exports = BestFirstFinder;\n","var Heap       = require('heap');\nvar Util       = require('../core/Util');\nvar Heuristic  = require('../core/Heuristic');\nvar DiagonalMovement = require('../core/DiagonalMovement');\n\n/**\n * A* path-finder.\n * based upon https://github.com/bgrins/javascript-astar\n * @constructor\n * @param {object} opt\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed. Deprecated, use diagonalMovement instead.\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching block corners. Deprecated, use diagonalMovement instead.\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\n * @param {function} opt.heuristic Heuristic function to estimate the distance\n *     (defaults to manhattan).\n * @param {integer} opt.weight Weight to apply to the heuristic to allow for suboptimal paths, \n *     in order to speed up the search.\n */\nfunction BiAStarFinder(opt) {\n    opt = opt || {};\n    this.allowDiagonal = opt.allowDiagonal;\n    this.dontCrossCorners = opt.dontCrossCorners;\n    this.diagonalMovement = opt.diagonalMovement;\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\n    this.weight = opt.weight || 1;\n\n    if (!this.diagonalMovement) {\n        if (!this.allowDiagonal) {\n            this.diagonalMovement = DiagonalMovement.Never;\n        } else {\n            if (this.dontCrossCorners) {\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\n            } else {\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\n            }\n        }\n    }\n\n    //When diagonal movement is allowed the manhattan heuristic is not admissible\n    //It should be octile instead\n    if (this.diagonalMovement === DiagonalMovement.Never) {\n        this.heuristic = opt.heuristic || Heuristic.manhattan;\n    } else {\n        this.heuristic = opt.heuristic || Heuristic.octile;\n    }\n}\n\n/**\n * Find and return the the path.\n * @return {Array.<[number, number]>} The path, including both start and\n *     end positions.\n */\nBiAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\n    var cmp = function(nodeA, nodeB) {\n            return nodeA.f - nodeB.f;\n        },\n        startOpenList = new Heap(cmp),\n        endOpenList = new Heap(cmp),\n        startNode = grid.getNodeAt(startX, startY),\n        endNode = grid.getNodeAt(endX, endY),\n        heuristic = this.heuristic,\n        diagonalMovement = this.diagonalMovement,\n        weight = this.weight,\n        abs = Math.abs, SQRT2 = Math.SQRT2,\n        node, neighbors, neighbor, i, l, x, y, ng,\n        BY_START = 1, BY_END = 2;\n\n    // set the `g` and `f` value of the start node to be 0\n    // and push it into the start open list\n    startNode.g = 0;\n    startNode.f = 0;\n    startOpenList.push(startNode);\n    startNode.opened = BY_START;\n\n    // set the `g` and `f` value of the end node to be 0\n    // and push it into the open open list\n    endNode.g = 0;\n    endNode.f = 0;\n    endOpenList.push(endNode);\n    endNode.opened = BY_END;\n\n    // while both the open lists are not empty\n    while (!startOpenList.empty() && !endOpenList.empty()) {\n\n        // pop the position of start node which has the minimum `f` value.\n        node = startOpenList.pop();\n        node.closed = true;\n\n        // get neigbours of the current node\n        neighbors = grid.getNeighbors(node, diagonalMovement);\n        for (i = 0, l = neighbors.length; i < l; ++i) {\n            neighbor = neighbors[i];\n\n            if (neighbor.closed) {\n                continue;\n            }\n            if (neighbor.opened === BY_END) {\n                return Util.biBacktrace(node, neighbor);\n            }\n\n            x = neighbor.x;\n            y = neighbor.y;\n\n            // get the distance between current node and the neighbor\n            // and calculate the next g score\n            ng = node.g + neighbor.cost + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);\n\n            // check if the neighbor has not been inspected yet, or\n            // can be reached with smaller cost from the current node\n            if (!neighbor.opened || ng < neighbor.g) {\n                neighbor.g = ng;\n                neighbor.h = neighbor.h || weight * heuristic(abs(x - endX), abs(y - endY));\n                neighbor.f = neighbor.g + neighbor.h;\n                neighbor.parent = node;\n\n                if (!neighbor.opened) {\n                    startOpenList.push(neighbor);\n                    neighbor.opened = BY_START;\n                } else {\n                    // the neighbor can be reached with smaller cost.\n                    // Since its f value has been updated, we have to\n                    // update its position in the open list\n                    startOpenList.updateItem(neighbor);\n                }\n            }\n        } // end for each neighbor\n\n\n        // pop the position of end node which has the minimum `f` value.\n        node = endOpenList.pop();\n        node.closed = true;\n\n        // get neigbours of the current node\n        neighbors = grid.getNeighbors(node, diagonalMovement);\n        for (i = 0, l = neighbors.length; i < l; ++i) {\n            neighbor = neighbors[i];\n\n            if (neighbor.closed) {\n                continue;\n            }\n            if (neighbor.opened === BY_START) {\n                return Util.biBacktrace(neighbor, node);\n            }\n\n            x = neighbor.x;\n            y = neighbor.y;\n\n            // get the distance between current node and the neighbor\n            // and calculate the next g score\n            ng = node.g + neighbor.cost + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);\n\n            // check if the neighbor has not been inspected yet, or\n            // can be reached with smaller cost from the current node\n            if (!neighbor.opened || ng < neighbor.g) {\n                neighbor.g = ng;\n                neighbor.h = neighbor.h || weight * heuristic(abs(x - startX), abs(y - startY));\n                neighbor.f = neighbor.g + neighbor.h;\n                neighbor.parent = node;\n\n                if (!neighbor.opened) {\n                    endOpenList.push(neighbor);\n                    neighbor.opened = BY_END;\n                } else {\n                    // the neighbor can be reached with smaller cost.\n                    // Since its f value has been updated, we have to\n                    // update its position in the open list\n                    endOpenList.updateItem(neighbor);\n                }\n            }\n        } // end for each neighbor\n    } // end while not open list empty\n\n    // fail to find the path\n    return [];\n};\n\nmodule.exports = BiAStarFinder;\n","var BiAStarFinder = require('./BiAStarFinder');\n\n/**\n * Bi-direcitional Best-First-Search path-finder.\n * @constructor\n * @extends BiAStarFinder\n * @param {object} opt\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed. Deprecated, use diagonalMovement instead.\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching block corners. Deprecated, use diagonalMovement instead.\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\n * @param {function} opt.heuristic Heuristic function to estimate the distance\n *     (defaults to manhattan).\n */\nfunction BiBestFirstFinder(opt) {\n    BiAStarFinder.call(this, opt);\n\n    var orig = this.heuristic;\n    this.heuristic = function(dx, dy) {\n        return orig(dx, dy) * 1000000;\n    };\n}\n\nBiBestFirstFinder.prototype = new BiAStarFinder();\nBiBestFirstFinder.prototype.constructor = BiBestFirstFinder;\n\nmodule.exports = BiBestFirstFinder;\n","var Util = require('../core/Util');\nvar DiagonalMovement = require('../core/DiagonalMovement');\n\n/**\n * Bi-directional Breadth-First-Search path finder.\n * @constructor\n * @param {object} opt\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed. Deprecated, use diagonalMovement instead.\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching block corners. Deprecated, use diagonalMovement instead.\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\n */\nfunction BiBreadthFirstFinder(opt) {\n    opt = opt || {};\n    this.allowDiagonal = opt.allowDiagonal;\n    this.dontCrossCorners = opt.dontCrossCorners;\n    this.diagonalMovement = opt.diagonalMovement;\n\n    if (!this.diagonalMovement) {\n        if (!this.allowDiagonal) {\n            this.diagonalMovement = DiagonalMovement.Never;\n        } else {\n            if (this.dontCrossCorners) {\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\n            } else {\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\n            }\n        }\n    }\n}\n\n\n/**\n * Find and return the the path.\n * @return {Array.<[number, number]>} The path, including both start and\n *     end positions.\n */\nBiBreadthFirstFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\n    var startNode = grid.getNodeAt(startX, startY),\n        endNode = grid.getNodeAt(endX, endY),\n        startOpenList = [], endOpenList = [],\n        neighbors, neighbor, node,\n        diagonalMovement = this.diagonalMovement,\n        BY_START = 0, BY_END = 1,\n        i, l;\n\n    // push the start and end nodes into the queues\n    startOpenList.push(startNode);\n    startNode.opened = true;\n    startNode.by = BY_START;\n\n    endOpenList.push(endNode);\n    endNode.opened = true;\n    endNode.by = BY_END;\n\n    // while both the queues are not empty\n    while (startOpenList.length && endOpenList.length) {\n\n        // expand start open list\n\n        node = startOpenList.shift();\n        node.closed = true;\n\n        neighbors = grid.getNeighbors(node, diagonalMovement);\n        for (i = 0, l = neighbors.length; i < l; ++i) {\n            neighbor = neighbors[i];\n\n            if (neighbor.closed) {\n                continue;\n            }\n            if (neighbor.opened) {\n                // if this node has been inspected by the reversed search,\n                // then a path is found.\n                if (neighbor.by === BY_END) {\n                    return Util.biBacktrace(node, neighbor);\n                }\n                continue;\n            }\n            startOpenList.push(neighbor);\n            neighbor.parent = node;\n            neighbor.opened = true;\n            neighbor.by = BY_START;\n        }\n\n        // expand end open list\n\n        node = endOpenList.shift();\n        node.closed = true;\n\n        neighbors = grid.getNeighbors(node, diagonalMovement);\n        for (i = 0, l = neighbors.length; i < l; ++i) {\n            neighbor = neighbors[i];\n\n            if (neighbor.closed) {\n                continue;\n            }\n            if (neighbor.opened) {\n                if (neighbor.by === BY_START) {\n                    return Util.biBacktrace(neighbor, node);\n                }\n                continue;\n            }\n            endOpenList.push(neighbor);\n            neighbor.parent = node;\n            neighbor.opened = true;\n            neighbor.by = BY_END;\n        }\n    }\n\n    // fail to find the path\n    return [];\n};\n\nmodule.exports = BiBreadthFirstFinder;\n","var BiAStarFinder = require('./BiAStarFinder');\n\n/**\n * Bi-directional Dijkstra path-finder.\n * @constructor\n * @extends BiAStarFinder\n * @param {object} opt\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed. Deprecated, use diagonalMovement instead.\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching block corners. Deprecated, use diagonalMovement instead.\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\n */\nfunction BiDijkstraFinder(opt) {\n    BiAStarFinder.call(this, opt);\n    this.heuristic = function(dx, dy) {\n        return 0;\n    };\n}\n\nBiDijkstraFinder.prototype = new BiAStarFinder();\nBiDijkstraFinder.prototype.constructor = BiDijkstraFinder;\n\nmodule.exports = BiDijkstraFinder;\n","var Util = require('../core/Util');\nvar DiagonalMovement = require('../core/DiagonalMovement');\n\n/**\n * Breadth-First-Search path finder.\n * @constructor\n * @param {object} opt\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed. Deprecated, use diagonalMovement instead.\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching block corners. Deprecated, use diagonalMovement instead.\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\n */\nfunction BreadthFirstFinder(opt) {\n    opt = opt || {};\n    this.allowDiagonal = opt.allowDiagonal;\n    this.dontCrossCorners = opt.dontCrossCorners;\n    this.diagonalMovement = opt.diagonalMovement;\n\n    if (!this.diagonalMovement) {\n        if (!this.allowDiagonal) {\n            this.diagonalMovement = DiagonalMovement.Never;\n        } else {\n            if (this.dontCrossCorners) {\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\n            } else {\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\n            }\n        }\n    }\n}\n\n/**\n * Find and return the the path.\n * @return {Array.<[number, number]>} The path, including both start and\n *     end positions.\n */\nBreadthFirstFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\n    var openList = [],\n        diagonalMovement = this.diagonalMovement,\n        startNode = grid.getNodeAt(startX, startY),\n        endNode = grid.getNodeAt(endX, endY),\n        neighbors, neighbor, node, i, l;\n\n    // push the start pos into the queue\n    openList.push(startNode);\n    startNode.opened = true;\n\n    // while the queue is not empty\n    while (openList.length) {\n        // take the front node from the queue\n        node = openList.shift();\n        node.closed = true;\n\n        // reached the end position\n        if (node === endNode) {\n            return Util.backtrace(endNode);\n        }\n\n        neighbors = grid.getNeighbors(node, diagonalMovement);\n        for (i = 0, l = neighbors.length; i < l; ++i) {\n            neighbor = neighbors[i];\n\n            // skip this neighbor if it has been inspected before\n            if (neighbor.closed || neighbor.opened) {\n                continue;\n            }\n\n            openList.push(neighbor);\n            neighbor.opened = true;\n            neighbor.parent = node;\n        }\n    }\n    \n    // fail to find the path\n    return [];\n};\n\nmodule.exports = BreadthFirstFinder;\n","var AStarFinder = require('./AStarFinder');\n\n/**\n * Dijkstra path-finder.\n * @constructor\n * @extends AStarFinder\n * @param {object} opt\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed. Deprecated, use diagonalMovement instead.\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching block corners. Deprecated, use diagonalMovement instead.\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\n */\nfunction DijkstraFinder(opt) {\n    AStarFinder.call(this, opt);\n    this.heuristic = function(dx, dy) {\n        return 0;\n    };\n}\n\nDijkstraFinder.prototype = new AStarFinder();\nDijkstraFinder.prototype.constructor = DijkstraFinder;\n\nmodule.exports = DijkstraFinder;\n","var Util       = require('../core/Util');\nvar Heuristic  = require('../core/Heuristic');\nvar Node       = require('../core/Node');\nvar DiagonalMovement = require('../core/DiagonalMovement');\n\n/**\n * Iterative Deeping A Star (IDA*) path-finder.\n *\n * Recursion based on:\n *   http://www.apl.jhu.edu/~hall/AI-Programming/IDA-Star.html\n *\n * Path retracing based on:\n *  V. Nageshwara Rao, Vipin Kumar and K. Ramesh\n *  \"A Parallel Implementation of Iterative-Deeping-A*\", January 1987.\n *  ftp://ftp.cs.utexas.edu/.snapshot/hourly.1/pub/AI-Lab/tech-reports/UT-AI-TR-87-46.pdf\n *\n * @author Gerard Meier (www.gerardmeier.com)\n *\n * @constructor\n * @param {object} opt\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed. Deprecated, use diagonalMovement instead.\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching block corners. Deprecated, use diagonalMovement instead.\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\n * @param {function} opt.heuristic Heuristic function to estimate the distance\n *     (defaults to manhattan).\n * @param {integer} opt.weight Weight to apply to the heuristic to allow for suboptimal paths,\n *     in order to speed up the search.\n * @param {object} opt.trackRecursion Whether to track recursion for statistical purposes.\n * @param {object} opt.timeLimit Maximum execution time. Use <= 0 for infinite.\n */\n\nfunction IDAStarFinder(opt) {\n    opt = opt || {};\n    this.allowDiagonal = opt.allowDiagonal;\n    this.dontCrossCorners = opt.dontCrossCorners;\n    this.diagonalMovement = opt.diagonalMovement;\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\n    this.weight = opt.weight || 1;\n    this.trackRecursion = opt.trackRecursion || false;\n    this.timeLimit = opt.timeLimit || Infinity; // Default: no time limit.\n\n    if (!this.diagonalMovement) {\n        if (!this.allowDiagonal) {\n            this.diagonalMovement = DiagonalMovement.Never;\n        } else {\n            if (this.dontCrossCorners) {\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\n            } else {\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\n            }\n        }\n    }\n\n    //When diagonal movement is allowed the manhattan heuristic is not admissible\n    //It should be octile instead\n    if (this.diagonalMovement === DiagonalMovement.Never) {\n        this.heuristic = opt.heuristic || Heuristic.manhattan;\n    } else {\n        this.heuristic = opt.heuristic || Heuristic.octile;\n    }\n}\n\n/**\n * Find and return the the path. When an empty array is returned, either\n * no path is possible, or the maximum execution time is reached.\n *\n * @return {Array.<[number, number]>} The path, including both start and\n *     end positions.\n */\nIDAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\n    // Used for statistics:\n    var nodesVisited = 0;\n\n    // Execution time limitation:\n    var startTime = new Date().getTime();\n\n    // Heuristic helper:\n    var h = function(a, b) {\n        return this.heuristic(Math.abs(b.x - a.x), Math.abs(b.y - a.y));\n    }.bind(this);\n\n    // Step cost from a to b:\n    var cost = function(a, b) {\n        return (a.x === b.x || a.y === b.y) ? 1 : Math.SQRT2;\n    };\n\n    /**\n     * IDA* search implementation.\n     *\n     * @param {Node} The node currently expanding from.\n     * @param {number} Cost to reach the given node.\n     * @param {number} Maximum search depth (cut-off value).\n     * @param {{Array.<[number, number]>}} The found route.\n     * @param {number} Recursion depth.\n     *\n     * @return {Object} either a number with the new optimal cut-off depth,\n     * or a valid node instance, in which case a path was found.\n     */\n    var search = function(node, g, cutoff, route, depth) {\n        nodesVisited++;\n\n        // Enforce timelimit:\n        if(this.timeLimit > 0 && new Date().getTime() - startTime > this.timeLimit * 1000) {\n            // Enforced as \"path-not-found\".\n            return Infinity;\n        }\n\n        var f = g + h(node, end) * this.weight;\n\n        // We've searched too deep for this iteration.\n        if(f > cutoff) {\n            return f;\n        }\n\n        if(node == end) {\n            route[depth] = [node.x, node.y];\n            return node;\n        }\n\n        var min, t, k, neighbour;\n\n        var neighbours = grid.getNeighbors(node, this.diagonalMovement);\n\n        // Sort the neighbours, gives nicer paths. But, this deviates\n        // from the original algorithm - so I left it out.\n        //neighbours.sort(function(a, b){\n        //    return h(a, end) - h(b, end);\n        //});\n\n        \n        /*jshint -W084 *///Disable warning: Expected a conditional expression and instead saw an assignment\n        for(k = 0, min = Infinity; neighbour = neighbours[k]; ++k) {\n        /*jshint +W084 *///Enable warning: Expected a conditional expression and instead saw an assignment\n            if(this.trackRecursion) {\n                // Retain a copy for visualisation. Due to recursion, this\n                // node may be part of other paths too.\n                neighbour.retainCount = neighbour.retainCount + 1 || 1;\n\n                if(neighbour.tested !== true) {\n                    neighbour.tested = true;\n                }\n            }\n\n            t = search(neighbour, g + cost(node, neighbour), cutoff, route, depth + 1);\n\n            if(t instanceof Node) {\n                route[depth] = [node.x, node.y];\n\n                // For a typical A* linked list, this would work:\n                // neighbour.parent = node;\n                return t;\n            }\n\n            // Decrement count, then determine whether it's actually closed.\n            if(this.trackRecursion && (--neighbour.retainCount) === 0) {\n                neighbour.tested = false;\n            }\n\n            if(t < min) {\n                min = t;\n            }\n        }\n\n        return min;\n\n    }.bind(this);\n\n    // Node instance lookups:\n    var start = grid.getNodeAt(startX, startY);\n    var end   = grid.getNodeAt(endX, endY);\n\n    // Initial search depth, given the typical heuristic contraints,\n    // there should be no cheaper route possible.\n    var cutOff = h(start, end);\n\n    var j, route, t;\n\n    // With an overflow protection.\n    for(j = 0; true; ++j) {\n        //console.log(\"Iteration: \" + j + \", search cut-off value: \" + cutOff + \", nodes visited thus far: \" + nodesVisited + \".\");\n\n        route = [];\n\n        // Search till cut-off depth:\n        t = search(start, 0, cutOff, route, 0);\n\n        // Route not possible, or not found in time limit.\n        if(t === Infinity) {\n            return [];\n        }\n\n        // If t is a node, it's also the end node. Route is now\n        // populated with a valid path to the end node.\n        if(t instanceof Node) {\n            //console.log(\"Finished at iteration: \" + j + \", search cut-off value: \" + cutOff + \", nodes visited: \" + nodesVisited + \".\");\n            return route;\n        }\n\n        // Try again, this time with a deeper cut-off. The t score\n        // is the closest we got to the end node.\n        cutOff = t;\n    }\n\n    // This _should_ never to be reached.\n    return [];\n};\n\nmodule.exports = IDAStarFinder;\n","/**\n * @author imor / https://github.com/imor\n */\nvar JumpPointFinderBase = require('./JumpPointFinderBase');\nvar DiagonalMovement = require('../core/DiagonalMovement');\n\n/**\n * Path finder using the Jump Point Search algorithm which always moves\n * diagonally irrespective of the number of obstacles.\n */\nfunction JPFAlwaysMoveDiagonally(opt) {\n    JumpPointFinderBase.call(this, opt);\n}\n\nJPFAlwaysMoveDiagonally.prototype = new JumpPointFinderBase();\nJPFAlwaysMoveDiagonally.prototype.constructor = JPFAlwaysMoveDiagonally;\n\n/**\n * Search recursively in the direction (parent -> child), stopping only when a\n * jump point is found.\n * @protected\n * @return {Array.<[number, number]>} The x, y coordinate of the jump point\n *     found, or null if not found\n */\nJPFAlwaysMoveDiagonally.prototype._jump = function(x, y, px, py) {\n    var grid = this.grid,\n        dx = x - px, dy = y - py;\n\n    if (!grid.isWalkableAt(x, y)) {\n        return null;\n    }\n\n    if(this.trackJumpRecursion === true) {\n        grid.getNodeAt(x, y).tested = true;\n    }\n\n    if (grid.getNodeAt(x, y) === this.endNode) {\n        return [x, y];\n    }\n\n    // check for forced neighbors\n    // along the diagonal\n    if (dx !== 0 && dy !== 0) {\n        if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||\n            (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {\n            return [x, y];\n        }\n        // when moving diagonally, must check for vertical/horizontal jump points\n        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {\n            return [x, y];\n        }\n    }\n    // horizontally/vertically\n    else {\n        if( dx !== 0 ) { // moving along x\n            if((grid.isWalkableAt(x + dx, y + 1) && !grid.isWalkableAt(x, y + 1)) ||\n               (grid.isWalkableAt(x + dx, y - 1) && !grid.isWalkableAt(x, y - 1))) {\n                return [x, y];\n            }\n        }\n        else {\n            if((grid.isWalkableAt(x + 1, y + dy) && !grid.isWalkableAt(x + 1, y)) ||\n               (grid.isWalkableAt(x - 1, y + dy) && !grid.isWalkableAt(x - 1, y))) {\n                return [x, y];\n            }\n        }\n    }\n\n    return this._jump(x + dx, y + dy, x, y);\n};\n\n/**\n * Find the neighbors for the given node. If the node has a parent,\n * prune the neighbors based on the jump point search algorithm, otherwise\n * return all available neighbors.\n * @return {Array.<[number, number]>} The neighbors found.\n */\nJPFAlwaysMoveDiagonally.prototype._findNeighbors = function(node) {\n    var parent = node.parent,\n        x = node.x, y = node.y,\n        grid = this.grid,\n        px, py, nx, ny, dx, dy,\n        neighbors = [], neighborNodes, neighborNode, i, l;\n\n    // directed pruning: can ignore most neighbors, unless forced.\n    if (parent) {\n        px = parent.x;\n        py = parent.y;\n        // get the normalized direction of travel\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\n\n        // search diagonally\n        if (dx !== 0 && dy !== 0) {\n            if (grid.isWalkableAt(x, y + dy)) {\n                neighbors.push([x, y + dy]);\n            }\n            if (grid.isWalkableAt(x + dx, y)) {\n                neighbors.push([x + dx, y]);\n            }\n            if (grid.isWalkableAt(x + dx, y + dy)) {\n                neighbors.push([x + dx, y + dy]);\n            }\n            if (!grid.isWalkableAt(x - dx, y)) {\n                neighbors.push([x - dx, y + dy]);\n            }\n            if (!grid.isWalkableAt(x, y - dy)) {\n                neighbors.push([x + dx, y - dy]);\n            }\n        }\n        // search horizontally/vertically\n        else {\n            if(dx === 0) {\n                if (grid.isWalkableAt(x, y + dy)) {\n                    neighbors.push([x, y + dy]);\n                }\n                if (!grid.isWalkableAt(x + 1, y)) {\n                    neighbors.push([x + 1, y + dy]);\n                }\n                if (!grid.isWalkableAt(x - 1, y)) {\n                    neighbors.push([x - 1, y + dy]);\n                }\n            }\n            else {\n                if (grid.isWalkableAt(x + dx, y)) {\n                    neighbors.push([x + dx, y]);\n                }\n                if (!grid.isWalkableAt(x, y + 1)) {\n                    neighbors.push([x + dx, y + 1]);\n                }\n                if (!grid.isWalkableAt(x, y - 1)) {\n                    neighbors.push([x + dx, y - 1]);\n                }\n            }\n        }\n    }\n    // return all neighbors\n    else {\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.Always);\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\n            neighborNode = neighborNodes[i];\n            neighbors.push([neighborNode.x, neighborNode.y]);\n        }\n    }\n\n    return neighbors;\n};\n\nmodule.exports = JPFAlwaysMoveDiagonally;\n","/**\n * @author imor / https://github.com/imor\n */\nvar JumpPointFinderBase = require('./JumpPointFinderBase');\nvar DiagonalMovement = require('../core/DiagonalMovement');\n\n/**\n * Path finder using the Jump Point Search algorithm which moves\n * diagonally only when there is at most one obstacle.\n */\nfunction JPFMoveDiagonallyIfAtMostOneObstacle(opt) {\n    JumpPointFinderBase.call(this, opt);\n}\n\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype = new JumpPointFinderBase();\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype.constructor = JPFMoveDiagonallyIfAtMostOneObstacle;\n\n/**\n * Search recursively in the direction (parent -> child), stopping only when a\n * jump point is found.\n * @protected\n * @return {Array.<[number, number]>} The x, y coordinate of the jump point\n *     found, or null if not found\n */\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype._jump = function(x, y, px, py) {\n    var grid = this.grid,\n        dx = x - px, dy = y - py;\n\n    if (!grid.isWalkableAt(x, y)) {\n        return null;\n    }\n\n    if(this.trackJumpRecursion === true) {\n        grid.getNodeAt(x, y).tested = true;\n    }\n\n    if (grid.getNodeAt(x, y) === this.endNode) {\n        return [x, y];\n    }\n\n    // check for forced neighbors\n    // along the diagonal\n    if (dx !== 0 && dy !== 0) {\n        if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||\n            (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {\n            return [x, y];\n        }\n        // when moving diagonally, must check for vertical/horizontal jump points\n        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {\n            return [x, y];\n        }\n    }\n    // horizontally/vertically\n    else {\n        if( dx !== 0 ) { // moving along x\n            if((grid.isWalkableAt(x + dx, y + 1) && !grid.isWalkableAt(x, y + 1)) ||\n               (grid.isWalkableAt(x + dx, y - 1) && !grid.isWalkableAt(x, y - 1))) {\n                return [x, y];\n            }\n        }\n        else {\n            if((grid.isWalkableAt(x + 1, y + dy) && !grid.isWalkableAt(x + 1, y)) ||\n               (grid.isWalkableAt(x - 1, y + dy) && !grid.isWalkableAt(x - 1, y))) {\n                return [x, y];\n            }\n        }\n    }\n\n    // moving diagonally, must make sure one of the vertical/horizontal\n    // neighbors is open to allow the path\n    if (grid.isWalkableAt(x + dx, y) || grid.isWalkableAt(x, y + dy)) {\n        return this._jump(x + dx, y + dy, x, y);\n    } else {\n        return null;\n    }\n};\n\n/**\n * Find the neighbors for the given node. If the node has a parent,\n * prune the neighbors based on the jump point search algorithm, otherwise\n * return all available neighbors.\n * @return {Array.<[number, number]>} The neighbors found.\n */\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype._findNeighbors = function(node) {\n    var parent = node.parent,\n        x = node.x, y = node.y,\n        grid = this.grid,\n        px, py, nx, ny, dx, dy,\n        neighbors = [], neighborNodes, neighborNode, i, l;\n\n    // directed pruning: can ignore most neighbors, unless forced.\n    if (parent) {\n        px = parent.x;\n        py = parent.y;\n        // get the normalized direction of travel\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\n\n        // search diagonally\n        if (dx !== 0 && dy !== 0) {\n            if (grid.isWalkableAt(x, y + dy)) {\n                neighbors.push([x, y + dy]);\n            }\n            if (grid.isWalkableAt(x + dx, y)) {\n                neighbors.push([x + dx, y]);\n            }\n            if (grid.isWalkableAt(x, y + dy) || grid.isWalkableAt(x + dx, y)) {\n                neighbors.push([x + dx, y + dy]);\n            }\n            if (!grid.isWalkableAt(x - dx, y) && grid.isWalkableAt(x, y + dy)) {\n                neighbors.push([x - dx, y + dy]);\n            }\n            if (!grid.isWalkableAt(x, y - dy) && grid.isWalkableAt(x + dx, y)) {\n                neighbors.push([x + dx, y - dy]);\n            }\n        }\n        // search horizontally/vertically\n        else {\n            if(dx === 0) {\n                if (grid.isWalkableAt(x, y + dy)) {\n                    neighbors.push([x, y + dy]);\n                    if (!grid.isWalkableAt(x + 1, y)) {\n                        neighbors.push([x + 1, y + dy]);\n                    }\n                    if (!grid.isWalkableAt(x - 1, y)) {\n                        neighbors.push([x - 1, y + dy]);\n                    }\n                }\n            }\n            else {\n                if (grid.isWalkableAt(x + dx, y)) {\n                    neighbors.push([x + dx, y]);\n                    if (!grid.isWalkableAt(x, y + 1)) {\n                        neighbors.push([x + dx, y + 1]);\n                    }\n                    if (!grid.isWalkableAt(x, y - 1)) {\n                        neighbors.push([x + dx, y - 1]);\n                    }\n                }\n            }\n        }\n    }\n    // return all neighbors\n    else {\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.IfAtMostOneObstacle);\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\n            neighborNode = neighborNodes[i];\n            neighbors.push([neighborNode.x, neighborNode.y]);\n        }\n    }\n\n    return neighbors;\n};\n\nmodule.exports = JPFMoveDiagonallyIfAtMostOneObstacle;\n","/**\n * @author imor / https://github.com/imor\n */\nvar JumpPointFinderBase = require('./JumpPointFinderBase');\nvar DiagonalMovement = require('../core/DiagonalMovement');\n\n/**\n * Path finder using the Jump Point Search algorithm which moves\n * diagonally only when there are no obstacles.\n */\nfunction JPFMoveDiagonallyIfNoObstacles(opt) {\n    JumpPointFinderBase.call(this, opt);\n}\n\nJPFMoveDiagonallyIfNoObstacles.prototype = new JumpPointFinderBase();\nJPFMoveDiagonallyIfNoObstacles.prototype.constructor = JPFMoveDiagonallyIfNoObstacles;\n\n/**\n * Search recursively in the direction (parent -> child), stopping only when a\n * jump point is found.\n * @protected\n * @return {Array.<[number, number]>} The x, y coordinate of the jump point\n *     found, or null if not found\n */\nJPFMoveDiagonallyIfNoObstacles.prototype._jump = function(x, y, px, py) {\n    var grid = this.grid,\n        dx = x - px, dy = y - py;\n\n    if (!grid.isWalkableAt(x, y)) {\n        return null;\n    }\n\n    if(this.trackJumpRecursion === true) {\n        grid.getNodeAt(x, y).tested = true;\n    }\n\n    if (grid.getNodeAt(x, y) === this.endNode) {\n        return [x, y];\n    }\n\n    // check for forced neighbors\n    // along the diagonal\n    if (dx !== 0 && dy !== 0) {\n        // if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||\n            // (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {\n            // return [x, y];\n        // }\n        // when moving diagonally, must check for vertical/horizontal jump points\n        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {\n            return [x, y];\n        }\n    }\n    // horizontally/vertically\n    else {\n        if (dx !== 0) {\n            if ((grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1)) ||\n                (grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1))) {\n                return [x, y];\n            }\n        }\n        else if (dy !== 0) {\n            if ((grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy)) ||\n                (grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy))) {\n                return [x, y];\n            }\n            // When moving vertically, must check for horizontal jump points\n            // if (this._jump(x + 1, y, x, y) || this._jump(x - 1, y, x, y)) {\n                // return [x, y];\n            // }\n        }\n    }\n\n    // moving diagonally, must make sure one of the vertical/horizontal\n    // neighbors is open to allow the path\n    if (grid.isWalkableAt(x + dx, y) && grid.isWalkableAt(x, y + dy)) {\n        return this._jump(x + dx, y + dy, x, y);\n    } else {\n        return null;\n    }\n};\n\n/**\n * Find the neighbors for the given node. If the node has a parent,\n * prune the neighbors based on the jump point search algorithm, otherwise\n * return all available neighbors.\n * @return {Array.<[number, number]>} The neighbors found.\n */\nJPFMoveDiagonallyIfNoObstacles.prototype._findNeighbors = function(node) {\n    var parent = node.parent,\n        x = node.x, y = node.y,\n        grid = this.grid,\n        px, py, nx, ny, dx, dy,\n        neighbors = [], neighborNodes, neighborNode, i, l;\n\n    // directed pruning: can ignore most neighbors, unless forced.\n    if (parent) {\n        px = parent.x;\n        py = parent.y;\n        // get the normalized direction of travel\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\n\n        // search diagonally\n        if (dx !== 0 && dy !== 0) {\n            if (grid.isWalkableAt(x, y + dy)) {\n                neighbors.push([x, y + dy]);\n            }\n            if (grid.isWalkableAt(x + dx, y)) {\n                neighbors.push([x + dx, y]);\n            }\n            if (grid.isWalkableAt(x, y + dy) && grid.isWalkableAt(x + dx, y)) {\n                neighbors.push([x + dx, y + dy]);\n            }\n        }\n        // search horizontally/vertically\n        else {\n            var isNextWalkable;\n            if (dx !== 0) {\n                isNextWalkable = grid.isWalkableAt(x + dx, y);\n                var isTopWalkable = grid.isWalkableAt(x, y + 1);\n                var isBottomWalkable = grid.isWalkableAt(x, y - 1);\n\n                if (isNextWalkable) {\n                    neighbors.push([x + dx, y]);\n                    if (isTopWalkable) {\n                        neighbors.push([x + dx, y + 1]);\n                    }\n                    if (isBottomWalkable) {\n                        neighbors.push([x + dx, y - 1]);\n                    }\n                }\n                if (isTopWalkable) {\n                    neighbors.push([x, y + 1]);\n                }\n                if (isBottomWalkable) {\n                    neighbors.push([x, y - 1]);\n                }\n            }\n            else if (dy !== 0) {\n                isNextWalkable = grid.isWalkableAt(x, y + dy);\n                var isRightWalkable = grid.isWalkableAt(x + 1, y);\n                var isLeftWalkable = grid.isWalkableAt(x - 1, y);\n\n                if (isNextWalkable) {\n                    neighbors.push([x, y + dy]);\n                    if (isRightWalkable) {\n                        neighbors.push([x + 1, y + dy]);\n                    }\n                    if (isLeftWalkable) {\n                        neighbors.push([x - 1, y + dy]);\n                    }\n                }\n                if (isRightWalkable) {\n                    neighbors.push([x + 1, y]);\n                }\n                if (isLeftWalkable) {\n                    neighbors.push([x - 1, y]);\n                }\n            }\n        }\n    }\n    // return all neighbors\n    else {\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.OnlyWhenNoObstacles);\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\n            neighborNode = neighborNodes[i];\n            neighbors.push([neighborNode.x, neighborNode.y]);\n        }\n    }\n\n    return neighbors;\n};\n\nmodule.exports = JPFMoveDiagonallyIfNoObstacles;\n","/**\n * @author imor / https://github.com/imor\n */\nvar JumpPointFinderBase = require('./JumpPointFinderBase');\nvar DiagonalMovement = require('../core/DiagonalMovement');\n\n/**\n * Path finder using the Jump Point Search algorithm allowing only horizontal\n * or vertical movements.\n */\nfunction JPFNeverMoveDiagonally(opt) {\n    JumpPointFinderBase.call(this, opt);\n}\n\nJPFNeverMoveDiagonally.prototype = new JumpPointFinderBase();\nJPFNeverMoveDiagonally.prototype.constructor = JPFNeverMoveDiagonally;\n\n/**\n * Search recursively in the direction (parent -> child), stopping only when a\n * jump point is found.\n * @protected\n * @return {Array.<[number, number]>} The x, y coordinate of the jump point\n *     found, or null if not found\n */\nJPFNeverMoveDiagonally.prototype._jump = function(x, y, px, py) {\n    var grid = this.grid,\n        dx = x - px, dy = y - py;\n\n    if (!grid.isWalkableAt(x, y)) {\n        return null;\n    }\n\n    if(this.trackJumpRecursion === true) {\n        grid.getNodeAt(x, y).tested = true;\n    }\n\n    if (grid.getNodeAt(x, y) === this.endNode) {\n        return [x, y];\n    }\n\n    if (dx !== 0) {\n        if ((grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1)) ||\n            (grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1))) {\n            return [x, y];\n        }\n    }\n    else if (dy !== 0) {\n        if ((grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy)) ||\n            (grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy))) {\n            return [x, y];\n        }\n        //When moving vertically, must check for horizontal jump points\n        if (this._jump(x + 1, y, x, y) || this._jump(x - 1, y, x, y)) {\n            return [x, y];\n        }\n    }\n    else {\n        throw new Error(\"Only horizontal and vertical movements are allowed\");\n    }\n\n    return this._jump(x + dx, y + dy, x, y);\n};\n\n/**\n * Find the neighbors for the given node. If the node has a parent,\n * prune the neighbors based on the jump point search algorithm, otherwise\n * return all available neighbors.\n * @return {Array.<[number, number]>} The neighbors found.\n */\nJPFNeverMoveDiagonally.prototype._findNeighbors = function(node) {\n    var parent = node.parent,\n        x = node.x, y = node.y,\n        grid = this.grid,\n        px, py, nx, ny, dx, dy,\n        neighbors = [], neighborNodes, neighborNode, i, l;\n\n    // directed pruning: can ignore most neighbors, unless forced.\n    if (parent) {\n        px = parent.x;\n        py = parent.y;\n        // get the normalized direction of travel\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\n\n        if (dx !== 0) {\n            if (grid.isWalkableAt(x, y - 1)) {\n                neighbors.push([x, y - 1]);\n            }\n            if (grid.isWalkableAt(x, y + 1)) {\n                neighbors.push([x, y + 1]);\n            }\n            if (grid.isWalkableAt(x + dx, y)) {\n                neighbors.push([x + dx, y]);\n            }\n        }\n        else if (dy !== 0) {\n            if (grid.isWalkableAt(x - 1, y)) {\n                neighbors.push([x - 1, y]);\n            }\n            if (grid.isWalkableAt(x + 1, y)) {\n                neighbors.push([x + 1, y]);\n            }\n            if (grid.isWalkableAt(x, y + dy)) {\n                neighbors.push([x, y + dy]);\n            }\n        }\n    }\n    // return all neighbors\n    else {\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.Never);\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\n            neighborNode = neighborNodes[i];\n            neighbors.push([neighborNode.x, neighborNode.y]);\n        }\n    }\n\n    return neighbors;\n};\n\nmodule.exports = JPFNeverMoveDiagonally;\n","/**\n * @author aniero / https://github.com/aniero\n */\nvar DiagonalMovement = require('../core/DiagonalMovement');\nvar JPFNeverMoveDiagonally = require('./JPFNeverMoveDiagonally');\nvar JPFAlwaysMoveDiagonally = require('./JPFAlwaysMoveDiagonally');\nvar JPFMoveDiagonallyIfNoObstacles = require('./JPFMoveDiagonallyIfNoObstacles');\nvar JPFMoveDiagonallyIfAtMostOneObstacle = require('./JPFMoveDiagonallyIfAtMostOneObstacle');\n\n/**\n * Path finder using the Jump Point Search algorithm\n * @param {object} opt\n * @param {function} opt.heuristic Heuristic function to estimate the distance\n *     (defaults to manhattan).\n * @param {DiagonalMovement} opt.diagonalMovement Condition under which diagonal\n *      movement will be allowed.\n */\nfunction JumpPointFinder(opt) {\n    opt = opt || {};\n    if (opt.diagonalMovement === DiagonalMovement.Never) {\n        return new JPFNeverMoveDiagonally(opt);\n    } else if (opt.diagonalMovement === DiagonalMovement.Always) {\n        return new JPFAlwaysMoveDiagonally(opt);\n    } else if (opt.diagonalMovement === DiagonalMovement.OnlyWhenNoObstacles) {\n        return new JPFMoveDiagonallyIfNoObstacles(opt);\n    } else {\n        return new JPFMoveDiagonallyIfAtMostOneObstacle(opt);\n    }\n}\n\nmodule.exports = JumpPointFinder;\n","/**\n * @author imor / https://github.com/imor\n */\nvar Heap       = require('heap');\nvar Util       = require('../core/Util');\nvar Heuristic  = require('../core/Heuristic');\nvar DiagonalMovement = require('../core/DiagonalMovement');\n\n/**\n * Base class for the Jump Point Search algorithm\n * @param {object} opt\n * @param {function} opt.heuristic Heuristic function to estimate the distance\n *     (defaults to manhattan).\n */\nfunction JumpPointFinderBase(opt) {\n    opt = opt || {};\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\n    this.trackJumpRecursion = opt.trackJumpRecursion || false;\n}\n\n/**\n * Find and return the path.\n * @return {Array.<[number, number]>} The path, including both start and\n *     end positions.\n */\nJumpPointFinderBase.prototype.findPath = function(startX, startY, endX, endY, grid) {\n    var openList = this.openList = new Heap(function(nodeA, nodeB) {\n            return nodeA.f - nodeB.f;\n        }),\n        startNode = this.startNode = grid.getNodeAt(startX, startY),\n        endNode = this.endNode = grid.getNodeAt(endX, endY), node;\n\n    this.grid = grid;\n\n\n    // set the `g` and `f` value of the start node to be 0\n    startNode.g = 0;\n    startNode.f = 0;\n\n    // push the start node into the open list\n    openList.push(startNode);\n    startNode.opened = true;\n\n    // while the open list is not empty\n    while (!openList.empty()) {\n        // pop the position of node which has the minimum `f` value.\n        node = openList.pop();\n        node.closed = true;\n\n        if (node === endNode) {\n            return Util.expandPath(Util.backtrace(endNode));\n        }\n\n        this._identifySuccessors(node);\n    }\n\n    // fail to find the path\n    return [];\n};\n\n/**\n * Identify successors for the given node. Runs a jump point search in the\n * direction of each available neighbor, adding any points found to the open\n * list.\n * @protected\n */\nJumpPointFinderBase.prototype._identifySuccessors = function(node) {\n    var grid = this.grid,\n        heuristic = this.heuristic,\n        openList = this.openList,\n        endX = this.endNode.x,\n        endY = this.endNode.y,\n        neighbors, neighbor,\n        jumpPoint, i, l,\n        x = node.x, y = node.y,\n        jx, jy, dx, dy, d, ng, jumpNode,\n        abs = Math.abs, max = Math.max;\n\n    neighbors = this._findNeighbors(node);\n    for(i = 0, l = neighbors.length; i < l; ++i) {\n        neighbor = neighbors[i];\n        jumpPoint = this._jump(neighbor[0], neighbor[1], x, y);\n        if (jumpPoint) {\n\n            jx = jumpPoint[0];\n            jy = jumpPoint[1];\n            jumpNode = grid.getNodeAt(jx, jy);\n\n            if (jumpNode.closed) {\n                continue;\n            }\n\n            // include distance, as parent may not be immediately adjacent:\n            d = Heuristic.octile(abs(jx - x), abs(jy - y));\n            ng = node.g + d; // next `g` value\n\n            if (!jumpNode.opened || ng < jumpNode.g) {\n                jumpNode.g = ng;\n                jumpNode.h = jumpNode.h || heuristic(abs(jx - endX), abs(jy - endY));\n                jumpNode.f = jumpNode.g + jumpNode.h;\n                jumpNode.parent = node;\n\n                if (!jumpNode.opened) {\n                    openList.push(jumpNode);\n                    jumpNode.opened = true;\n                } else {\n                    openList.updateItem(jumpNode);\n                }\n            }\n        }\n    }\n};\n\nmodule.exports = JumpPointFinderBase;\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJkaXN0L2xpYi9ncmlkRGlzdGFuY2UuanMiLCJkaXN0L2xpYi9zb3J0ZWRGb29kLmpzIiwiZGlzdC9saWIvd2VpZ2h0LmpzIiwiZGlzdC93ZWIuanMiLCJub2RlX21vZHVsZXMvaGVhcC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9oZWFwL2xpYi9oZWFwLmpzIiwibm9kZV9tb2R1bGVzL3BhdGhmaW5kaW5nL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3BhdGhmaW5kaW5nL3NyYy9QYXRoRmluZGluZy5qcyIsIm5vZGVfbW9kdWxlcy9wYXRoZmluZGluZy9zcmMvY29yZS9EaWFnb25hbE1vdmVtZW50LmpzIiwibm9kZV9tb2R1bGVzL3BhdGhmaW5kaW5nL3NyYy9jb3JlL0dyaWQuanMiLCJub2RlX21vZHVsZXMvcGF0aGZpbmRpbmcvc3JjL2NvcmUvSGV1cmlzdGljLmpzIiwibm9kZV9tb2R1bGVzL3BhdGhmaW5kaW5nL3NyYy9jb3JlL05vZGUuanMiLCJub2RlX21vZHVsZXMvcGF0aGZpbmRpbmcvc3JjL2NvcmUvVXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9wYXRoZmluZGluZy9zcmMvZmluZGVycy9BU3RhckZpbmRlci5qcyIsIm5vZGVfbW9kdWxlcy9wYXRoZmluZGluZy9zcmMvZmluZGVycy9CZXN0Rmlyc3RGaW5kZXIuanMiLCJub2RlX21vZHVsZXMvcGF0aGZpbmRpbmcvc3JjL2ZpbmRlcnMvQmlBU3RhckZpbmRlci5qcyIsIm5vZGVfbW9kdWxlcy9wYXRoZmluZGluZy9zcmMvZmluZGVycy9CaUJlc3RGaXJzdEZpbmRlci5qcyIsIm5vZGVfbW9kdWxlcy9wYXRoZmluZGluZy9zcmMvZmluZGVycy9CaUJyZWFkdGhGaXJzdEZpbmRlci5qcyIsIm5vZGVfbW9kdWxlcy9wYXRoZmluZGluZy9zcmMvZmluZGVycy9CaURpamtzdHJhRmluZGVyLmpzIiwibm9kZV9tb2R1bGVzL3BhdGhmaW5kaW5nL3NyYy9maW5kZXJzL0JyZWFkdGhGaXJzdEZpbmRlci5qcyIsIm5vZGVfbW9kdWxlcy9wYXRoZmluZGluZy9zcmMvZmluZGVycy9EaWprc3RyYUZpbmRlci5qcyIsIm5vZGVfbW9kdWxlcy9wYXRoZmluZGluZy9zcmMvZmluZGVycy9JREFTdGFyRmluZGVyLmpzIiwibm9kZV9tb2R1bGVzL3BhdGhmaW5kaW5nL3NyYy9maW5kZXJzL0pQRkFsd2F5c01vdmVEaWFnb25hbGx5LmpzIiwibm9kZV9tb2R1bGVzL3BhdGhmaW5kaW5nL3NyYy9maW5kZXJzL0pQRk1vdmVEaWFnb25hbGx5SWZBdE1vc3RPbmVPYnN0YWNsZS5qcyIsIm5vZGVfbW9kdWxlcy9wYXRoZmluZGluZy9zcmMvZmluZGVycy9KUEZNb3ZlRGlhZ29uYWxseUlmTm9PYnN0YWNsZXMuanMiLCJub2RlX21vZHVsZXMvcGF0aGZpbmRpbmcvc3JjL2ZpbmRlcnMvSlBGTmV2ZXJNb3ZlRGlhZ29uYWxseS5qcyIsIm5vZGVfbW9kdWxlcy9wYXRoZmluZGluZy9zcmMvZmluZGVycy9KdW1wUG9pbnRGaW5kZXIuanMiLCJub2RlX21vZHVsZXMvcGF0aGZpbmRpbmcvc3JjL2ZpbmRlcnMvSnVtcFBvaW50RmluZGVyQmFzZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbktBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalhBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBncmlkRGlzdGFuY2UoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICByZXR1cm4gTWF0aC5hYnMoeDEgLSB4MikgKyBNYXRoLmFicyh5MSAtIHkyKTtcbn1cbmV4cG9ydHMuZ3JpZERpc3RhbmNlID0gZ3JpZERpc3RhbmNlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBncmlkRGlzdGFuY2VfMSA9IHJlcXVpcmUoXCIuL2dyaWREaXN0YW5jZVwiKTtcbmZ1bmN0aW9uIHNvcnRlZEZvb2QoZGF0YSkge1xuICAgIGNvbnN0IHNvcnRlZCA9IHtcbiAgICAgICAgZm9vZDogbnVsbCxcbiAgICAgICAgZGlzdGFuY2U6IDEwMDAwMCxcbiAgICB9O1xuICAgIGlmICghZGF0YS5ib2FyZC5mb29kLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIChjb25zdCBmb29kIG9mIGRhdGEuYm9hcmQuZm9vZCkge1xuICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICBmb29kOiBmb29kLFxuICAgICAgICAgICAgZGlzdGFuY2U6IGdyaWREaXN0YW5jZV8xLmdyaWREaXN0YW5jZShkYXRhLnlvdS5ib2R5WzBdLngsIGRhdGEueW91LmJvZHlbMF0ueSwgZm9vZC54LCBmb29kLnkpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVzdWx0LnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgcmV0dXJuIGEuZGlzdGFuY2UgLSBiLmRpc3RhbmNlO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLnNvcnRlZEZvb2QgPSBzb3J0ZWRGb29kO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBncmlkRGlzdGFuY2VfMSA9IHJlcXVpcmUoXCIuL2dyaWREaXN0YW5jZVwiKTtcbmZ1bmN0aW9uIHdlaWdodChkYXRhLCB4LCB5KSB7XG4gICAgZm9yIChjb25zdCBzbmFrZSBvZiBkYXRhLmJvYXJkLnNuYWtlcykge1xuICAgICAgICBjb25zdCBib2R5ID0gc25ha2UuYm9keTtcbiAgICAgICAgLy8gY29uc3QgYm9keSA9IHNuYWtlLmJvZHkuZmlsdGVyKChwMSwgaSwgYSkgPT4gYS5maW5kSW5kZXgocDIgPT4gcDEueCA9PSBwMi54ICYmIHAxLnkgPT0gcDIueSkgPT09IGkpO1xuICAgICAgICBmb3IgKGNvbnN0IFtwLCBwYXJ0XSBvZiBib2R5LmVudHJpZXMoKSkge1xuICAgICAgICAgICAgLy8gSXMgcGFydCBvZiBzbmFrZT9cbiAgICAgICAgICAgIGlmIChwYXJ0LnggPT0geCAmJiBwYXJ0LnkgPT0geSkge1xuICAgICAgICAgICAgICAgIC8vIElzIGVuZCBvZiBzbmFrZT9cbiAgICAgICAgICAgICAgICBpZiAocCAhPSBib2R5Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3Qgc25ha2Ugb2YgZGF0YS5ib2FyZC5zbmFrZXMpIHtcbiAgICAgICAgY29uc3QgYm9keSA9IHNuYWtlLmJvZHk7XG4gICAgICAgIGZvciAoY29uc3QgW3AsIHBhcnRdIG9mIGJvZHkuZW50cmllcygpKSB7XG4gICAgICAgICAgICAvLyBJcyBuZWFyIGhlYWQ/XG4gICAgICAgICAgICBpZiAoc25ha2UuaWQgIT0gZGF0YS55b3UuaWQgJiYgcCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBncmlkRGlzdGFuY2VfMS5ncmlkRGlzdGFuY2UoeCwgeSwgcGFydC54LCBwYXJ0LnkpO1xuICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZSA8IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpc3RhbmNlICogMTA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiA1MDtcbn1cbmV4cG9ydHMud2VpZ2h0ID0gd2VpZ2h0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB3ZWlnaHRfMSA9IHJlcXVpcmUoXCIuL2xpYi93ZWlnaHRcIik7XG5jb25zdCBzb3J0ZWRGb29kXzEgPSByZXF1aXJlKFwiLi9saWIvc29ydGVkRm9vZFwiKTtcbmNvbnN0IFBGID0gcmVxdWlyZSgncGF0aGZpbmRpbmcnKTtcbi8vIGNvbnN0IGNvbG9ycyA9IFsnIzJlY2M3MScsICcjMzQ5OGRiJywgJyM5YjU5YjYnLCAnI2YxYzQwZicsICcjZTY3ZTIyJywgJyNlNzRjM2MnLCAnIzk1YTVhNicsICcjMzQ0OTVlJ107XG5jb25zdCBncmlkID0gJCgnLmdyaWQnKTtcbmNvbnN0IGdldENvbCA9ICh4LCB5KSA9PiB7XG4gICAgcmV0dXJuIGdyaWQuZmluZCgnLnJvdycpLmVxKHkpLmZpbmQoJy5jb2wnKS5lcSh4KTtcbn07XG5jb25zdCBCTE9DS0VEID0gMTtcbmNvbnN0IEZSRUUgPSAwO1xuY29uc3QgcGYgPSBuZXcgUEYuQVN0YXJGaW5kZXIoe1xuICAgIGFsbG93RGlhZ29uYWw6IGZhbHNlLFxuICAgIHVzZUNvc3Q6IHRydWUsXG59KTtcbmNvbnN0IGRyYXdCb2FyZCA9IChkYXRhKSA9PiB7XG4gICAgZ3JpZC5odG1sKCcnKTtcbiAgICBjb25zdCBtYXRyaXggPSBbXTtcbiAgICBjb25zdCBjb3N0cyA9IFtdO1xuICAgIGZvciAodmFyIHkgPSAwOyB5IDwgZGF0YS5ib2FyZC5oZWlnaHQ7IHkrKykge1xuICAgICAgICBtYXRyaXhbeV0gPSBbXTtcbiAgICAgICAgY29zdHNbeV0gPSBbXTtcbiAgICAgICAgY29uc3Qgcm93ID0gJCgnPGRpdj4nKS5hZGRDbGFzcygncm93JykuYXBwZW5kVG8oZ3JpZCk7XG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgZGF0YS5ib2FyZC53aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICBjb25zdCB3ID0gd2VpZ2h0XzEud2VpZ2h0KGRhdGEsIHgsIHkpO1xuICAgICAgICAgICAgbWF0cml4W3ldW3hdID0gdyA+IDAgPyBGUkVFIDogQkxPQ0tFRDtcbiAgICAgICAgICAgIGNvc3RzW3ldW3hdID0gMTAwIC0gdztcbiAgICAgICAgICAgIGNvbnN0IGNvbCA9ICQoJzxkaXY+JykuYWRkQ2xhc3MoJ2NvbCcpLmNzcyh7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBgcmdiYSgwLCAwLCAwLCAkeygxMDAgLSB3KSAvIDEwMH0pYCxcbiAgICAgICAgICAgIH0pLmFwcGVuZFRvKHJvdyk7XG4gICAgICAgICAgICAkKCc8ZGl2PicpLmFkZENsYXNzKCd3ZWlnaHQnKS5odG1sKHggKyAnLycgKyB5ICsgJzxici8+dzonICsgdyArICc8YnIvPicgKyAobWF0cml4W3ldW3hdID09IEZSRUUgPyAnRlJFRScgOiAnQkxPQ0tFRCcpICsgJzxici8+YzonICsgY29zdHNbeV1beF0pLmNzcyh7XG4gICAgICAgICAgICAgICAgY29sb3I6IHcgPCA2MCA/ICd3aGl0ZScgOiAnYmxhY2snLFxuICAgICAgICAgICAgfSkuYXBwZW5kVG8oY29sKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGZvb2Qgb2YgZGF0YS5ib2FyZC5mb29kKSB7XG4gICAgICAgIGNvbnN0IGNvbCA9IGdldENvbChmb29kLngsIGZvb2QueSk7XG4gICAgICAgICQoJzxkaXY+JykuYWRkQ2xhc3MoJ2Zvb2QnKS5hcHBlbmRUbyhjb2wpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHNuYWtlIG9mIGRhdGEuYm9hcmQuc25ha2VzKSB7XG4gICAgICAgIGNvbnN0IGNvbG9yID0gc25ha2UuaWQgPT0gZGF0YS55b3UuaWQgPyAnIzJlY2M3MScgOiAnI2U3NGMzYyc7XG4gICAgICAgIGZvciAoY29uc3QgW3AsIHBhcnRdIG9mIHNuYWtlLmJvZHkuZW50cmllcygpKSB7XG4gICAgICAgICAgICBjb25zdCBjb2wgPSBnZXRDb2wocGFydC54LCBwYXJ0LnkpO1xuICAgICAgICAgICAgJCgnPGRpdj4nKS5hZGRDbGFzcygnc25ha2UnKS5jc3Moe1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiBwID09IDAgPyAxMDAgOiAwLFxuICAgICAgICAgICAgfSkudGV4dCgnICcpLmFwcGVuZFRvKGNvbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc29ydGVkID0gc29ydGVkRm9vZF8xLnNvcnRlZEZvb2QoZGF0YSk7XG4gICAgaWYgKCFzb3J0ZWQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc29sZS5sb2coJ3NvcnRlZCcsIHNvcnRlZCk7XG4gICAgY2xvc2VzdDogZm9yIChjb25zdCBjbG9zZXN0IG9mIHNvcnRlZCkge1xuICAgICAgICBjb25zb2xlLmxvZygnY2xvc2VzdCcsIGNsb3Nlc3QpO1xuICAgICAgICBjb25zdCBwZkdyaWQgPSBuZXcgUEYuR3JpZChkYXRhLmJvYXJkLndpZHRoLCBkYXRhLmJvYXJkLmhlaWdodCwgbWF0cml4LCBjb3N0cyk7XG4gICAgICAgIGNvbnN0IHBhdGggPSBwZi5maW5kUGF0aChkYXRhLnlvdS5ib2R5WzBdLngsIGRhdGEueW91LmJvZHlbMF0ueSwgY2xvc2VzdC5mb29kLngsIGNsb3Nlc3QuZm9vZC55LCBwZkdyaWQuY2xvbmUoKSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcCA9IHBhdGhbaV07XG4gICAgICAgICAgICBpZiAoaSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb2wgPSBnZXRDb2wocFswXSwgcFsxXSk7XG4gICAgICAgICAgICAkKCc8ZGl2PicpLmFkZENsYXNzKCdwYXRoJykuYXBwZW5kVG8oY29sKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHAgPSBwYXRoW2ldO1xuICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwWzBdID09IGRhdGEueW91LmJvZHlbMF0ueCAtIDEgJiYgcFsxXSA9PSBkYXRhLnlvdS5ib2R5WzBdLnkpIHtcbiAgICAgICAgICAgICAgICAvLyBMZWZ0XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ21vdmVUb3dhcmRzRm9vZFBmJywgcCwgJ2xlZnQnKTtcbiAgICAgICAgICAgICAgICBicmVhayBjbG9zZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocFswXSA9PSBkYXRhLnlvdS5ib2R5WzBdLnggKyAxICYmIHBbMV0gPT0gZGF0YS55b3UuYm9keVswXS55KSB7XG4gICAgICAgICAgICAgICAgLy8gUmlnaHRcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnbW92ZVRvd2FyZHNGb29kUGYnLCBwLCAncmlnaHQnKTtcbiAgICAgICAgICAgICAgICBicmVhayBjbG9zZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocFswXSA9PSBkYXRhLnlvdS5ib2R5WzBdLnggJiYgcFsxXSA9PSBkYXRhLnlvdS5ib2R5WzBdLnkgLSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gVXBcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnbW92ZVRvd2FyZHNGb29kUGYnLCBwLCAndXAnKTtcbiAgICAgICAgICAgICAgICBicmVhayBjbG9zZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocFswXSA9PSBkYXRhLnlvdS5ib2R5WzBdLnggJiYgcFsxXSA9PSBkYXRhLnlvdS5ib2R5WzBdLnkgKyAxKSB7XG4gICAgICAgICAgICAgICAgLy8gRG93blxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdtb3ZlVG93YXJkc0Zvb2RQZicsIHAsICdkb3duJyk7XG4gICAgICAgICAgICAgICAgYnJlYWsgY2xvc2VzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdtb3ZlVG93YXJkc0Zvb2RQZicsIHAsICdubyBwYXRoJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gaGFzV2F5T3V0KGRhdGEsIHBhdGgpO1xufTtcbmNvbnN0IGhhc1dheU91dCA9IChkYXRhLCBwYXRoKSA9PiB7XG4gICAgY29uc3QgbWF0cml4ID0gW107XG4gICAgY29uc3QgY29zdHMgPSBbXTtcbiAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGRhdGEuYm9hcmQuaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgbWF0cml4W3ldID0gW107XG4gICAgICAgIGNvc3RzW3ldID0gW107XG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgZGF0YS5ib2FyZC53aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICBjb25zdCB3ID0gd2VpZ2h0XzEud2VpZ2h0KGRhdGEsIHgsIHkpO1xuICAgICAgICAgICAgbWF0cml4W3ldW3hdID0gdyA+IDAgPyBGUkVFIDogQkxPQ0tFRDtcbiAgICAgICAgICAgIGNvc3RzW3ldW3hdID0gMTAwIC0gdztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtpLCBwXSBvZiBwYXRoLmVudHJpZXMoKSkge1xuICAgICAgICBtYXRyaXhbcFsxXV1bcFswXV0gPSBCTE9DS0VEO1xuICAgIH1cbiAgICBjb25zdCBwZkdyaWQgPSBuZXcgUEYuR3JpZChkYXRhLmJvYXJkLndpZHRoLCBkYXRhLmJvYXJkLmhlaWdodCwgbWF0cml4LCBjb3N0cyk7XG4gICAgZm9yIChjb25zdCBmb29kIG9mIGRhdGEuYm9hcmQuZm9vZCkge1xuICAgICAgICBjb25zdCB3YXlPdXRQYXRoID0gcGYuZmluZFBhdGgoZGF0YS55b3UuYm9keVswXS54LCBkYXRhLnlvdS5ib2R5WzBdLnksIGZvb2QueCwgZm9vZC55LCBwZkdyaWQuY2xvbmUoKSk7XG4gICAgICAgIGNvbnNvbGUubG9nKHdheU91dFBhdGgpO1xuICAgIH1cbn07XG5sZXQgZ2FtZSA9IG51bGw7XG5jb25zdCBsb2FkR2FtZSA9IChnYW1lRmlsZSwgdHVybiA9IG51bGwpID0+IHtcbiAgICAkKCcubW92ZXMnKS5odG1sKCcnKTtcbiAgICAkLmdldEpTT04oJy4uL2dhbWVzLycgKyBnYW1lRmlsZSkuZG9uZSgocmVzcG9uc2UpID0+IHtcbiAgICAgICAgZ2FtZSA9IHJlc3BvbnNlO1xuICAgICAgICBpZiAodHVybikge1xuICAgICAgICAgICAgZHJhd0JvYXJkKGdhbWUubW92ZXNbdHVybl0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZHJhd0JvYXJkKGdhbWUuc3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgbW92ZSBvZiBnYW1lLm1vdmVzKSB7XG4gICAgICAgICAgICBpZiAoIW1vdmUgfHwgIW1vdmUudHVybikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJCgnPGRpdj4nKS5hZGRDbGFzcygnbW92ZScpLmRhdGEoJ3R1cm4nLCBtb3ZlLnR1cm4pLnRleHQoJ01vdmUgJyArIG1vdmUudHVybikuYXBwZW5kVG8oJy5tb3ZlcycpO1xuICAgICAgICB9XG4gICAgfSkuZmFpbCgoeGhyLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikgPT4ge1xuICAgICAgICAkKCcubG9nJykudGV4dCh0ZXh0U3RhdHVzICsgJzogJyArIGVycm9yVGhyb3duKTtcbiAgICAgICAgY29uc29sZS5lcnJvcih0ZXh0U3RhdHVzLCBlcnJvclRocm93bik7XG4gICAgfSk7XG59O1xuJCgnLmdhbWUnKS5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgZ2FtZUZpbGUgPSAkKHRoaXMpLmRhdGEoJ2dhbWUnKTtcbiAgICBsb2FkR2FtZShnYW1lRmlsZSk7XG59KTtcbmNvbnN0IHVybFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMod2luZG93LmxvY2F0aW9uLnNlYXJjaCk7XG5jb25zdCBxdWVyeUdhbWUgPSB1cmxQYXJhbXMuZ2V0KCdnYW1lJyk7XG5jb25zdCBxdWVyeVR1cm4gPSB1cmxQYXJhbXMuZ2V0KCd0dXJuJyk7XG5pZiAocXVlcnlHYW1lKSB7XG4gICAgbG9hZEdhbWUocXVlcnlHYW1lLCBxdWVyeVR1cm4pO1xufVxuZWxzZSB7XG4gICAgJCgnLmdhbWU6bGFzdCcpLmNsaWNrKCk7XG59XG4kKCcubW92ZXMnKS5vbignY2xpY2snLCAnLm1vdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgdHVybiA9ICQodGhpcykuZGF0YSgndHVybicpO1xuICAgIGRyYXdCb2FyZChnYW1lLm1vdmVzW3R1cm5dKTtcbiAgICBjb25zdCBuZXdVcmwgPSB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyB3aW5kb3cubG9jYXRpb24uaG9zdCArIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSArICc/Z2FtZT0nICsgZ2FtZS5tb3Zlc1t0dXJuXS55b3UuaWQgKyAnJnR1cm49JyArIHR1cm47XG4gICAgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKHtcbiAgICAgICAgcGF0aDogbmV3VXJsLFxuICAgIH0sICcnLCBuZXdVcmwpO1xufSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2hlYXAnKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS44LjBcbihmdW5jdGlvbigpIHtcbiAgdmFyIEhlYXAsIGRlZmF1bHRDbXAsIGZsb29yLCBoZWFwaWZ5LCBoZWFwcG9wLCBoZWFwcHVzaCwgaGVhcHB1c2hwb3AsIGhlYXByZXBsYWNlLCBpbnNvcnQsIG1pbiwgbmxhcmdlc3QsIG5zbWFsbGVzdCwgdXBkYXRlSXRlbSwgX3NpZnRkb3duLCBfc2lmdHVwO1xuXG4gIGZsb29yID0gTWF0aC5mbG9vciwgbWluID0gTWF0aC5taW47XG5cblxuICAvKlxuICBEZWZhdWx0IGNvbXBhcmlzb24gZnVuY3Rpb24gdG8gYmUgdXNlZFxuICAgKi9cblxuICBkZWZhdWx0Q21wID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIGlmICh4IDwgeSkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBpZiAoeCA+IHkpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfTtcblxuXG4gIC8qXG4gIEluc2VydCBpdGVtIHggaW4gbGlzdCBhLCBhbmQga2VlcCBpdCBzb3J0ZWQgYXNzdW1pbmcgYSBpcyBzb3J0ZWQuXG4gIFxuICBJZiB4IGlzIGFscmVhZHkgaW4gYSwgaW5zZXJ0IGl0IHRvIHRoZSByaWdodCBvZiB0aGUgcmlnaHRtb3N0IHguXG4gIFxuICBPcHRpb25hbCBhcmdzIGxvIChkZWZhdWx0IDApIGFuZCBoaSAoZGVmYXVsdCBhLmxlbmd0aCkgYm91bmQgdGhlIHNsaWNlXG4gIG9mIGEgdG8gYmUgc2VhcmNoZWQuXG4gICAqL1xuXG4gIGluc29ydCA9IGZ1bmN0aW9uKGEsIHgsIGxvLCBoaSwgY21wKSB7XG4gICAgdmFyIG1pZDtcbiAgICBpZiAobG8gPT0gbnVsbCkge1xuICAgICAgbG8gPSAwO1xuICAgIH1cbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIGlmIChsbyA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbG8gbXVzdCBiZSBub24tbmVnYXRpdmUnKTtcbiAgICB9XG4gICAgaWYgKGhpID09IG51bGwpIHtcbiAgICAgIGhpID0gYS5sZW5ndGg7XG4gICAgfVxuICAgIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgICBtaWQgPSBmbG9vcigobG8gKyBoaSkgLyAyKTtcbiAgICAgIGlmIChjbXAoeCwgYVttaWRdKSA8IDApIHtcbiAgICAgICAgaGkgPSBtaWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsbyA9IG1pZCArIDE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoW10uc3BsaWNlLmFwcGx5KGEsIFtsbywgbG8gLSBsb10uY29uY2F0KHgpKSwgeCk7XG4gIH07XG5cblxuICAvKlxuICBQdXNoIGl0ZW0gb250byBoZWFwLCBtYWludGFpbmluZyB0aGUgaGVhcCBpbnZhcmlhbnQuXG4gICAqL1xuXG4gIGhlYXBwdXNoID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGNtcCkge1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgYXJyYXkucHVzaChpdGVtKTtcbiAgICByZXR1cm4gX3NpZnRkb3duKGFycmF5LCAwLCBhcnJheS5sZW5ndGggLSAxLCBjbXApO1xuICB9O1xuXG5cbiAgLypcbiAgUG9wIHRoZSBzbWFsbGVzdCBpdGVtIG9mZiB0aGUgaGVhcCwgbWFpbnRhaW5pbmcgdGhlIGhlYXAgaW52YXJpYW50LlxuICAgKi9cblxuICBoZWFwcG9wID0gZnVuY3Rpb24oYXJyYXksIGNtcCkge1xuICAgIHZhciBsYXN0ZWx0LCByZXR1cm5pdGVtO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgbGFzdGVsdCA9IGFycmF5LnBvcCgpO1xuICAgIGlmIChhcnJheS5sZW5ndGgpIHtcbiAgICAgIHJldHVybml0ZW0gPSBhcnJheVswXTtcbiAgICAgIGFycmF5WzBdID0gbGFzdGVsdDtcbiAgICAgIF9zaWZ0dXAoYXJyYXksIDAsIGNtcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybml0ZW0gPSBsYXN0ZWx0O1xuICAgIH1cbiAgICByZXR1cm4gcmV0dXJuaXRlbTtcbiAgfTtcblxuXG4gIC8qXG4gIFBvcCBhbmQgcmV0dXJuIHRoZSBjdXJyZW50IHNtYWxsZXN0IHZhbHVlLCBhbmQgYWRkIHRoZSBuZXcgaXRlbS5cbiAgXG4gIFRoaXMgaXMgbW9yZSBlZmZpY2llbnQgdGhhbiBoZWFwcG9wKCkgZm9sbG93ZWQgYnkgaGVhcHB1c2goKSwgYW5kIGNhbiBiZVxuICBtb3JlIGFwcHJvcHJpYXRlIHdoZW4gdXNpbmcgYSBmaXhlZCBzaXplIGhlYXAuIE5vdGUgdGhhdCB0aGUgdmFsdWVcbiAgcmV0dXJuZWQgbWF5IGJlIGxhcmdlciB0aGFuIGl0ZW0hIFRoYXQgY29uc3RyYWlucyByZWFzb25hYmxlIHVzZSBvZlxuICB0aGlzIHJvdXRpbmUgdW5sZXNzIHdyaXR0ZW4gYXMgcGFydCBvZiBhIGNvbmRpdGlvbmFsIHJlcGxhY2VtZW50OlxuICAgICAgaWYgaXRlbSA+IGFycmF5WzBdXG4gICAgICAgIGl0ZW0gPSBoZWFwcmVwbGFjZShhcnJheSwgaXRlbSlcbiAgICovXG5cbiAgaGVhcHJlcGxhY2UgPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgY21wKSB7XG4gICAgdmFyIHJldHVybml0ZW07XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICByZXR1cm5pdGVtID0gYXJyYXlbMF07XG4gICAgYXJyYXlbMF0gPSBpdGVtO1xuICAgIF9zaWZ0dXAoYXJyYXksIDAsIGNtcCk7XG4gICAgcmV0dXJuIHJldHVybml0ZW07XG4gIH07XG5cblxuICAvKlxuICBGYXN0IHZlcnNpb24gb2YgYSBoZWFwcHVzaCBmb2xsb3dlZCBieSBhIGhlYXBwb3AuXG4gICAqL1xuXG4gIGhlYXBwdXNocG9wID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGNtcCkge1xuICAgIHZhciBfcmVmO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgaWYgKGFycmF5Lmxlbmd0aCAmJiBjbXAoYXJyYXlbMF0sIGl0ZW0pIDwgMCkge1xuICAgICAgX3JlZiA9IFthcnJheVswXSwgaXRlbV0sIGl0ZW0gPSBfcmVmWzBdLCBhcnJheVswXSA9IF9yZWZbMV07XG4gICAgICBfc2lmdHVwKGFycmF5LCAwLCBjbXApO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbTtcbiAgfTtcblxuXG4gIC8qXG4gIFRyYW5zZm9ybSBsaXN0IGludG8gYSBoZWFwLCBpbi1wbGFjZSwgaW4gTyhhcnJheS5sZW5ndGgpIHRpbWUuXG4gICAqL1xuXG4gIGhlYXBpZnkgPSBmdW5jdGlvbihhcnJheSwgY21wKSB7XG4gICAgdmFyIGksIF9pLCBfaiwgX2xlbiwgX3JlZiwgX3JlZjEsIF9yZXN1bHRzLCBfcmVzdWx0czE7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBfcmVmMSA9IChmdW5jdGlvbigpIHtcbiAgICAgIF9yZXN1bHRzMSA9IFtdO1xuICAgICAgZm9yICh2YXIgX2ogPSAwLCBfcmVmID0gZmxvb3IoYXJyYXkubGVuZ3RoIC8gMik7IDAgPD0gX3JlZiA/IF9qIDwgX3JlZiA6IF9qID4gX3JlZjsgMCA8PSBfcmVmID8gX2orKyA6IF9qLS0peyBfcmVzdWx0czEucHVzaChfaik7IH1cbiAgICAgIHJldHVybiBfcmVzdWx0czE7XG4gICAgfSkuYXBwbHkodGhpcykucmV2ZXJzZSgpO1xuICAgIF9yZXN1bHRzID0gW107XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgaSA9IF9yZWYxW19pXTtcbiAgICAgIF9yZXN1bHRzLnB1c2goX3NpZnR1cChhcnJheSwgaSwgY21wKSk7XG4gICAgfVxuICAgIHJldHVybiBfcmVzdWx0cztcbiAgfTtcblxuXG4gIC8qXG4gIFVwZGF0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGdpdmVuIGl0ZW0gaW4gdGhlIGhlYXAuXG4gIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIGNhbGxlZCBldmVyeSB0aW1lIHRoZSBpdGVtIGlzIGJlaW5nIG1vZGlmaWVkLlxuICAgKi9cblxuICB1cGRhdGVJdGVtID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGNtcCkge1xuICAgIHZhciBwb3M7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBwb3MgPSBhcnJheS5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChwb3MgPT09IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIF9zaWZ0ZG93bihhcnJheSwgMCwgcG9zLCBjbXApO1xuICAgIHJldHVybiBfc2lmdHVwKGFycmF5LCBwb3MsIGNtcCk7XG4gIH07XG5cblxuICAvKlxuICBGaW5kIHRoZSBuIGxhcmdlc3QgZWxlbWVudHMgaW4gYSBkYXRhc2V0LlxuICAgKi9cblxuICBubGFyZ2VzdCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBjbXApIHtcbiAgICB2YXIgZWxlbSwgcmVzdWx0LCBfaSwgX2xlbiwgX3JlZjtcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIHJlc3VsdCA9IGFycmF5LnNsaWNlKDAsIG4pO1xuICAgIGlmICghcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaGVhcGlmeShyZXN1bHQsIGNtcCk7XG4gICAgX3JlZiA9IGFycmF5LnNsaWNlKG4pO1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgZWxlbSA9IF9yZWZbX2ldO1xuICAgICAgaGVhcHB1c2hwb3AocmVzdWx0LCBlbGVtLCBjbXApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LnNvcnQoY21wKS5yZXZlcnNlKCk7XG4gIH07XG5cblxuICAvKlxuICBGaW5kIHRoZSBuIHNtYWxsZXN0IGVsZW1lbnRzIGluIGEgZGF0YXNldC5cbiAgICovXG5cbiAgbnNtYWxsZXN0ID0gZnVuY3Rpb24oYXJyYXksIG4sIGNtcCkge1xuICAgIHZhciBlbGVtLCBpLCBsb3MsIHJlc3VsdCwgX2ksIF9qLCBfbGVuLCBfcmVmLCBfcmVmMSwgX3Jlc3VsdHM7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBpZiAobiAqIDEwIDw9IGFycmF5Lmxlbmd0aCkge1xuICAgICAgcmVzdWx0ID0gYXJyYXkuc2xpY2UoMCwgbikuc29ydChjbXApO1xuICAgICAgaWYgKCFyZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBsb3MgPSByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdO1xuICAgICAgX3JlZiA9IGFycmF5LnNsaWNlKG4pO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGVsZW0gPSBfcmVmW19pXTtcbiAgICAgICAgaWYgKGNtcChlbGVtLCBsb3MpIDwgMCkge1xuICAgICAgICAgIGluc29ydChyZXN1bHQsIGVsZW0sIDAsIG51bGwsIGNtcCk7XG4gICAgICAgICAgcmVzdWx0LnBvcCgpO1xuICAgICAgICAgIGxvcyA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGhlYXBpZnkoYXJyYXksIGNtcCk7XG4gICAgX3Jlc3VsdHMgPSBbXTtcbiAgICBmb3IgKGkgPSBfaiA9IDAsIF9yZWYxID0gbWluKG4sIGFycmF5Lmxlbmd0aCk7IDAgPD0gX3JlZjEgPyBfaiA8IF9yZWYxIDogX2ogPiBfcmVmMTsgaSA9IDAgPD0gX3JlZjEgPyArK19qIDogLS1faikge1xuICAgICAgX3Jlc3VsdHMucHVzaChoZWFwcG9wKGFycmF5LCBjbXApKTtcbiAgICB9XG4gICAgcmV0dXJuIF9yZXN1bHRzO1xuICB9O1xuXG4gIF9zaWZ0ZG93biA9IGZ1bmN0aW9uKGFycmF5LCBzdGFydHBvcywgcG9zLCBjbXApIHtcbiAgICB2YXIgbmV3aXRlbSwgcGFyZW50LCBwYXJlbnRwb3M7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBuZXdpdGVtID0gYXJyYXlbcG9zXTtcbiAgICB3aGlsZSAocG9zID4gc3RhcnRwb3MpIHtcbiAgICAgIHBhcmVudHBvcyA9IChwb3MgLSAxKSA+PiAxO1xuICAgICAgcGFyZW50ID0gYXJyYXlbcGFyZW50cG9zXTtcbiAgICAgIGlmIChjbXAobmV3aXRlbSwgcGFyZW50KSA8IDApIHtcbiAgICAgICAgYXJyYXlbcG9zXSA9IHBhcmVudDtcbiAgICAgICAgcG9zID0gcGFyZW50cG9zO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXlbcG9zXSA9IG5ld2l0ZW07XG4gIH07XG5cbiAgX3NpZnR1cCA9IGZ1bmN0aW9uKGFycmF5LCBwb3MsIGNtcCkge1xuICAgIHZhciBjaGlsZHBvcywgZW5kcG9zLCBuZXdpdGVtLCByaWdodHBvcywgc3RhcnRwb3M7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBlbmRwb3MgPSBhcnJheS5sZW5ndGg7XG4gICAgc3RhcnRwb3MgPSBwb3M7XG4gICAgbmV3aXRlbSA9IGFycmF5W3Bvc107XG4gICAgY2hpbGRwb3MgPSAyICogcG9zICsgMTtcbiAgICB3aGlsZSAoY2hpbGRwb3MgPCBlbmRwb3MpIHtcbiAgICAgIHJpZ2h0cG9zID0gY2hpbGRwb3MgKyAxO1xuICAgICAgaWYgKHJpZ2h0cG9zIDwgZW5kcG9zICYmICEoY21wKGFycmF5W2NoaWxkcG9zXSwgYXJyYXlbcmlnaHRwb3NdKSA8IDApKSB7XG4gICAgICAgIGNoaWxkcG9zID0gcmlnaHRwb3M7XG4gICAgICB9XG4gICAgICBhcnJheVtwb3NdID0gYXJyYXlbY2hpbGRwb3NdO1xuICAgICAgcG9zID0gY2hpbGRwb3M7XG4gICAgICBjaGlsZHBvcyA9IDIgKiBwb3MgKyAxO1xuICAgIH1cbiAgICBhcnJheVtwb3NdID0gbmV3aXRlbTtcbiAgICByZXR1cm4gX3NpZnRkb3duKGFycmF5LCBzdGFydHBvcywgcG9zLCBjbXApO1xuICB9O1xuXG4gIEhlYXAgPSAoZnVuY3Rpb24oKSB7XG4gICAgSGVhcC5wdXNoID0gaGVhcHB1c2g7XG5cbiAgICBIZWFwLnBvcCA9IGhlYXBwb3A7XG5cbiAgICBIZWFwLnJlcGxhY2UgPSBoZWFwcmVwbGFjZTtcblxuICAgIEhlYXAucHVzaHBvcCA9IGhlYXBwdXNocG9wO1xuXG4gICAgSGVhcC5oZWFwaWZ5ID0gaGVhcGlmeTtcblxuICAgIEhlYXAudXBkYXRlSXRlbSA9IHVwZGF0ZUl0ZW07XG5cbiAgICBIZWFwLm5sYXJnZXN0ID0gbmxhcmdlc3Q7XG5cbiAgICBIZWFwLm5zbWFsbGVzdCA9IG5zbWFsbGVzdDtcblxuICAgIGZ1bmN0aW9uIEhlYXAoY21wKSB7XG4gICAgICB0aGlzLmNtcCA9IGNtcCAhPSBudWxsID8gY21wIDogZGVmYXVsdENtcDtcbiAgICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgICB9XG5cbiAgICBIZWFwLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIGhlYXBwdXNoKHRoaXMubm9kZXMsIHgsIHRoaXMuY21wKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaGVhcHBvcCh0aGlzLm5vZGVzLCB0aGlzLmNtcCk7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzWzBdO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzLmluZGV4T2YoeCkgIT09IC0xO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIGhlYXByZXBsYWNlKHRoaXMubm9kZXMsIHgsIHRoaXMuY21wKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUucHVzaHBvcCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBoZWFwcHVzaHBvcCh0aGlzLm5vZGVzLCB4LCB0aGlzLmNtcCk7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLmhlYXBpZnkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBoZWFwaWZ5KHRoaXMubm9kZXMsIHRoaXMuY21wKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUudXBkYXRlSXRlbSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB1cGRhdGVJdGVtKHRoaXMubm9kZXMsIHgsIHRoaXMuY21wKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzID0gW107XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2Rlcy5sZW5ndGggPT09IDA7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzLmxlbmd0aDtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBoZWFwO1xuICAgICAgaGVhcCA9IG5ldyBIZWFwKCk7XG4gICAgICBoZWFwLm5vZGVzID0gdGhpcy5ub2Rlcy5zbGljZSgwKTtcbiAgICAgIHJldHVybiBoZWFwO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2Rlcy5zbGljZSgwKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUuaW5zZXJ0ID0gSGVhcC5wcm90b3R5cGUucHVzaDtcblxuICAgIEhlYXAucHJvdG90eXBlLnRvcCA9IEhlYXAucHJvdG90eXBlLnBlZWs7XG5cbiAgICBIZWFwLnByb3RvdHlwZS5mcm9udCA9IEhlYXAucHJvdG90eXBlLnBlZWs7XG5cbiAgICBIZWFwLnByb3RvdHlwZS5oYXMgPSBIZWFwLnByb3RvdHlwZS5jb250YWlucztcblxuICAgIEhlYXAucHJvdG90eXBlLmNvcHkgPSBIZWFwLnByb3RvdHlwZS5jbG9uZTtcblxuICAgIHJldHVybiBIZWFwO1xuXG4gIH0pKCk7XG5cbiAgaWYgKHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlICE9PSBudWxsID8gbW9kdWxlLmV4cG9ydHMgOiB2b2lkIDApIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEhlYXA7XG4gIH0gZWxzZSB7XG4gICAgd2luZG93LkhlYXAgPSBIZWFwO1xuICB9XG5cbn0pLmNhbGwodGhpcyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vc3JjL1BhdGhGaW5kaW5nJyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAnSGVhcCcgICAgICAgICAgICAgICAgICAgICAgOiByZXF1aXJlKCdoZWFwJyksXG4gICAgJ05vZGUnICAgICAgICAgICAgICAgICAgICAgIDogcmVxdWlyZSgnLi9jb3JlL05vZGUnKSxcbiAgICAnR3JpZCcgICAgICAgICAgICAgICAgICAgICAgOiByZXF1aXJlKCcuL2NvcmUvR3JpZCcpLFxuICAgICdVdGlsJyAgICAgICAgICAgICAgICAgICAgICA6IHJlcXVpcmUoJy4vY29yZS9VdGlsJyksXG5cdCdEaWFnb25hbE1vdmVtZW50JyAgICAgICAgICA6IHJlcXVpcmUoJy4vY29yZS9EaWFnb25hbE1vdmVtZW50JyksXG4gICAgJ0hldXJpc3RpYycgICAgICAgICAgICAgICAgIDogcmVxdWlyZSgnLi9jb3JlL0hldXJpc3RpYycpLFxuICAgICdBU3RhckZpbmRlcicgICAgICAgICAgICAgICA6IHJlcXVpcmUoJy4vZmluZGVycy9BU3RhckZpbmRlcicpLFxuICAgICdCZXN0Rmlyc3RGaW5kZXInICAgICAgICAgICA6IHJlcXVpcmUoJy4vZmluZGVycy9CZXN0Rmlyc3RGaW5kZXInKSxcbiAgICAnQnJlYWR0aEZpcnN0RmluZGVyJyAgICAgICAgOiByZXF1aXJlKCcuL2ZpbmRlcnMvQnJlYWR0aEZpcnN0RmluZGVyJyksXG4gICAgJ0RpamtzdHJhRmluZGVyJyAgICAgICAgICAgIDogcmVxdWlyZSgnLi9maW5kZXJzL0RpamtzdHJhRmluZGVyJyksXG4gICAgJ0JpQVN0YXJGaW5kZXInICAgICAgICAgICAgIDogcmVxdWlyZSgnLi9maW5kZXJzL0JpQVN0YXJGaW5kZXInKSxcbiAgICAnQmlCZXN0Rmlyc3RGaW5kZXInICAgICAgICAgOiByZXF1aXJlKCcuL2ZpbmRlcnMvQmlCZXN0Rmlyc3RGaW5kZXInKSxcbiAgICAnQmlCcmVhZHRoRmlyc3RGaW5kZXInICAgICAgOiByZXF1aXJlKCcuL2ZpbmRlcnMvQmlCcmVhZHRoRmlyc3RGaW5kZXInKSxcbiAgICAnQmlEaWprc3RyYUZpbmRlcicgICAgICAgICAgOiByZXF1aXJlKCcuL2ZpbmRlcnMvQmlEaWprc3RyYUZpbmRlcicpLFxuICAgICdJREFTdGFyRmluZGVyJyAgICAgICAgICAgICA6IHJlcXVpcmUoJy4vZmluZGVycy9JREFTdGFyRmluZGVyJyksXG4gICAgJ0p1bXBQb2ludEZpbmRlcicgICAgICAgICAgIDogcmVxdWlyZSgnLi9maW5kZXJzL0p1bXBQb2ludEZpbmRlcicpLFxufTtcbiIsInZhciBEaWFnb25hbE1vdmVtZW50ID0ge1xuICAgIEFsd2F5czogMSxcbiAgICBOZXZlcjogMixcbiAgICBJZkF0TW9zdE9uZU9ic3RhY2xlOiAzLFxuICAgIE9ubHlXaGVuTm9PYnN0YWNsZXM6IDRcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGlhZ29uYWxNb3ZlbWVudDsiLCJ2YXIgTm9kZSA9IHJlcXVpcmUoJy4vTm9kZScpO1xudmFyIERpYWdvbmFsTW92ZW1lbnQgPSByZXF1aXJlKCcuL0RpYWdvbmFsTW92ZW1lbnQnKTtcblxuLyoqXG4gKiBUaGUgR3JpZCBjbGFzcywgd2hpY2ggc2VydmVzIGFzIHRoZSBlbmNhcHN1bGF0aW9uIG9mIHRoZSBsYXlvdXQgb2YgdGhlIG5vZGVzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge251bWJlcnxBcnJheS48QXJyYXkuPChudW1iZXJ8Ym9vbGVhbik+Pn0gd2lkdGhfb3JfbWF0cml4IE51bWJlciBvZiBjb2x1bW5zIG9mIHRoZSBncmlkLCBvciBtYXRyaXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgTnVtYmVyIG9mIHJvd3Mgb2YgdGhlIGdyaWQuXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheS48KG51bWJlcnxib29sZWFuKT4+fSBbbWF0cml4XSAtIEEgMC0xIG1hdHJpeFxuICogICAgIHJlcHJlc2VudGluZyB0aGUgd2Fsa2FibGUgc3RhdHVzIG9mIHRoZSBub2RlcygwIG9yIGZhbHNlIGZvciB3YWxrYWJsZSkuXG4gKiAgICAgSWYgdGhlIG1hdHJpeCBpcyBub3Qgc3VwcGxpZWQsIGFsbCB0aGUgbm9kZXMgd2lsbCBiZSB3YWxrYWJsZS4gXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheS48KG51bWJlcik+Pn0gW2Nvc3RzXSAtIEEgbWF0cml4XG4gKiAgICAgcmVwcmVzZW50aW5nIHRoZSBjb3N0IG9mIHdhbGtpbmcgdGhlIG5vZGUuXG4gKiAgICAgSWYgdGhlIGNvc3RzIGlzIG5vdCBzdXBwbGllZCwgYWxsIHRoZSBub2RlcyB3aWxsIGNvc3QgMC4gICovXG5mdW5jdGlvbiBHcmlkKHdpZHRoX29yX21hdHJpeCwgaGVpZ2h0LCBtYXRyaXgsIGNvc3RzKSB7XG4gICAgdmFyIHdpZHRoO1xuXG4gICAgaWYgKHR5cGVvZiB3aWR0aF9vcl9tYXRyaXggIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHdpZHRoID0gd2lkdGhfb3JfbWF0cml4O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGhlaWdodCA9IHdpZHRoX29yX21hdHJpeC5sZW5ndGg7XG4gICAgICAgIHdpZHRoID0gd2lkdGhfb3JfbWF0cml4WzBdLmxlbmd0aDtcbiAgICAgICAgbWF0cml4ID0gd2lkdGhfb3JfbWF0cml4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgY29sdW1ucyBvZiB0aGUgZ3JpZC5cbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKi9cbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiByb3dzIG9mIHRoZSBncmlkLlxuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqL1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgLyoqXG4gICAgICogQSAyRCBhcnJheSBvZiBub2Rlcy5cbiAgICAgKi9cbiAgICB0aGlzLm5vZGVzID0gdGhpcy5fYnVpbGROb2Rlcyh3aWR0aCwgaGVpZ2h0LCBtYXRyaXgsIGNvc3RzKTtcbn1cblxuLyoqXG4gKiBCdWlsZCBhbmQgcmV0dXJuIHRoZSBub2Rlcy5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGhcbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcbiAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxudW1iZXJ8Ym9vbGVhbj4+fSBbbWF0cml4XSAtIEEgMC0xIG1hdHJpeCByZXByZXNlbnRpbmdcbiAqICAgICB0aGUgd2Fsa2FibGUgc3RhdHVzIG9mIHRoZSBub2Rlcy5cbiAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxudW1iZXI+Pn0gW2Nvc3RzXSAtIEEgbWF0cml4IHJlcHJlc2VudGluZ1xuICogICAgIHRoZSBjb3N0cyB0byB3YWxrIHRoZSBub2Rlcy5cbiAqIEBzZWUgR3JpZFxuICovXG5HcmlkLnByb3RvdHlwZS5fYnVpbGROb2RlcyA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIG1hdHJpeCwgY29zdHMpIHtcbiAgICB2YXIgaSwgaixcbiAgICAgICAgbm9kZXMgPSBuZXcgQXJyYXkoaGVpZ2h0KSxcbiAgICAgICAgcm93O1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGhlaWdodDsgKytpKSB7XG4gICAgICAgIG5vZGVzW2ldID0gbmV3IEFycmF5KHdpZHRoKTtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IHdpZHRoOyArK2opIHtcbiAgICAgICAgICAgIG5vZGVzW2ldW2pdID0gbmV3IE5vZGUoaiwgaSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWF0cml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH1cblxuICAgIGlmIChtYXRyaXgubGVuZ3RoICE9PSBoZWlnaHQgfHwgbWF0cml4WzBdLmxlbmd0aCAhPT0gd2lkdGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYXRyaXggc2l6ZSBkb2VzIG5vdCBmaXQnKTtcbiAgICB9XG5cbiAgICBpZiAoY29zdHMgIT09IHVuZGVmaW5lZCAmJiAoY29zdHMubGVuZ3RoICE9PSBoZWlnaHQgfHwgY29zdHNbMF0ubGVuZ3RoICE9PSB3aWR0aCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3N0cyBzaXplIGRvZXMgbm90IGZpdCcpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBoZWlnaHQ7ICsraSkge1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgd2lkdGg7ICsraikge1xuICAgICAgICAgICAgaWYgKG1hdHJpeFtpXVtqXSkge1xuICAgICAgICAgICAgICAgIC8vIDAsIGZhbHNlLCBudWxsIHdpbGwgYmUgd2Fsa2FibGVcbiAgICAgICAgICAgICAgICAvLyB3aGlsZSBvdGhlcnMgd2lsbCBiZSB1bi13YWxrYWJsZVxuICAgICAgICAgICAgICAgIG5vZGVzW2ldW2pdLndhbGthYmxlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29zdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG5vZGVzW2ldW2pdLmNvc3Q9Y29zdHNbaV1bal07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZXM7XG59O1xuXG5cbkdyaWQucHJvdG90eXBlLmdldE5vZGVBdCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy5ub2Rlc1t5XVt4XTtcbn07XG5cblxuLyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgbm9kZSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24gaXMgd2Fsa2FibGUuXG4gKiAoQWxzbyByZXR1cm5zIGZhbHNlIGlmIHRoZSBwb3NpdGlvbiBpcyBvdXRzaWRlIHRoZSBncmlkLilcbiAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgbm9kZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgbm9kZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IC0gVGhlIHdhbGthYmlsaXR5IG9mIHRoZSBub2RlLlxuICovXG5HcmlkLnByb3RvdHlwZS5pc1dhbGthYmxlQXQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNJbnNpZGUoeCwgeSkgJiYgdGhpcy5ub2Rlc1t5XVt4XS53YWxrYWJsZTtcbn07XG5cblxuLyoqXG4gKiBHZXQgY29zdCB0byB3YWxrIHRoZSBub2RlIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAqIChBbHNvIHJldHVybnMgZmFsc2UgaWYgdGhlIHBvc2l0aW9uIGlzIG91dHNpZGUgdGhlIGdyaWQuKVxuICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBub2RlLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgeSBjb29yZGluYXRlIG9mIHRoZSBub2RlLlxuICogQHJldHVybiB7bnVtYmVyfSAtIENvc3QgdG8gd2FsayBub2RlLlxuICovXG5HcmlkLnByb3RvdHlwZS5nZXRDb3N0QXQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgaWYgKCF0aGlzLmlzSW5zaWRlKHgsIHkpKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMubm9kZXNbeV1beF0uY29zdDtcbn07XG5cblxuLyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgcG9zaXRpb24gaXMgaW5zaWRlIHRoZSBncmlkLlxuICogWFhYOiBgZ3JpZC5pc0luc2lkZSh4LCB5KWAgaXMgd2llcmQgdG8gcmVhZC5cbiAqIEl0IHNob3VsZCBiZSBgKHgsIHkpIGlzIGluc2lkZSBncmlkYCwgYnV0IEkgZmFpbGVkIHRvIGZpbmQgYSBiZXR0ZXJcbiAqIG5hbWUgZm9yIHRoaXMgbWV0aG9kLlxuICogQHBhcmFtIHtudW1iZXJ9IHhcbiAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5HcmlkLnByb3RvdHlwZS5pc0luc2lkZSA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICByZXR1cm4gKHggPj0gMCAmJiB4IDwgdGhpcy53aWR0aCkgJiYgKHkgPj0gMCAmJiB5IDwgdGhpcy5oZWlnaHQpO1xufTtcblxuXG4vKipcbiAqIFNldCB3aGV0aGVyIHRoZSBub2RlIG9uIHRoZSBnaXZlbiBwb3NpdGlvbiBpcyB3YWxrYWJsZS5cbiAqIE5PVEU6IHRocm93cyBleGNlcHRpb24gaWYgdGhlIGNvb3JkaW5hdGUgaXMgbm90IGluc2lkZSB0aGUgZ3JpZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgbm9kZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgbm9kZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gd2Fsa2FibGUgLSBXaGV0aGVyIHRoZSBwb3NpdGlvbiBpcyB3YWxrYWJsZS5cbiAqL1xuR3JpZC5wcm90b3R5cGUuc2V0V2Fsa2FibGVBdCA9IGZ1bmN0aW9uKHgsIHksIHdhbGthYmxlKSB7XG4gICAgdGhpcy5ub2Rlc1t5XVt4XS53YWxrYWJsZSA9IHdhbGthYmxlO1xufTtcblxuXG4vKipcbiAqIFNldCBjb3N0IG9mIHRoZSBub2RlIG9uIHRoZSBnaXZlbiBwb3NpdGlvblxuICogTk9URTogdGhyb3dzIGV4Y2VwdGlvbiBpZiB0aGUgY29vcmRpbmF0ZSBpcyBub3QgaW5zaWRlIHRoZSBncmlkLlxuICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBub2RlLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgeSBjb29yZGluYXRlIG9mIHRoZSBub2RlLlxuICogQHBhcmFtIHtudW1iZXJ9IGNvc3QgLSBDb3N0IHRvIHdhbGsgdGhlIG5vZGUuXG4gKi9cbkdyaWQucHJvdG90eXBlLnNldENvc3RBdCA9IGZ1bmN0aW9uKHgsIHksIGNvc3QpIHtcbiAgICB0aGlzLm5vZGVzW3ldW3hdLmNvc3QgPSBjb3N0O1xufTtcblxuXG4vKipcbiAqIEdldCB0aGUgbmVpZ2hib3JzIG9mIHRoZSBnaXZlbiBub2RlLlxuICpcbiAqICAgICBvZmZzZXRzICAgICAgZGlhZ29uYWxPZmZzZXRzOlxuICogICstLS0rLS0tKy0tLSsgICAgKy0tLSstLS0rLS0tK1xuICogIHwgICB8IDAgfCAgIHwgICAgfCAwIHwgICB8IDEgfFxuICogICstLS0rLS0tKy0tLSsgICAgKy0tLSstLS0rLS0tK1xuICogIHwgMyB8ICAgfCAxIHwgICAgfCAgIHwgICB8ICAgfFxuICogICstLS0rLS0tKy0tLSsgICAgKy0tLSstLS0rLS0tK1xuICogIHwgICB8IDIgfCAgIHwgICAgfCAzIHwgICB8IDIgfFxuICogICstLS0rLS0tKy0tLSsgICAgKy0tLSstLS0rLS0tK1xuICpcbiAqICBXaGVuIGFsbG93RGlhZ29uYWwgaXMgdHJ1ZSwgaWYgb2Zmc2V0c1tpXSBpcyB2YWxpZCwgdGhlblxuICogIGRpYWdvbmFsT2Zmc2V0c1tpXSBhbmRcbiAqICBkaWFnb25hbE9mZnNldHNbKGkgKyAxKSAlIDRdIGlzIHZhbGlkLlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge0RpYWdvbmFsTW92ZW1lbnR9IGRpYWdvbmFsTW92ZW1lbnRcbiAqL1xuR3JpZC5wcm90b3R5cGUuZ2V0TmVpZ2hib3JzID0gZnVuY3Rpb24obm9kZSwgZGlhZ29uYWxNb3ZlbWVudCkge1xuICAgIHZhciB4ID0gbm9kZS54LFxuICAgICAgICB5ID0gbm9kZS55LFxuICAgICAgICBuZWlnaGJvcnMgPSBbXSxcbiAgICAgICAgczAgPSBmYWxzZSwgZDAgPSBmYWxzZSxcbiAgICAgICAgczEgPSBmYWxzZSwgZDEgPSBmYWxzZSxcbiAgICAgICAgczIgPSBmYWxzZSwgZDIgPSBmYWxzZSxcbiAgICAgICAgczMgPSBmYWxzZSwgZDMgPSBmYWxzZSxcbiAgICAgICAgbm9kZXMgPSB0aGlzLm5vZGVzO1xuXG4gICAgLy8g4oaRXG4gICAgaWYgKHRoaXMuaXNXYWxrYWJsZUF0KHgsIHkgLSAxKSkge1xuICAgICAgICBuZWlnaGJvcnMucHVzaChub2Rlc1t5IC0gMV1beF0pO1xuICAgICAgICBzMCA9IHRydWU7XG4gICAgfVxuICAgIC8vIOKGklxuICAgIGlmICh0aGlzLmlzV2Fsa2FibGVBdCh4ICsgMSwgeSkpIHtcbiAgICAgICAgbmVpZ2hib3JzLnB1c2gobm9kZXNbeV1beCArIDFdKTtcbiAgICAgICAgczEgPSB0cnVlO1xuICAgIH1cbiAgICAvLyDihpNcbiAgICBpZiAodGhpcy5pc1dhbGthYmxlQXQoeCwgeSArIDEpKSB7XG4gICAgICAgIG5laWdoYm9ycy5wdXNoKG5vZGVzW3kgKyAxXVt4XSk7XG4gICAgICAgIHMyID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8g4oaQXG4gICAgaWYgKHRoaXMuaXNXYWxrYWJsZUF0KHggLSAxLCB5KSkge1xuICAgICAgICBuZWlnaGJvcnMucHVzaChub2Rlc1t5XVt4IC0gMV0pO1xuICAgICAgICBzMyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGRpYWdvbmFsTW92ZW1lbnQgPT09IERpYWdvbmFsTW92ZW1lbnQuTmV2ZXIpIHtcbiAgICAgICAgcmV0dXJuIG5laWdoYm9ycztcbiAgICB9XG5cbiAgICBpZiAoZGlhZ29uYWxNb3ZlbWVudCA9PT0gRGlhZ29uYWxNb3ZlbWVudC5Pbmx5V2hlbk5vT2JzdGFjbGVzKSB7XG4gICAgICAgIGQwID0gczMgJiYgczA7XG4gICAgICAgIGQxID0gczAgJiYgczE7XG4gICAgICAgIGQyID0gczEgJiYgczI7XG4gICAgICAgIGQzID0gczIgJiYgczM7XG4gICAgfSBlbHNlIGlmIChkaWFnb25hbE1vdmVtZW50ID09PSBEaWFnb25hbE1vdmVtZW50LklmQXRNb3N0T25lT2JzdGFjbGUpIHtcbiAgICAgICAgZDAgPSBzMyB8fCBzMDtcbiAgICAgICAgZDEgPSBzMCB8fCBzMTtcbiAgICAgICAgZDIgPSBzMSB8fCBzMjtcbiAgICAgICAgZDMgPSBzMiB8fCBzMztcbiAgICB9IGVsc2UgaWYgKGRpYWdvbmFsTW92ZW1lbnQgPT09IERpYWdvbmFsTW92ZW1lbnQuQWx3YXlzKSB7XG4gICAgICAgIGQwID0gdHJ1ZTtcbiAgICAgICAgZDEgPSB0cnVlO1xuICAgICAgICBkMiA9IHRydWU7XG4gICAgICAgIGQzID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29ycmVjdCB2YWx1ZSBvZiBkaWFnb25hbE1vdmVtZW50Jyk7XG4gICAgfVxuXG4gICAgLy8g4oaWXG4gICAgaWYgKGQwICYmIHRoaXMuaXNXYWxrYWJsZUF0KHggLSAxLCB5IC0gMSkpIHtcbiAgICAgICAgbmVpZ2hib3JzLnB1c2gobm9kZXNbeSAtIDFdW3ggLSAxXSk7XG4gICAgfVxuICAgIC8vIOKGl1xuICAgIGlmIChkMSAmJiB0aGlzLmlzV2Fsa2FibGVBdCh4ICsgMSwgeSAtIDEpKSB7XG4gICAgICAgIG5laWdoYm9ycy5wdXNoKG5vZGVzW3kgLSAxXVt4ICsgMV0pO1xuICAgIH1cbiAgICAvLyDihphcbiAgICBpZiAoZDIgJiYgdGhpcy5pc1dhbGthYmxlQXQoeCArIDEsIHkgKyAxKSkge1xuICAgICAgICBuZWlnaGJvcnMucHVzaChub2Rlc1t5ICsgMV1beCArIDFdKTtcbiAgICB9XG4gICAgLy8g4oaZXG4gICAgaWYgKGQzICYmIHRoaXMuaXNXYWxrYWJsZUF0KHggLSAxLCB5ICsgMSkpIHtcbiAgICAgICAgbmVpZ2hib3JzLnB1c2gobm9kZXNbeSArIDFdW3ggLSAxXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5laWdoYm9ycztcbn07XG5cblxuLyoqXG4gKiBHZXQgYSBjbG9uZSBvZiB0aGlzIGdyaWQuXG4gKiBAcmV0dXJuIHtHcmlkfSBDbG9uZWQgZ3JpZC5cbiAqL1xuR3JpZC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaSwgaixcblxuICAgICAgICB3aWR0aCA9IHRoaXMud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IHRoaXMuaGVpZ2h0LFxuICAgICAgICB0aGlzTm9kZXMgPSB0aGlzLm5vZGVzLFxuXG4gICAgICAgIG5ld0dyaWQgPSBuZXcgR3JpZCh3aWR0aCwgaGVpZ2h0KSxcbiAgICAgICAgbmV3Tm9kZXMgPSBuZXcgQXJyYXkoaGVpZ2h0KSxcbiAgICAgICAgcm93O1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGhlaWdodDsgKytpKSB7XG4gICAgICAgIG5ld05vZGVzW2ldID0gbmV3IEFycmF5KHdpZHRoKTtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IHdpZHRoOyArK2opIHtcbiAgICAgICAgICAgIG5ld05vZGVzW2ldW2pdID0gbmV3IE5vZGUoaiwgaSwgdGhpc05vZGVzW2ldW2pdLndhbGthYmxlLCB0aGlzTm9kZXNbaV1bal0uY29zdCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZXdHcmlkLm5vZGVzID0gbmV3Tm9kZXM7XG5cbiAgICByZXR1cm4gbmV3R3JpZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR3JpZDtcbiIsIi8qKlxuICogQG5hbWVzcGFjZSBQRi5IZXVyaXN0aWNcbiAqIEBkZXNjcmlwdGlvbiBBIGNvbGxlY3Rpb24gb2YgaGV1cmlzdGljIGZ1bmN0aW9ucy5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgLyoqXG4gICAqIE1hbmhhdHRhbiBkaXN0YW5jZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGR4IC0gRGlmZmVyZW5jZSBpbiB4LlxuICAgKiBAcGFyYW0ge251bWJlcn0gZHkgLSBEaWZmZXJlbmNlIGluIHkuXG4gICAqIEByZXR1cm4ge251bWJlcn0gZHggKyBkeVxuICAgKi9cbiAgbWFuaGF0dGFuOiBmdW5jdGlvbihkeCwgZHkpIHtcbiAgICAgIHJldHVybiBkeCArIGR5O1xuICB9LFxuXG4gIC8qKlxuICAgKiBFdWNsaWRlYW4gZGlzdGFuY2UuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkeCAtIERpZmZlcmVuY2UgaW4geC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGR5IC0gRGlmZmVyZW5jZSBpbiB5LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IHNxcnQoZHggKiBkeCArIGR5ICogZHkpXG4gICAqL1xuICBldWNsaWRlYW46IGZ1bmN0aW9uKGR4LCBkeSkge1xuICAgICAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE9jdGlsZSBkaXN0YW5jZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGR4IC0gRGlmZmVyZW5jZSBpbiB4LlxuICAgKiBAcGFyYW0ge251bWJlcn0gZHkgLSBEaWZmZXJlbmNlIGluIHkuXG4gICAqIEByZXR1cm4ge251bWJlcn0gc3FydChkeCAqIGR4ICsgZHkgKiBkeSkgZm9yIGdyaWRzXG4gICAqL1xuICBvY3RpbGU6IGZ1bmN0aW9uKGR4LCBkeSkge1xuICAgICAgdmFyIEYgPSBNYXRoLlNRUlQyIC0gMTtcbiAgICAgIHJldHVybiAoZHggPCBkeSkgPyBGICogZHggKyBkeSA6IEYgKiBkeSArIGR4O1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVieXNoZXYgZGlzdGFuY2UuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkeCAtIERpZmZlcmVuY2UgaW4geC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGR5IC0gRGlmZmVyZW5jZSBpbiB5LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IG1heChkeCwgZHkpXG4gICAqL1xuICBjaGVieXNoZXY6IGZ1bmN0aW9uKGR4LCBkeSkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KGR4LCBkeSk7XG4gIH1cblxufTtcbiIsIi8qKlxuICogQSBub2RlIGluIGdyaWQuIFxuICogVGhpcyBjbGFzcyBob2xkcyBzb21lIGJhc2ljIGluZm9ybWF0aW9uIGFib3V0IGEgbm9kZSBhbmQgY3VzdG9tIFxuICogYXR0cmlidXRlcyBtYXkgYmUgYWRkZWQsIGRlcGVuZGluZyBvbiB0aGUgYWxnb3JpdGhtcycgbmVlZHMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgbm9kZSBvbiB0aGUgZ3JpZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgbm9kZSBvbiB0aGUgZ3JpZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3dhbGthYmxlXSAtIFdoZXRoZXIgdGhpcyBub2RlIGlzIHdhbGthYmxlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtjb3N0XSAtIG5vZGUgY29zdCB1c2VkIGJ5IGZpbmRlcnMgdGhhdCBhbGxvdyBub24tdW5pZm9ybSBub2RlIGNvc3RzXG4gKi9cbmZ1bmN0aW9uIE5vZGUoeCwgeSwgd2Fsa2FibGUsIGNvc3QpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBub2RlIG9uIHRoZSBncmlkLlxuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqL1xuICAgIHRoaXMueCA9IHg7XG4gICAgLyoqXG4gICAgICogVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgbm9kZSBvbiB0aGUgZ3JpZC5cbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKi9cbiAgICB0aGlzLnkgPSB5O1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhpcyBub2RlIGNhbiBiZSB3YWxrZWQgdGhyb3VnaC5cbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICovXG4gICAgdGhpcy53YWxrYWJsZSA9ICh3YWxrYWJsZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IHdhbGthYmxlKTtcbiAgICAvKipcbiAgICAgKiBDb3N0IHRvIHdhbGsgdGhpcyBub2RlIGlmIGl0cyB3YWxrYWJsZVxuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqL1xuICAgIHRoaXMuY29zdCA9IChjb3N0ID09PSB1bmRlZmluZWQpID8gMCA6IGNvc3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTm9kZTtcbiIsIi8qKlxuICogQmFja3RyYWNlIGFjY29yZGluZyB0byB0aGUgcGFyZW50IHJlY29yZHMgYW5kIHJldHVybiB0aGUgcGF0aC5cbiAqIChpbmNsdWRpbmcgYm90aCBzdGFydCBhbmQgZW5kIG5vZGVzKVxuICogQHBhcmFtIHtOb2RlfSBub2RlIEVuZCBub2RlXG4gKiBAcmV0dXJuIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSB0aGUgcGF0aFxuICovXG5mdW5jdGlvbiBiYWNrdHJhY2Uobm9kZSkge1xuICAgIHZhciBwYXRoID0gW1tub2RlLngsIG5vZGUueV1dO1xuICAgIHdoaWxlIChub2RlLnBhcmVudCkge1xuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgICAgIHBhdGgucHVzaChbbm9kZS54LCBub2RlLnldKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGgucmV2ZXJzZSgpO1xufVxuZXhwb3J0cy5iYWNrdHJhY2UgPSBiYWNrdHJhY2U7XG5cbi8qKlxuICogQmFja3RyYWNlIGZyb20gc3RhcnQgYW5kIGVuZCBub2RlLCBhbmQgcmV0dXJuIHRoZSBwYXRoLlxuICogKGluY2x1ZGluZyBib3RoIHN0YXJ0IGFuZCBlbmQgbm9kZXMpXG4gKiBAcGFyYW0ge05vZGV9XG4gKiBAcGFyYW0ge05vZGV9XG4gKi9cbmZ1bmN0aW9uIGJpQmFja3RyYWNlKG5vZGVBLCBub2RlQikge1xuICAgIHZhciBwYXRoQSA9IGJhY2t0cmFjZShub2RlQSksXG4gICAgICAgIHBhdGhCID0gYmFja3RyYWNlKG5vZGVCKTtcbiAgICByZXR1cm4gcGF0aEEuY29uY2F0KHBhdGhCLnJldmVyc2UoKSk7XG59XG5leHBvcnRzLmJpQmFja3RyYWNlID0gYmlCYWNrdHJhY2U7XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgbGVuZ3RoIG9mIHRoZSBwYXRoLlxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBwYXRoIFRoZSBwYXRoXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBsZW5ndGggb2YgdGhlIHBhdGhcbiAqL1xuZnVuY3Rpb24gcGF0aExlbmd0aChwYXRoKSB7XG4gICAgdmFyIGksIHN1bSA9IDAsIGEsIGIsIGR4LCBkeTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgcGF0aC5sZW5ndGg7ICsraSkge1xuICAgICAgICBhID0gcGF0aFtpIC0gMV07XG4gICAgICAgIGIgPSBwYXRoW2ldO1xuICAgICAgICBkeCA9IGFbMF0gLSBiWzBdO1xuICAgICAgICBkeSA9IGFbMV0gLSBiWzFdO1xuICAgICAgICBzdW0gKz0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICB9XG4gICAgcmV0dXJuIHN1bTtcbn1cbmV4cG9ydHMucGF0aExlbmd0aCA9IHBhdGhMZW5ndGg7XG5cblxuLyoqXG4gKiBHaXZlbiB0aGUgc3RhcnQgYW5kIGVuZCBjb29yZGluYXRlcywgcmV0dXJuIGFsbCB0aGUgY29vcmRpbmF0ZXMgbHlpbmdcbiAqIG9uIHRoZSBsaW5lIGZvcm1lZCBieSB0aGVzZSBjb29yZGluYXRlcywgYmFzZWQgb24gQnJlc2VuaGFtJ3MgYWxnb3JpdGhtLlxuICogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CcmVzZW5oYW0nc19saW5lX2FsZ29yaXRobSNTaW1wbGlmaWNhdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHgwIFN0YXJ0IHggY29vcmRpbmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHkwIFN0YXJ0IHkgY29vcmRpbmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHgxIEVuZCB4IGNvb3JkaW5hdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MSBFbmQgeSBjb29yZGluYXRlXG4gKiBAcmV0dXJuIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBUaGUgY29vcmRpbmF0ZXMgb24gdGhlIGxpbmVcbiAqL1xuZnVuY3Rpb24gaW50ZXJwb2xhdGUoeDAsIHkwLCB4MSwgeTEpIHtcbiAgICB2YXIgYWJzID0gTWF0aC5hYnMsXG4gICAgICAgIGxpbmUgPSBbXSxcbiAgICAgICAgc3gsIHN5LCBkeCwgZHksIGVyciwgZTI7XG5cbiAgICBkeCA9IGFicyh4MSAtIHgwKTtcbiAgICBkeSA9IGFicyh5MSAtIHkwKTtcblxuICAgIHN4ID0gKHgwIDwgeDEpID8gMSA6IC0xO1xuICAgIHN5ID0gKHkwIDwgeTEpID8gMSA6IC0xO1xuXG4gICAgZXJyID0gZHggLSBkeTtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGxpbmUucHVzaChbeDAsIHkwXSk7XG5cbiAgICAgICAgaWYgKHgwID09PSB4MSAmJiB5MCA9PT0geTEpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBlMiA9IDIgKiBlcnI7XG4gICAgICAgIGlmIChlMiA+IC1keSkge1xuICAgICAgICAgICAgZXJyID0gZXJyIC0gZHk7XG4gICAgICAgICAgICB4MCA9IHgwICsgc3g7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUyIDwgZHgpIHtcbiAgICAgICAgICAgIGVyciA9IGVyciArIGR4O1xuICAgICAgICAgICAgeTAgPSB5MCArIHN5O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpbmU7XG59XG5leHBvcnRzLmludGVycG9sYXRlID0gaW50ZXJwb2xhdGU7XG5cblxuLyoqXG4gKiBHaXZlbiBhIGNvbXByZXNzZWQgcGF0aCwgcmV0dXJuIGEgbmV3IHBhdGggdGhhdCBoYXMgYWxsIHRoZSBzZWdtZW50c1xuICogaW4gaXQgaW50ZXJwb2xhdGVkLlxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBwYXRoIFRoZSBwYXRoXG4gKiBAcmV0dXJuIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBleHBhbmRlZCBwYXRoXG4gKi9cbmZ1bmN0aW9uIGV4cGFuZFBhdGgocGF0aCkge1xuICAgIHZhciBleHBhbmRlZCA9IFtdLFxuICAgICAgICBsZW4gPSBwYXRoLmxlbmd0aCxcbiAgICAgICAgY29vcmQwLCBjb29yZDEsXG4gICAgICAgIGludGVycG9sYXRlZCxcbiAgICAgICAgaW50ZXJwb2xhdGVkTGVuLFxuICAgICAgICBpLCBqO1xuXG4gICAgaWYgKGxlbiA8IDIpIHtcbiAgICAgICAgcmV0dXJuIGV4cGFuZGVkO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW4gLSAxOyArK2kpIHtcbiAgICAgICAgY29vcmQwID0gcGF0aFtpXTtcbiAgICAgICAgY29vcmQxID0gcGF0aFtpICsgMV07XG5cbiAgICAgICAgaW50ZXJwb2xhdGVkID0gaW50ZXJwb2xhdGUoY29vcmQwWzBdLCBjb29yZDBbMV0sIGNvb3JkMVswXSwgY29vcmQxWzFdKTtcbiAgICAgICAgaW50ZXJwb2xhdGVkTGVuID0gaW50ZXJwb2xhdGVkLmxlbmd0aDtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGludGVycG9sYXRlZExlbiAtIDE7ICsraikge1xuICAgICAgICAgICAgZXhwYW5kZWQucHVzaChpbnRlcnBvbGF0ZWRbal0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGV4cGFuZGVkLnB1c2gocGF0aFtsZW4gLSAxXSk7XG5cbiAgICByZXR1cm4gZXhwYW5kZWQ7XG59XG5leHBvcnRzLmV4cGFuZFBhdGggPSBleHBhbmRQYXRoO1xuXG5cbi8qKlxuICogU21vb3RoZW4gdGhlIGdpdmUgcGF0aC5cbiAqIFRoZSBvcmlnaW5hbCBwYXRoIHdpbGwgbm90IGJlIG1vZGlmaWVkOyBhIG5ldyBwYXRoIHdpbGwgYmUgcmV0dXJuZWQuXG4gKiBAcGFyYW0ge1BGLkdyaWR9IGdyaWRcbiAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxudW1iZXI+Pn0gcGF0aCBUaGUgcGF0aFxuICovXG5mdW5jdGlvbiBzbW9vdGhlblBhdGgoZ3JpZCwgcGF0aCkge1xuICAgIHZhciBsZW4gPSBwYXRoLmxlbmd0aCxcbiAgICAgICAgeDAgPSBwYXRoWzBdWzBdLCAgICAgICAgLy8gcGF0aCBzdGFydCB4XG4gICAgICAgIHkwID0gcGF0aFswXVsxXSwgICAgICAgIC8vIHBhdGggc3RhcnQgeVxuICAgICAgICB4MSA9IHBhdGhbbGVuIC0gMV1bMF0sICAvLyBwYXRoIGVuZCB4XG4gICAgICAgIHkxID0gcGF0aFtsZW4gLSAxXVsxXSwgIC8vIHBhdGggZW5kIHlcbiAgICAgICAgc3gsIHN5LCAgICAgICAgICAgICAgICAgLy8gY3VycmVudCBzdGFydCBjb29yZGluYXRlXG4gICAgICAgIGV4LCBleSwgICAgICAgICAgICAgICAgIC8vIGN1cnJlbnQgZW5kIGNvb3JkaW5hdGVcbiAgICAgICAgbmV3UGF0aCxcbiAgICAgICAgaSwgaiwgY29vcmQsIGxpbmUsIHRlc3RDb29yZCwgYmxvY2tlZDtcblxuICAgIHN4ID0geDA7XG4gICAgc3kgPSB5MDtcbiAgICBuZXdQYXRoID0gW1tzeCwgc3ldXTtcblxuICAgIGZvciAoaSA9IDI7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBjb29yZCA9IHBhdGhbaV07XG4gICAgICAgIGV4ID0gY29vcmRbMF07XG4gICAgICAgIGV5ID0gY29vcmRbMV07XG4gICAgICAgIGxpbmUgPSBpbnRlcnBvbGF0ZShzeCwgc3ksIGV4LCBleSk7XG5cbiAgICAgICAgYmxvY2tlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGogPSAxOyBqIDwgbGluZS5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgdGVzdENvb3JkID0gbGluZVtqXTtcblxuICAgICAgICAgICAgaWYgKCFncmlkLmlzV2Fsa2FibGVBdCh0ZXN0Q29vcmRbMF0sIHRlc3RDb29yZFsxXSkpIHtcbiAgICAgICAgICAgICAgICBibG9ja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYmxvY2tlZCkge1xuICAgICAgICAgICAgbGFzdFZhbGlkQ29vcmQgPSBwYXRoW2kgLSAxXTtcbiAgICAgICAgICAgIG5ld1BhdGgucHVzaChsYXN0VmFsaWRDb29yZCk7XG4gICAgICAgICAgICBzeCA9IGxhc3RWYWxpZENvb3JkWzBdO1xuICAgICAgICAgICAgc3kgPSBsYXN0VmFsaWRDb29yZFsxXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZXdQYXRoLnB1c2goW3gxLCB5MV0pO1xuXG4gICAgcmV0dXJuIG5ld1BhdGg7XG59XG5leHBvcnRzLnNtb290aGVuUGF0aCA9IHNtb290aGVuUGF0aDtcblxuXG4vKipcbiAqIENvbXByZXNzIGEgcGF0aCwgcmVtb3ZlIHJlZHVuZGFudCBub2RlcyB3aXRob3V0IGFsdGVyaW5nIHRoZSBzaGFwZVxuICogVGhlIG9yaWdpbmFsIHBhdGggaXMgbm90IG1vZGlmaWVkXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyPj59IHBhdGggVGhlIHBhdGhcbiAqIEByZXR1cm4ge0FycmF5LjxBcnJheS48bnVtYmVyPj59IFRoZSBjb21wcmVzc2VkIHBhdGhcbiAqL1xuZnVuY3Rpb24gY29tcHJlc3NQYXRoKHBhdGgpIHtcblxuICAgIC8vIG5vdGhpbmcgdG8gY29tcHJlc3NcbiAgICBpZihwYXRoLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxuXG4gICAgdmFyIGNvbXByZXNzZWQgPSBbXSxcbiAgICAgICAgc3ggPSBwYXRoWzBdWzBdLCAvLyBzdGFydCB4XG4gICAgICAgIHN5ID0gcGF0aFswXVsxXSwgLy8gc3RhcnQgeVxuICAgICAgICBweCA9IHBhdGhbMV1bMF0sIC8vIHNlY29uZCBwb2ludCB4XG4gICAgICAgIHB5ID0gcGF0aFsxXVsxXSwgLy8gc2Vjb25kIHBvaW50IHlcbiAgICAgICAgZHggPSBweCAtIHN4LCAvLyBkaXJlY3Rpb24gYmV0d2VlbiB0aGUgdHdvIHBvaW50c1xuICAgICAgICBkeSA9IHB5IC0gc3ksIC8vIGRpcmVjdGlvbiBiZXR3ZWVuIHRoZSB0d28gcG9pbnRzXG4gICAgICAgIGx4LCBseSxcbiAgICAgICAgbGR4LCBsZHksXG4gICAgICAgIHNxLCBpO1xuXG4gICAgLy8gbm9ybWFsaXplIHRoZSBkaXJlY3Rpb25cbiAgICBzcSA9IE1hdGguc3FydChkeCpkeCArIGR5KmR5KTtcbiAgICBkeCAvPSBzcTtcbiAgICBkeSAvPSBzcTtcblxuICAgIC8vIHN0YXJ0IHRoZSBuZXcgcGF0aFxuICAgIGNvbXByZXNzZWQucHVzaChbc3gsc3ldKTtcblxuICAgIGZvcihpID0gMjsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICAvLyBzdG9yZSB0aGUgbGFzdCBwb2ludFxuICAgICAgICBseCA9IHB4O1xuICAgICAgICBseSA9IHB5O1xuXG4gICAgICAgIC8vIHN0b3JlIHRoZSBsYXN0IGRpcmVjdGlvblxuICAgICAgICBsZHggPSBkeDtcbiAgICAgICAgbGR5ID0gZHk7XG5cbiAgICAgICAgLy8gbmV4dCBwb2ludFxuICAgICAgICBweCA9IHBhdGhbaV1bMF07XG4gICAgICAgIHB5ID0gcGF0aFtpXVsxXTtcblxuICAgICAgICAvLyBuZXh0IGRpcmVjdGlvblxuICAgICAgICBkeCA9IHB4IC0gbHg7XG4gICAgICAgIGR5ID0gcHkgLSBseTtcblxuICAgICAgICAvLyBub3JtYWxpemVcbiAgICAgICAgc3EgPSBNYXRoLnNxcnQoZHgqZHggKyBkeSpkeSk7XG4gICAgICAgIGR4IC89IHNxO1xuICAgICAgICBkeSAvPSBzcTtcblxuICAgICAgICAvLyBpZiB0aGUgZGlyZWN0aW9uIGhhcyBjaGFuZ2VkLCBzdG9yZSB0aGUgcG9pbnRcbiAgICAgICAgaWYgKCBkeCAhPT0gbGR4IHx8IGR5ICE9PSBsZHkgKSB7XG4gICAgICAgICAgICBjb21wcmVzc2VkLnB1c2goW2x4LGx5XSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzdG9yZSB0aGUgbGFzdCBwb2ludFxuICAgIGNvbXByZXNzZWQucHVzaChbcHgscHldKTtcblxuICAgIHJldHVybiBjb21wcmVzc2VkO1xufVxuZXhwb3J0cy5jb21wcmVzc1BhdGggPSBjb21wcmVzc1BhdGg7XG4iLCJ2YXIgSGVhcCAgICAgICA9IHJlcXVpcmUoJ2hlYXAnKTtcbnZhciBVdGlsICAgICAgID0gcmVxdWlyZSgnLi4vY29yZS9VdGlsJyk7XG52YXIgSGV1cmlzdGljICA9IHJlcXVpcmUoJy4uL2NvcmUvSGV1cmlzdGljJyk7XG52YXIgRGlhZ29uYWxNb3ZlbWVudCA9IHJlcXVpcmUoJy4uL2NvcmUvRGlhZ29uYWxNb3ZlbWVudCcpO1xuXG4vKipcbiAqIEEqIHBhdGgtZmluZGVyLlxuICogYmFzZWQgdXBvbiBodHRwczovL2dpdGh1Yi5jb20vYmdyaW5zL2phdmFzY3JpcHQtYXN0YXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IG9wdFxuICogQHBhcmFtIHtib29sZWFufSBvcHQuYWxsb3dEaWFnb25hbCBXaGV0aGVyIGRpYWdvbmFsIG1vdmVtZW50IGlzIGFsbG93ZWQuIERlcHJlY2F0ZWQsIHVzZSBkaWFnb25hbE1vdmVtZW50IGluc3RlYWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdC5kb250Q3Jvc3NDb3JuZXJzIERpc2FsbG93IGRpYWdvbmFsIG1vdmVtZW50IHRvdWNoaW5nIGJsb2NrIGNvcm5lcnMuIERlcHJlY2F0ZWQsIHVzZSBkaWFnb25hbE1vdmVtZW50IGluc3RlYWQuXG4gKiBAcGFyYW0ge0RpYWdvbmFsTW92ZW1lbnR9IG9wdC5kaWFnb25hbE1vdmVtZW50IEFsbG93ZWQgZGlhZ29uYWwgbW92ZW1lbnQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBvcHQuaGV1cmlzdGljIEhldXJpc3RpYyBmdW5jdGlvbiB0byBlc3RpbWF0ZSB0aGUgZGlzdGFuY2VcbiAqICAgICAoZGVmYXVsdHMgdG8gbWFuaGF0dGFuKS5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gb3B0LndlaWdodCBXZWlnaHQgdG8gYXBwbHkgdG8gdGhlIGhldXJpc3RpYyB0byBhbGxvdyBmb3Igc3Vib3B0aW1hbCBwYXRocywgXG4gKiAgICAgaW4gb3JkZXIgdG8gc3BlZWQgdXAgdGhlIHNlYXJjaC5cbiAqL1xuZnVuY3Rpb24gQVN0YXJGaW5kZXIob3B0KSB7XG4gICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgIHRoaXMuYWxsb3dEaWFnb25hbCA9IG9wdC5hbGxvd0RpYWdvbmFsO1xuICAgIHRoaXMuZG9udENyb3NzQ29ybmVycyA9IG9wdC5kb250Q3Jvc3NDb3JuZXJzO1xuICAgIHRoaXMuaGV1cmlzdGljID0gb3B0LmhldXJpc3RpYyB8fCBIZXVyaXN0aWMubWFuaGF0dGFuO1xuICAgIHRoaXMud2VpZ2h0ID0gb3B0LndlaWdodCB8fCAxO1xuICAgIHRoaXMuZGlhZ29uYWxNb3ZlbWVudCA9IG9wdC5kaWFnb25hbE1vdmVtZW50O1xuXG4gICAgaWYgKCF0aGlzLmRpYWdvbmFsTW92ZW1lbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFsbG93RGlhZ29uYWwpIHtcbiAgICAgICAgICAgIHRoaXMuZGlhZ29uYWxNb3ZlbWVudCA9IERpYWdvbmFsTW92ZW1lbnQuTmV2ZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kb250Q3Jvc3NDb3JuZXJzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaWFnb25hbE1vdmVtZW50ID0gRGlhZ29uYWxNb3ZlbWVudC5Pbmx5V2hlbk5vT2JzdGFjbGVzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpYWdvbmFsTW92ZW1lbnQgPSBEaWFnb25hbE1vdmVtZW50LklmQXRNb3N0T25lT2JzdGFjbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvL1doZW4gZGlhZ29uYWwgbW92ZW1lbnQgaXMgYWxsb3dlZCB0aGUgbWFuaGF0dGFuIGhldXJpc3RpYyBpcyBub3QgYWRtaXNzaWJsZVxuICAgIC8vSXQgc2hvdWxkIGJlIG9jdGlsZSBpbnN0ZWFkXG4gICAgaWYgKHRoaXMuZGlhZ29uYWxNb3ZlbWVudCA9PT0gRGlhZ29uYWxNb3ZlbWVudC5OZXZlcikge1xuICAgICAgICB0aGlzLmhldXJpc3RpYyA9IG9wdC5oZXVyaXN0aWMgfHwgSGV1cmlzdGljLm1hbmhhdHRhbjtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhldXJpc3RpYyA9IG9wdC5oZXVyaXN0aWMgfHwgSGV1cmlzdGljLm9jdGlsZTtcbiAgICB9XG59XG5cbi8qKlxuICogRmluZCBhbmQgcmV0dXJuIHRoZSB0aGUgcGF0aC5cbiAqIEByZXR1cm4ge0FycmF5LjxbbnVtYmVyLCBudW1iZXJdPn0gVGhlIHBhdGgsIGluY2x1ZGluZyBib3RoIHN0YXJ0IGFuZFxuICogICAgIGVuZCBwb3NpdGlvbnMuXG4gKi9cbkFTdGFyRmluZGVyLnByb3RvdHlwZS5maW5kUGF0aCA9IGZ1bmN0aW9uKHN0YXJ0WCwgc3RhcnRZLCBlbmRYLCBlbmRZLCBncmlkKSB7XG4gICAgdmFyIG9wZW5MaXN0ID0gbmV3IEhlYXAoZnVuY3Rpb24obm9kZUEsIG5vZGVCKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZUEuZiAtIG5vZGVCLmY7XG4gICAgICAgIH0pLFxuICAgICAgICBzdGFydE5vZGUgPSBncmlkLmdldE5vZGVBdChzdGFydFgsIHN0YXJ0WSksXG4gICAgICAgIGVuZE5vZGUgPSBncmlkLmdldE5vZGVBdChlbmRYLCBlbmRZKSxcbiAgICAgICAgaGV1cmlzdGljID0gdGhpcy5oZXVyaXN0aWMsXG4gICAgICAgIGRpYWdvbmFsTW92ZW1lbnQgPSB0aGlzLmRpYWdvbmFsTW92ZW1lbnQsXG4gICAgICAgIHdlaWdodCA9IHRoaXMud2VpZ2h0LFxuICAgICAgICBhYnMgPSBNYXRoLmFicywgU1FSVDIgPSBNYXRoLlNRUlQyLFxuICAgICAgICBub2RlLCBuZWlnaGJvcnMsIG5laWdoYm9yLCBpLCBsLCB4LCB5LCBuZztcblxuICAgIC8vIHNldCB0aGUgYGdgIGFuZCBgZmAgdmFsdWUgb2YgdGhlIHN0YXJ0IG5vZGUgdG8gYmUgMFxuICAgIHN0YXJ0Tm9kZS5nID0gMDtcbiAgICBzdGFydE5vZGUuZiA9IDA7XG5cbiAgICAvLyBwdXNoIHRoZSBzdGFydCBub2RlIGludG8gdGhlIG9wZW4gbGlzdFxuICAgIG9wZW5MaXN0LnB1c2goc3RhcnROb2RlKTtcbiAgICBzdGFydE5vZGUub3BlbmVkID0gdHJ1ZTtcblxuICAgIC8vIHdoaWxlIHRoZSBvcGVuIGxpc3QgaXMgbm90IGVtcHR5XG4gICAgd2hpbGUgKCFvcGVuTGlzdC5lbXB0eSgpKSB7XG4gICAgICAgIC8vIHBvcCB0aGUgcG9zaXRpb24gb2Ygbm9kZSB3aGljaCBoYXMgdGhlIG1pbmltdW0gYGZgIHZhbHVlLlxuICAgICAgICBub2RlID0gb3Blbkxpc3QucG9wKCk7XG4gICAgICAgIG5vZGUuY2xvc2VkID0gdHJ1ZTtcblxuICAgICAgICAvLyBpZiByZWFjaGVkIHRoZSBlbmQgcG9zaXRpb24sIGNvbnN0cnVjdCB0aGUgcGF0aCBhbmQgcmV0dXJuIGl0XG4gICAgICAgIGlmIChub2RlID09PSBlbmROb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gVXRpbC5iYWNrdHJhY2UoZW5kTm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgbmVpZ2JvdXJzIG9mIHRoZSBjdXJyZW50IG5vZGVcbiAgICAgICAgbmVpZ2hib3JzID0gZ3JpZC5nZXROZWlnaGJvcnMobm9kZSwgZGlhZ29uYWxNb3ZlbWVudCk7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBuZWlnaGJvcnMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBuZWlnaGJvciA9IG5laWdoYm9yc1tpXTtcblxuICAgICAgICAgICAgaWYgKG5laWdoYm9yLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB4ID0gbmVpZ2hib3IueDtcbiAgICAgICAgICAgIHkgPSBuZWlnaGJvci55O1xuXG4gICAgICAgICAgICAvLyBnZXQgdGhlIGRpc3RhbmNlIGJldHdlZW4gY3VycmVudCBub2RlIGFuZCB0aGUgbmVpZ2hib3JcbiAgICAgICAgICAgIC8vIGFuZCBjYWxjdWxhdGUgdGhlIG5leHQgZyBzY29yZVxuICAgICAgICAgICAgbmcgPSBub2RlLmcgKyBuZWlnaGJvci5jb3N0ICsgKCh4IC0gbm9kZS54ID09PSAwIHx8IHkgLSBub2RlLnkgPT09IDApID8gMSA6IFNRUlQyKTtcblxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIG5laWdoYm9yIGhhcyBub3QgYmVlbiBpbnNwZWN0ZWQgeWV0LCBvclxuICAgICAgICAgICAgLy8gY2FuIGJlIHJlYWNoZWQgd2l0aCBzbWFsbGVyIGNvc3QgZnJvbSB0aGUgY3VycmVudCBub2RlXG4gICAgICAgICAgICBpZiAoIW5laWdoYm9yLm9wZW5lZCB8fCBuZyA8IG5laWdoYm9yLmcpIHtcbiAgICAgICAgICAgICAgICBuZWlnaGJvci5nID0gbmc7XG4gICAgICAgICAgICAgICAgbmVpZ2hib3IuaCA9IG5laWdoYm9yLmggfHwgd2VpZ2h0ICogaGV1cmlzdGljKGFicyh4IC0gZW5kWCksIGFicyh5IC0gZW5kWSkpO1xuICAgICAgICAgICAgICAgIG5laWdoYm9yLmYgPSBuZWlnaGJvci5nICsgbmVpZ2hib3IuaDtcbiAgICAgICAgICAgICAgICBuZWlnaGJvci5wYXJlbnQgPSBub2RlO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFuZWlnaGJvci5vcGVuZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3Blbkxpc3QucHVzaChuZWlnaGJvcik7XG4gICAgICAgICAgICAgICAgICAgIG5laWdoYm9yLm9wZW5lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIG5laWdoYm9yIGNhbiBiZSByZWFjaGVkIHdpdGggc21hbGxlciBjb3N0LlxuICAgICAgICAgICAgICAgICAgICAvLyBTaW5jZSBpdHMgZiB2YWx1ZSBoYXMgYmVlbiB1cGRhdGVkLCB3ZSBoYXZlIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBpdHMgcG9zaXRpb24gaW4gdGhlIG9wZW4gbGlzdFxuICAgICAgICAgICAgICAgICAgICBvcGVuTGlzdC51cGRhdGVJdGVtKG5laWdoYm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gLy8gZW5kIGZvciBlYWNoIG5laWdoYm9yXG4gICAgfSAvLyBlbmQgd2hpbGUgbm90IG9wZW4gbGlzdCBlbXB0eVxuXG4gICAgLy8gZmFpbCB0byBmaW5kIHRoZSBwYXRoXG4gICAgcmV0dXJuIFtdO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBU3RhckZpbmRlcjtcbiIsInZhciBBU3RhckZpbmRlciA9IHJlcXVpcmUoJy4vQVN0YXJGaW5kZXInKTtcblxuLyoqXG4gKiBCZXN0LUZpcnN0LVNlYXJjaCBwYXRoLWZpbmRlci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQVN0YXJGaW5kZXJcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0LmFsbG93RGlhZ29uYWwgV2hldGhlciBkaWFnb25hbCBtb3ZlbWVudCBpcyBhbGxvd2VkLiBEZXByZWNhdGVkLCB1c2UgZGlhZ29uYWxNb3ZlbWVudCBpbnN0ZWFkLlxuICogQHBhcmFtIHtib29sZWFufSBvcHQuZG9udENyb3NzQ29ybmVycyBEaXNhbGxvdyBkaWFnb25hbCBtb3ZlbWVudCB0b3VjaGluZyBibG9jayBjb3JuZXJzLiBEZXByZWNhdGVkLCB1c2UgZGlhZ29uYWxNb3ZlbWVudCBpbnN0ZWFkLlxuICogQHBhcmFtIHtEaWFnb25hbE1vdmVtZW50fSBvcHQuZGlhZ29uYWxNb3ZlbWVudCBBbGxvd2VkIGRpYWdvbmFsIG1vdmVtZW50LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0LmhldXJpc3RpYyBIZXVyaXN0aWMgZnVuY3Rpb24gdG8gZXN0aW1hdGUgdGhlIGRpc3RhbmNlXG4gKiAgICAgKGRlZmF1bHRzIHRvIG1hbmhhdHRhbikuXG4gKi9cbmZ1bmN0aW9uIEJlc3RGaXJzdEZpbmRlcihvcHQpIHtcbiAgICBBU3RhckZpbmRlci5jYWxsKHRoaXMsIG9wdCk7XG5cbiAgICB2YXIgb3JpZyA9IHRoaXMuaGV1cmlzdGljO1xuICAgIHRoaXMuaGV1cmlzdGljID0gZnVuY3Rpb24oZHgsIGR5KSB7XG4gICAgICAgIHJldHVybiBvcmlnKGR4LCBkeSkgKiAxMDAwMDAwO1xuICAgIH07XG59XG5cbkJlc3RGaXJzdEZpbmRlci5wcm90b3R5cGUgPSBuZXcgQVN0YXJGaW5kZXIoKTtcbkJlc3RGaXJzdEZpbmRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCZXN0Rmlyc3RGaW5kZXI7XG5cbm1vZHVsZS5leHBvcnRzID0gQmVzdEZpcnN0RmluZGVyO1xuIiwidmFyIEhlYXAgICAgICAgPSByZXF1aXJlKCdoZWFwJyk7XG52YXIgVXRpbCAgICAgICA9IHJlcXVpcmUoJy4uL2NvcmUvVXRpbCcpO1xudmFyIEhldXJpc3RpYyAgPSByZXF1aXJlKCcuLi9jb3JlL0hldXJpc3RpYycpO1xudmFyIERpYWdvbmFsTW92ZW1lbnQgPSByZXF1aXJlKCcuLi9jb3JlL0RpYWdvbmFsTW92ZW1lbnQnKTtcblxuLyoqXG4gKiBBKiBwYXRoLWZpbmRlci5cbiAqIGJhc2VkIHVwb24gaHR0cHM6Ly9naXRodWIuY29tL2Jncmlucy9qYXZhc2NyaXB0LWFzdGFyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0LmFsbG93RGlhZ29uYWwgV2hldGhlciBkaWFnb25hbCBtb3ZlbWVudCBpcyBhbGxvd2VkLiBEZXByZWNhdGVkLCB1c2UgZGlhZ29uYWxNb3ZlbWVudCBpbnN0ZWFkLlxuICogQHBhcmFtIHtib29sZWFufSBvcHQuZG9udENyb3NzQ29ybmVycyBEaXNhbGxvdyBkaWFnb25hbCBtb3ZlbWVudCB0b3VjaGluZyBibG9jayBjb3JuZXJzLiBEZXByZWNhdGVkLCB1c2UgZGlhZ29uYWxNb3ZlbWVudCBpbnN0ZWFkLlxuICogQHBhcmFtIHtEaWFnb25hbE1vdmVtZW50fSBvcHQuZGlhZ29uYWxNb3ZlbWVudCBBbGxvd2VkIGRpYWdvbmFsIG1vdmVtZW50LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0LmhldXJpc3RpYyBIZXVyaXN0aWMgZnVuY3Rpb24gdG8gZXN0aW1hdGUgdGhlIGRpc3RhbmNlXG4gKiAgICAgKGRlZmF1bHRzIHRvIG1hbmhhdHRhbikuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IG9wdC53ZWlnaHQgV2VpZ2h0IHRvIGFwcGx5IHRvIHRoZSBoZXVyaXN0aWMgdG8gYWxsb3cgZm9yIHN1Ym9wdGltYWwgcGF0aHMsIFxuICogICAgIGluIG9yZGVyIHRvIHNwZWVkIHVwIHRoZSBzZWFyY2guXG4gKi9cbmZ1bmN0aW9uIEJpQVN0YXJGaW5kZXIob3B0KSB7XG4gICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgIHRoaXMuYWxsb3dEaWFnb25hbCA9IG9wdC5hbGxvd0RpYWdvbmFsO1xuICAgIHRoaXMuZG9udENyb3NzQ29ybmVycyA9IG9wdC5kb250Q3Jvc3NDb3JuZXJzO1xuICAgIHRoaXMuZGlhZ29uYWxNb3ZlbWVudCA9IG9wdC5kaWFnb25hbE1vdmVtZW50O1xuICAgIHRoaXMuaGV1cmlzdGljID0gb3B0LmhldXJpc3RpYyB8fCBIZXVyaXN0aWMubWFuaGF0dGFuO1xuICAgIHRoaXMud2VpZ2h0ID0gb3B0LndlaWdodCB8fCAxO1xuXG4gICAgaWYgKCF0aGlzLmRpYWdvbmFsTW92ZW1lbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFsbG93RGlhZ29uYWwpIHtcbiAgICAgICAgICAgIHRoaXMuZGlhZ29uYWxNb3ZlbWVudCA9IERpYWdvbmFsTW92ZW1lbnQuTmV2ZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kb250Q3Jvc3NDb3JuZXJzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaWFnb25hbE1vdmVtZW50ID0gRGlhZ29uYWxNb3ZlbWVudC5Pbmx5V2hlbk5vT2JzdGFjbGVzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpYWdvbmFsTW92ZW1lbnQgPSBEaWFnb25hbE1vdmVtZW50LklmQXRNb3N0T25lT2JzdGFjbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvL1doZW4gZGlhZ29uYWwgbW92ZW1lbnQgaXMgYWxsb3dlZCB0aGUgbWFuaGF0dGFuIGhldXJpc3RpYyBpcyBub3QgYWRtaXNzaWJsZVxuICAgIC8vSXQgc2hvdWxkIGJlIG9jdGlsZSBpbnN0ZWFkXG4gICAgaWYgKHRoaXMuZGlhZ29uYWxNb3ZlbWVudCA9PT0gRGlhZ29uYWxNb3ZlbWVudC5OZXZlcikge1xuICAgICAgICB0aGlzLmhldXJpc3RpYyA9IG9wdC5oZXVyaXN0aWMgfHwgSGV1cmlzdGljLm1hbmhhdHRhbjtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhldXJpc3RpYyA9IG9wdC5oZXVyaXN0aWMgfHwgSGV1cmlzdGljLm9jdGlsZTtcbiAgICB9XG59XG5cbi8qKlxuICogRmluZCBhbmQgcmV0dXJuIHRoZSB0aGUgcGF0aC5cbiAqIEByZXR1cm4ge0FycmF5LjxbbnVtYmVyLCBudW1iZXJdPn0gVGhlIHBhdGgsIGluY2x1ZGluZyBib3RoIHN0YXJ0IGFuZFxuICogICAgIGVuZCBwb3NpdGlvbnMuXG4gKi9cbkJpQVN0YXJGaW5kZXIucHJvdG90eXBlLmZpbmRQYXRoID0gZnVuY3Rpb24oc3RhcnRYLCBzdGFydFksIGVuZFgsIGVuZFksIGdyaWQpIHtcbiAgICB2YXIgY21wID0gZnVuY3Rpb24obm9kZUEsIG5vZGVCKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZUEuZiAtIG5vZGVCLmY7XG4gICAgICAgIH0sXG4gICAgICAgIHN0YXJ0T3Blbkxpc3QgPSBuZXcgSGVhcChjbXApLFxuICAgICAgICBlbmRPcGVuTGlzdCA9IG5ldyBIZWFwKGNtcCksXG4gICAgICAgIHN0YXJ0Tm9kZSA9IGdyaWQuZ2V0Tm9kZUF0KHN0YXJ0WCwgc3RhcnRZKSxcbiAgICAgICAgZW5kTm9kZSA9IGdyaWQuZ2V0Tm9kZUF0KGVuZFgsIGVuZFkpLFxuICAgICAgICBoZXVyaXN0aWMgPSB0aGlzLmhldXJpc3RpYyxcbiAgICAgICAgZGlhZ29uYWxNb3ZlbWVudCA9IHRoaXMuZGlhZ29uYWxNb3ZlbWVudCxcbiAgICAgICAgd2VpZ2h0ID0gdGhpcy53ZWlnaHQsXG4gICAgICAgIGFicyA9IE1hdGguYWJzLCBTUVJUMiA9IE1hdGguU1FSVDIsXG4gICAgICAgIG5vZGUsIG5laWdoYm9ycywgbmVpZ2hib3IsIGksIGwsIHgsIHksIG5nLFxuICAgICAgICBCWV9TVEFSVCA9IDEsIEJZX0VORCA9IDI7XG5cbiAgICAvLyBzZXQgdGhlIGBnYCBhbmQgYGZgIHZhbHVlIG9mIHRoZSBzdGFydCBub2RlIHRvIGJlIDBcbiAgICAvLyBhbmQgcHVzaCBpdCBpbnRvIHRoZSBzdGFydCBvcGVuIGxpc3RcbiAgICBzdGFydE5vZGUuZyA9IDA7XG4gICAgc3RhcnROb2RlLmYgPSAwO1xuICAgIHN0YXJ0T3Blbkxpc3QucHVzaChzdGFydE5vZGUpO1xuICAgIHN0YXJ0Tm9kZS5vcGVuZWQgPSBCWV9TVEFSVDtcblxuICAgIC8vIHNldCB0aGUgYGdgIGFuZCBgZmAgdmFsdWUgb2YgdGhlIGVuZCBub2RlIHRvIGJlIDBcbiAgICAvLyBhbmQgcHVzaCBpdCBpbnRvIHRoZSBvcGVuIG9wZW4gbGlzdFxuICAgIGVuZE5vZGUuZyA9IDA7XG4gICAgZW5kTm9kZS5mID0gMDtcbiAgICBlbmRPcGVuTGlzdC5wdXNoKGVuZE5vZGUpO1xuICAgIGVuZE5vZGUub3BlbmVkID0gQllfRU5EO1xuXG4gICAgLy8gd2hpbGUgYm90aCB0aGUgb3BlbiBsaXN0cyBhcmUgbm90IGVtcHR5XG4gICAgd2hpbGUgKCFzdGFydE9wZW5MaXN0LmVtcHR5KCkgJiYgIWVuZE9wZW5MaXN0LmVtcHR5KCkpIHtcblxuICAgICAgICAvLyBwb3AgdGhlIHBvc2l0aW9uIG9mIHN0YXJ0IG5vZGUgd2hpY2ggaGFzIHRoZSBtaW5pbXVtIGBmYCB2YWx1ZS5cbiAgICAgICAgbm9kZSA9IHN0YXJ0T3Blbkxpc3QucG9wKCk7XG4gICAgICAgIG5vZGUuY2xvc2VkID0gdHJ1ZTtcblxuICAgICAgICAvLyBnZXQgbmVpZ2JvdXJzIG9mIHRoZSBjdXJyZW50IG5vZGVcbiAgICAgICAgbmVpZ2hib3JzID0gZ3JpZC5nZXROZWlnaGJvcnMobm9kZSwgZGlhZ29uYWxNb3ZlbWVudCk7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBuZWlnaGJvcnMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBuZWlnaGJvciA9IG5laWdoYm9yc1tpXTtcblxuICAgICAgICAgICAgaWYgKG5laWdoYm9yLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5laWdoYm9yLm9wZW5lZCA9PT0gQllfRU5EKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0aWwuYmlCYWNrdHJhY2Uobm9kZSwgbmVpZ2hib3IpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB4ID0gbmVpZ2hib3IueDtcbiAgICAgICAgICAgIHkgPSBuZWlnaGJvci55O1xuXG4gICAgICAgICAgICAvLyBnZXQgdGhlIGRpc3RhbmNlIGJldHdlZW4gY3VycmVudCBub2RlIGFuZCB0aGUgbmVpZ2hib3JcbiAgICAgICAgICAgIC8vIGFuZCBjYWxjdWxhdGUgdGhlIG5leHQgZyBzY29yZVxuICAgICAgICAgICAgbmcgPSBub2RlLmcgKyBuZWlnaGJvci5jb3N0ICsgKCh4IC0gbm9kZS54ID09PSAwIHx8IHkgLSBub2RlLnkgPT09IDApID8gMSA6IFNRUlQyKTtcblxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIG5laWdoYm9yIGhhcyBub3QgYmVlbiBpbnNwZWN0ZWQgeWV0LCBvclxuICAgICAgICAgICAgLy8gY2FuIGJlIHJlYWNoZWQgd2l0aCBzbWFsbGVyIGNvc3QgZnJvbSB0aGUgY3VycmVudCBub2RlXG4gICAgICAgICAgICBpZiAoIW5laWdoYm9yLm9wZW5lZCB8fCBuZyA8IG5laWdoYm9yLmcpIHtcbiAgICAgICAgICAgICAgICBuZWlnaGJvci5nID0gbmc7XG4gICAgICAgICAgICAgICAgbmVpZ2hib3IuaCA9IG5laWdoYm9yLmggfHwgd2VpZ2h0ICogaGV1cmlzdGljKGFicyh4IC0gZW5kWCksIGFicyh5IC0gZW5kWSkpO1xuICAgICAgICAgICAgICAgIG5laWdoYm9yLmYgPSBuZWlnaGJvci5nICsgbmVpZ2hib3IuaDtcbiAgICAgICAgICAgICAgICBuZWlnaGJvci5wYXJlbnQgPSBub2RlO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFuZWlnaGJvci5vcGVuZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRPcGVuTGlzdC5wdXNoKG5laWdoYm9yKTtcbiAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3Iub3BlbmVkID0gQllfU1RBUlQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIG5laWdoYm9yIGNhbiBiZSByZWFjaGVkIHdpdGggc21hbGxlciBjb3N0LlxuICAgICAgICAgICAgICAgICAgICAvLyBTaW5jZSBpdHMgZiB2YWx1ZSBoYXMgYmVlbiB1cGRhdGVkLCB3ZSBoYXZlIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBpdHMgcG9zaXRpb24gaW4gdGhlIG9wZW4gbGlzdFxuICAgICAgICAgICAgICAgICAgICBzdGFydE9wZW5MaXN0LnVwZGF0ZUl0ZW0obmVpZ2hib3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBlbmQgZm9yIGVhY2ggbmVpZ2hib3JcblxuXG4gICAgICAgIC8vIHBvcCB0aGUgcG9zaXRpb24gb2YgZW5kIG5vZGUgd2hpY2ggaGFzIHRoZSBtaW5pbXVtIGBmYCB2YWx1ZS5cbiAgICAgICAgbm9kZSA9IGVuZE9wZW5MaXN0LnBvcCgpO1xuICAgICAgICBub2RlLmNsb3NlZCA9IHRydWU7XG5cbiAgICAgICAgLy8gZ2V0IG5laWdib3VycyBvZiB0aGUgY3VycmVudCBub2RlXG4gICAgICAgIG5laWdoYm9ycyA9IGdyaWQuZ2V0TmVpZ2hib3JzKG5vZGUsIGRpYWdvbmFsTW92ZW1lbnQpO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gbmVpZ2hib3JzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgbmVpZ2hib3IgPSBuZWlnaGJvcnNbaV07XG5cbiAgICAgICAgICAgIGlmIChuZWlnaGJvci5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZWlnaGJvci5vcGVuZWQgPT09IEJZX1NUQVJUKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0aWwuYmlCYWNrdHJhY2UobmVpZ2hib3IsIG5vZGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB4ID0gbmVpZ2hib3IueDtcbiAgICAgICAgICAgIHkgPSBuZWlnaGJvci55O1xuXG4gICAgICAgICAgICAvLyBnZXQgdGhlIGRpc3RhbmNlIGJldHdlZW4gY3VycmVudCBub2RlIGFuZCB0aGUgbmVpZ2hib3JcbiAgICAgICAgICAgIC8vIGFuZCBjYWxjdWxhdGUgdGhlIG5leHQgZyBzY29yZVxuICAgICAgICAgICAgbmcgPSBub2RlLmcgKyBuZWlnaGJvci5jb3N0ICsgKCh4IC0gbm9kZS54ID09PSAwIHx8IHkgLSBub2RlLnkgPT09IDApID8gMSA6IFNRUlQyKTtcblxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIG5laWdoYm9yIGhhcyBub3QgYmVlbiBpbnNwZWN0ZWQgeWV0LCBvclxuICAgICAgICAgICAgLy8gY2FuIGJlIHJlYWNoZWQgd2l0aCBzbWFsbGVyIGNvc3QgZnJvbSB0aGUgY3VycmVudCBub2RlXG4gICAgICAgICAgICBpZiAoIW5laWdoYm9yLm9wZW5lZCB8fCBuZyA8IG5laWdoYm9yLmcpIHtcbiAgICAgICAgICAgICAgICBuZWlnaGJvci5nID0gbmc7XG4gICAgICAgICAgICAgICAgbmVpZ2hib3IuaCA9IG5laWdoYm9yLmggfHwgd2VpZ2h0ICogaGV1cmlzdGljKGFicyh4IC0gc3RhcnRYKSwgYWJzKHkgLSBzdGFydFkpKTtcbiAgICAgICAgICAgICAgICBuZWlnaGJvci5mID0gbmVpZ2hib3IuZyArIG5laWdoYm9yLmg7XG4gICAgICAgICAgICAgICAgbmVpZ2hib3IucGFyZW50ID0gbm9kZTtcblxuICAgICAgICAgICAgICAgIGlmICghbmVpZ2hib3Iub3BlbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZE9wZW5MaXN0LnB1c2gobmVpZ2hib3IpO1xuICAgICAgICAgICAgICAgICAgICBuZWlnaGJvci5vcGVuZWQgPSBCWV9FTkQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIG5laWdoYm9yIGNhbiBiZSByZWFjaGVkIHdpdGggc21hbGxlciBjb3N0LlxuICAgICAgICAgICAgICAgICAgICAvLyBTaW5jZSBpdHMgZiB2YWx1ZSBoYXMgYmVlbiB1cGRhdGVkLCB3ZSBoYXZlIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBpdHMgcG9zaXRpb24gaW4gdGhlIG9wZW4gbGlzdFxuICAgICAgICAgICAgICAgICAgICBlbmRPcGVuTGlzdC51cGRhdGVJdGVtKG5laWdoYm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gLy8gZW5kIGZvciBlYWNoIG5laWdoYm9yXG4gICAgfSAvLyBlbmQgd2hpbGUgbm90IG9wZW4gbGlzdCBlbXB0eVxuXG4gICAgLy8gZmFpbCB0byBmaW5kIHRoZSBwYXRoXG4gICAgcmV0dXJuIFtdO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCaUFTdGFyRmluZGVyO1xuIiwidmFyIEJpQVN0YXJGaW5kZXIgPSByZXF1aXJlKCcuL0JpQVN0YXJGaW5kZXInKTtcblxuLyoqXG4gKiBCaS1kaXJlY2l0aW9uYWwgQmVzdC1GaXJzdC1TZWFyY2ggcGF0aC1maW5kZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEJpQVN0YXJGaW5kZXJcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0LmFsbG93RGlhZ29uYWwgV2hldGhlciBkaWFnb25hbCBtb3ZlbWVudCBpcyBhbGxvd2VkLiBEZXByZWNhdGVkLCB1c2UgZGlhZ29uYWxNb3ZlbWVudCBpbnN0ZWFkLlxuICogQHBhcmFtIHtib29sZWFufSBvcHQuZG9udENyb3NzQ29ybmVycyBEaXNhbGxvdyBkaWFnb25hbCBtb3ZlbWVudCB0b3VjaGluZyBibG9jayBjb3JuZXJzLiBEZXByZWNhdGVkLCB1c2UgZGlhZ29uYWxNb3ZlbWVudCBpbnN0ZWFkLlxuICogQHBhcmFtIHtEaWFnb25hbE1vdmVtZW50fSBvcHQuZGlhZ29uYWxNb3ZlbWVudCBBbGxvd2VkIGRpYWdvbmFsIG1vdmVtZW50LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0LmhldXJpc3RpYyBIZXVyaXN0aWMgZnVuY3Rpb24gdG8gZXN0aW1hdGUgdGhlIGRpc3RhbmNlXG4gKiAgICAgKGRlZmF1bHRzIHRvIG1hbmhhdHRhbikuXG4gKi9cbmZ1bmN0aW9uIEJpQmVzdEZpcnN0RmluZGVyKG9wdCkge1xuICAgIEJpQVN0YXJGaW5kZXIuY2FsbCh0aGlzLCBvcHQpO1xuXG4gICAgdmFyIG9yaWcgPSB0aGlzLmhldXJpc3RpYztcbiAgICB0aGlzLmhldXJpc3RpYyA9IGZ1bmN0aW9uKGR4LCBkeSkge1xuICAgICAgICByZXR1cm4gb3JpZyhkeCwgZHkpICogMTAwMDAwMDtcbiAgICB9O1xufVxuXG5CaUJlc3RGaXJzdEZpbmRlci5wcm90b3R5cGUgPSBuZXcgQmlBU3RhckZpbmRlcigpO1xuQmlCZXN0Rmlyc3RGaW5kZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQmlCZXN0Rmlyc3RGaW5kZXI7XG5cbm1vZHVsZS5leHBvcnRzID0gQmlCZXN0Rmlyc3RGaW5kZXI7XG4iLCJ2YXIgVXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvVXRpbCcpO1xudmFyIERpYWdvbmFsTW92ZW1lbnQgPSByZXF1aXJlKCcuLi9jb3JlL0RpYWdvbmFsTW92ZW1lbnQnKTtcblxuLyoqXG4gKiBCaS1kaXJlY3Rpb25hbCBCcmVhZHRoLUZpcnN0LVNlYXJjaCBwYXRoIGZpbmRlci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IG9wdFxuICogQHBhcmFtIHtib29sZWFufSBvcHQuYWxsb3dEaWFnb25hbCBXaGV0aGVyIGRpYWdvbmFsIG1vdmVtZW50IGlzIGFsbG93ZWQuIERlcHJlY2F0ZWQsIHVzZSBkaWFnb25hbE1vdmVtZW50IGluc3RlYWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdC5kb250Q3Jvc3NDb3JuZXJzIERpc2FsbG93IGRpYWdvbmFsIG1vdmVtZW50IHRvdWNoaW5nIGJsb2NrIGNvcm5lcnMuIERlcHJlY2F0ZWQsIHVzZSBkaWFnb25hbE1vdmVtZW50IGluc3RlYWQuXG4gKiBAcGFyYW0ge0RpYWdvbmFsTW92ZW1lbnR9IG9wdC5kaWFnb25hbE1vdmVtZW50IEFsbG93ZWQgZGlhZ29uYWwgbW92ZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIEJpQnJlYWR0aEZpcnN0RmluZGVyKG9wdCkge1xuICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICB0aGlzLmFsbG93RGlhZ29uYWwgPSBvcHQuYWxsb3dEaWFnb25hbDtcbiAgICB0aGlzLmRvbnRDcm9zc0Nvcm5lcnMgPSBvcHQuZG9udENyb3NzQ29ybmVycztcbiAgICB0aGlzLmRpYWdvbmFsTW92ZW1lbnQgPSBvcHQuZGlhZ29uYWxNb3ZlbWVudDtcblxuICAgIGlmICghdGhpcy5kaWFnb25hbE1vdmVtZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5hbGxvd0RpYWdvbmFsKSB7XG4gICAgICAgICAgICB0aGlzLmRpYWdvbmFsTW92ZW1lbnQgPSBEaWFnb25hbE1vdmVtZW50Lk5ldmVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuZG9udENyb3NzQ29ybmVycykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlhZ29uYWxNb3ZlbWVudCA9IERpYWdvbmFsTW92ZW1lbnQuT25seVdoZW5Ob09ic3RhY2xlcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaWFnb25hbE1vdmVtZW50ID0gRGlhZ29uYWxNb3ZlbWVudC5JZkF0TW9zdE9uZU9ic3RhY2xlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5cbi8qKlxuICogRmluZCBhbmQgcmV0dXJuIHRoZSB0aGUgcGF0aC5cbiAqIEByZXR1cm4ge0FycmF5LjxbbnVtYmVyLCBudW1iZXJdPn0gVGhlIHBhdGgsIGluY2x1ZGluZyBib3RoIHN0YXJ0IGFuZFxuICogICAgIGVuZCBwb3NpdGlvbnMuXG4gKi9cbkJpQnJlYWR0aEZpcnN0RmluZGVyLnByb3RvdHlwZS5maW5kUGF0aCA9IGZ1bmN0aW9uKHN0YXJ0WCwgc3RhcnRZLCBlbmRYLCBlbmRZLCBncmlkKSB7XG4gICAgdmFyIHN0YXJ0Tm9kZSA9IGdyaWQuZ2V0Tm9kZUF0KHN0YXJ0WCwgc3RhcnRZKSxcbiAgICAgICAgZW5kTm9kZSA9IGdyaWQuZ2V0Tm9kZUF0KGVuZFgsIGVuZFkpLFxuICAgICAgICBzdGFydE9wZW5MaXN0ID0gW10sIGVuZE9wZW5MaXN0ID0gW10sXG4gICAgICAgIG5laWdoYm9ycywgbmVpZ2hib3IsIG5vZGUsXG4gICAgICAgIGRpYWdvbmFsTW92ZW1lbnQgPSB0aGlzLmRpYWdvbmFsTW92ZW1lbnQsXG4gICAgICAgIEJZX1NUQVJUID0gMCwgQllfRU5EID0gMSxcbiAgICAgICAgaSwgbDtcblxuICAgIC8vIHB1c2ggdGhlIHN0YXJ0IGFuZCBlbmQgbm9kZXMgaW50byB0aGUgcXVldWVzXG4gICAgc3RhcnRPcGVuTGlzdC5wdXNoKHN0YXJ0Tm9kZSk7XG4gICAgc3RhcnROb2RlLm9wZW5lZCA9IHRydWU7XG4gICAgc3RhcnROb2RlLmJ5ID0gQllfU1RBUlQ7XG5cbiAgICBlbmRPcGVuTGlzdC5wdXNoKGVuZE5vZGUpO1xuICAgIGVuZE5vZGUub3BlbmVkID0gdHJ1ZTtcbiAgICBlbmROb2RlLmJ5ID0gQllfRU5EO1xuXG4gICAgLy8gd2hpbGUgYm90aCB0aGUgcXVldWVzIGFyZSBub3QgZW1wdHlcbiAgICB3aGlsZSAoc3RhcnRPcGVuTGlzdC5sZW5ndGggJiYgZW5kT3Blbkxpc3QubGVuZ3RoKSB7XG5cbiAgICAgICAgLy8gZXhwYW5kIHN0YXJ0IG9wZW4gbGlzdFxuXG4gICAgICAgIG5vZGUgPSBzdGFydE9wZW5MaXN0LnNoaWZ0KCk7XG4gICAgICAgIG5vZGUuY2xvc2VkID0gdHJ1ZTtcblxuICAgICAgICBuZWlnaGJvcnMgPSBncmlkLmdldE5laWdoYm9ycyhub2RlLCBkaWFnb25hbE1vdmVtZW50KTtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IG5laWdoYm9ycy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIG5laWdoYm9yID0gbmVpZ2hib3JzW2ldO1xuXG4gICAgICAgICAgICBpZiAobmVpZ2hib3IuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmVpZ2hib3Iub3BlbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBub2RlIGhhcyBiZWVuIGluc3BlY3RlZCBieSB0aGUgcmV2ZXJzZWQgc2VhcmNoLFxuICAgICAgICAgICAgICAgIC8vIHRoZW4gYSBwYXRoIGlzIGZvdW5kLlxuICAgICAgICAgICAgICAgIGlmIChuZWlnaGJvci5ieSA9PT0gQllfRU5EKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBVdGlsLmJpQmFja3RyYWNlKG5vZGUsIG5laWdoYm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFydE9wZW5MaXN0LnB1c2gobmVpZ2hib3IpO1xuICAgICAgICAgICAgbmVpZ2hib3IucGFyZW50ID0gbm9kZTtcbiAgICAgICAgICAgIG5laWdoYm9yLm9wZW5lZCA9IHRydWU7XG4gICAgICAgICAgICBuZWlnaGJvci5ieSA9IEJZX1NUQVJUO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZXhwYW5kIGVuZCBvcGVuIGxpc3RcblxuICAgICAgICBub2RlID0gZW5kT3Blbkxpc3Quc2hpZnQoKTtcbiAgICAgICAgbm9kZS5jbG9zZWQgPSB0cnVlO1xuXG4gICAgICAgIG5laWdoYm9ycyA9IGdyaWQuZ2V0TmVpZ2hib3JzKG5vZGUsIGRpYWdvbmFsTW92ZW1lbnQpO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gbmVpZ2hib3JzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgbmVpZ2hib3IgPSBuZWlnaGJvcnNbaV07XG5cbiAgICAgICAgICAgIGlmIChuZWlnaGJvci5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZWlnaGJvci5vcGVuZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAobmVpZ2hib3IuYnkgPT09IEJZX1NUQVJUKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBVdGlsLmJpQmFja3RyYWNlKG5laWdoYm9yLCBub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbmRPcGVuTGlzdC5wdXNoKG5laWdoYm9yKTtcbiAgICAgICAgICAgIG5laWdoYm9yLnBhcmVudCA9IG5vZGU7XG4gICAgICAgICAgICBuZWlnaGJvci5vcGVuZWQgPSB0cnVlO1xuICAgICAgICAgICAgbmVpZ2hib3IuYnkgPSBCWV9FTkQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBmYWlsIHRvIGZpbmQgdGhlIHBhdGhcbiAgICByZXR1cm4gW107XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJpQnJlYWR0aEZpcnN0RmluZGVyO1xuIiwidmFyIEJpQVN0YXJGaW5kZXIgPSByZXF1aXJlKCcuL0JpQVN0YXJGaW5kZXInKTtcblxuLyoqXG4gKiBCaS1kaXJlY3Rpb25hbCBEaWprc3RyYSBwYXRoLWZpbmRlci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQmlBU3RhckZpbmRlclxuICogQHBhcmFtIHtvYmplY3R9IG9wdFxuICogQHBhcmFtIHtib29sZWFufSBvcHQuYWxsb3dEaWFnb25hbCBXaGV0aGVyIGRpYWdvbmFsIG1vdmVtZW50IGlzIGFsbG93ZWQuIERlcHJlY2F0ZWQsIHVzZSBkaWFnb25hbE1vdmVtZW50IGluc3RlYWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdC5kb250Q3Jvc3NDb3JuZXJzIERpc2FsbG93IGRpYWdvbmFsIG1vdmVtZW50IHRvdWNoaW5nIGJsb2NrIGNvcm5lcnMuIERlcHJlY2F0ZWQsIHVzZSBkaWFnb25hbE1vdmVtZW50IGluc3RlYWQuXG4gKiBAcGFyYW0ge0RpYWdvbmFsTW92ZW1lbnR9IG9wdC5kaWFnb25hbE1vdmVtZW50IEFsbG93ZWQgZGlhZ29uYWwgbW92ZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIEJpRGlqa3N0cmFGaW5kZXIob3B0KSB7XG4gICAgQmlBU3RhckZpbmRlci5jYWxsKHRoaXMsIG9wdCk7XG4gICAgdGhpcy5oZXVyaXN0aWMgPSBmdW5jdGlvbihkeCwgZHkpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbn1cblxuQmlEaWprc3RyYUZpbmRlci5wcm90b3R5cGUgPSBuZXcgQmlBU3RhckZpbmRlcigpO1xuQmlEaWprc3RyYUZpbmRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCaURpamtzdHJhRmluZGVyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJpRGlqa3N0cmFGaW5kZXI7XG4iLCJ2YXIgVXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvVXRpbCcpO1xudmFyIERpYWdvbmFsTW92ZW1lbnQgPSByZXF1aXJlKCcuLi9jb3JlL0RpYWdvbmFsTW92ZW1lbnQnKTtcblxuLyoqXG4gKiBCcmVhZHRoLUZpcnN0LVNlYXJjaCBwYXRoIGZpbmRlci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IG9wdFxuICogQHBhcmFtIHtib29sZWFufSBvcHQuYWxsb3dEaWFnb25hbCBXaGV0aGVyIGRpYWdvbmFsIG1vdmVtZW50IGlzIGFsbG93ZWQuIERlcHJlY2F0ZWQsIHVzZSBkaWFnb25hbE1vdmVtZW50IGluc3RlYWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdC5kb250Q3Jvc3NDb3JuZXJzIERpc2FsbG93IGRpYWdvbmFsIG1vdmVtZW50IHRvdWNoaW5nIGJsb2NrIGNvcm5lcnMuIERlcHJlY2F0ZWQsIHVzZSBkaWFnb25hbE1vdmVtZW50IGluc3RlYWQuXG4gKiBAcGFyYW0ge0RpYWdvbmFsTW92ZW1lbnR9IG9wdC5kaWFnb25hbE1vdmVtZW50IEFsbG93ZWQgZGlhZ29uYWwgbW92ZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIEJyZWFkdGhGaXJzdEZpbmRlcihvcHQpIHtcbiAgICBvcHQgPSBvcHQgfHwge307XG4gICAgdGhpcy5hbGxvd0RpYWdvbmFsID0gb3B0LmFsbG93RGlhZ29uYWw7XG4gICAgdGhpcy5kb250Q3Jvc3NDb3JuZXJzID0gb3B0LmRvbnRDcm9zc0Nvcm5lcnM7XG4gICAgdGhpcy5kaWFnb25hbE1vdmVtZW50ID0gb3B0LmRpYWdvbmFsTW92ZW1lbnQ7XG5cbiAgICBpZiAoIXRoaXMuZGlhZ29uYWxNb3ZlbWVudCkge1xuICAgICAgICBpZiAoIXRoaXMuYWxsb3dEaWFnb25hbCkge1xuICAgICAgICAgICAgdGhpcy5kaWFnb25hbE1vdmVtZW50ID0gRGlhZ29uYWxNb3ZlbWVudC5OZXZlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbnRDcm9zc0Nvcm5lcnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpYWdvbmFsTW92ZW1lbnQgPSBEaWFnb25hbE1vdmVtZW50Lk9ubHlXaGVuTm9PYnN0YWNsZXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlhZ29uYWxNb3ZlbWVudCA9IERpYWdvbmFsTW92ZW1lbnQuSWZBdE1vc3RPbmVPYnN0YWNsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBGaW5kIGFuZCByZXR1cm4gdGhlIHRoZSBwYXRoLlxuICogQHJldHVybiB7QXJyYXkuPFtudW1iZXIsIG51bWJlcl0+fSBUaGUgcGF0aCwgaW5jbHVkaW5nIGJvdGggc3RhcnQgYW5kXG4gKiAgICAgZW5kIHBvc2l0aW9ucy5cbiAqL1xuQnJlYWR0aEZpcnN0RmluZGVyLnByb3RvdHlwZS5maW5kUGF0aCA9IGZ1bmN0aW9uKHN0YXJ0WCwgc3RhcnRZLCBlbmRYLCBlbmRZLCBncmlkKSB7XG4gICAgdmFyIG9wZW5MaXN0ID0gW10sXG4gICAgICAgIGRpYWdvbmFsTW92ZW1lbnQgPSB0aGlzLmRpYWdvbmFsTW92ZW1lbnQsXG4gICAgICAgIHN0YXJ0Tm9kZSA9IGdyaWQuZ2V0Tm9kZUF0KHN0YXJ0WCwgc3RhcnRZKSxcbiAgICAgICAgZW5kTm9kZSA9IGdyaWQuZ2V0Tm9kZUF0KGVuZFgsIGVuZFkpLFxuICAgICAgICBuZWlnaGJvcnMsIG5laWdoYm9yLCBub2RlLCBpLCBsO1xuXG4gICAgLy8gcHVzaCB0aGUgc3RhcnQgcG9zIGludG8gdGhlIHF1ZXVlXG4gICAgb3Blbkxpc3QucHVzaChzdGFydE5vZGUpO1xuICAgIHN0YXJ0Tm9kZS5vcGVuZWQgPSB0cnVlO1xuXG4gICAgLy8gd2hpbGUgdGhlIHF1ZXVlIGlzIG5vdCBlbXB0eVxuICAgIHdoaWxlIChvcGVuTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgLy8gdGFrZSB0aGUgZnJvbnQgbm9kZSBmcm9tIHRoZSBxdWV1ZVxuICAgICAgICBub2RlID0gb3Blbkxpc3Quc2hpZnQoKTtcbiAgICAgICAgbm9kZS5jbG9zZWQgPSB0cnVlO1xuXG4gICAgICAgIC8vIHJlYWNoZWQgdGhlIGVuZCBwb3NpdGlvblxuICAgICAgICBpZiAobm9kZSA9PT0gZW5kTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIFV0aWwuYmFja3RyYWNlKGVuZE5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmVpZ2hib3JzID0gZ3JpZC5nZXROZWlnaGJvcnMobm9kZSwgZGlhZ29uYWxNb3ZlbWVudCk7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBuZWlnaGJvcnMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBuZWlnaGJvciA9IG5laWdoYm9yc1tpXTtcblxuICAgICAgICAgICAgLy8gc2tpcCB0aGlzIG5laWdoYm9yIGlmIGl0IGhhcyBiZWVuIGluc3BlY3RlZCBiZWZvcmVcbiAgICAgICAgICAgIGlmIChuZWlnaGJvci5jbG9zZWQgfHwgbmVpZ2hib3Iub3BlbmVkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9wZW5MaXN0LnB1c2gobmVpZ2hib3IpO1xuICAgICAgICAgICAgbmVpZ2hib3Iub3BlbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIG5laWdoYm9yLnBhcmVudCA9IG5vZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gZmFpbCB0byBmaW5kIHRoZSBwYXRoXG4gICAgcmV0dXJuIFtdO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCcmVhZHRoRmlyc3RGaW5kZXI7XG4iLCJ2YXIgQVN0YXJGaW5kZXIgPSByZXF1aXJlKCcuL0FTdGFyRmluZGVyJyk7XG5cbi8qKlxuICogRGlqa3N0cmEgcGF0aC1maW5kZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEFTdGFyRmluZGVyXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdC5hbGxvd0RpYWdvbmFsIFdoZXRoZXIgZGlhZ29uYWwgbW92ZW1lbnQgaXMgYWxsb3dlZC4gRGVwcmVjYXRlZCwgdXNlIGRpYWdvbmFsTW92ZW1lbnQgaW5zdGVhZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0LmRvbnRDcm9zc0Nvcm5lcnMgRGlzYWxsb3cgZGlhZ29uYWwgbW92ZW1lbnQgdG91Y2hpbmcgYmxvY2sgY29ybmVycy4gRGVwcmVjYXRlZCwgdXNlIGRpYWdvbmFsTW92ZW1lbnQgaW5zdGVhZC5cbiAqIEBwYXJhbSB7RGlhZ29uYWxNb3ZlbWVudH0gb3B0LmRpYWdvbmFsTW92ZW1lbnQgQWxsb3dlZCBkaWFnb25hbCBtb3ZlbWVudC5cbiAqL1xuZnVuY3Rpb24gRGlqa3N0cmFGaW5kZXIob3B0KSB7XG4gICAgQVN0YXJGaW5kZXIuY2FsbCh0aGlzLCBvcHQpO1xuICAgIHRoaXMuaGV1cmlzdGljID0gZnVuY3Rpb24oZHgsIGR5KSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH07XG59XG5cbkRpamtzdHJhRmluZGVyLnByb3RvdHlwZSA9IG5ldyBBU3RhckZpbmRlcigpO1xuRGlqa3N0cmFGaW5kZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRGlqa3N0cmFGaW5kZXI7XG5cbm1vZHVsZS5leHBvcnRzID0gRGlqa3N0cmFGaW5kZXI7XG4iLCJ2YXIgVXRpbCAgICAgICA9IHJlcXVpcmUoJy4uL2NvcmUvVXRpbCcpO1xudmFyIEhldXJpc3RpYyAgPSByZXF1aXJlKCcuLi9jb3JlL0hldXJpc3RpYycpO1xudmFyIE5vZGUgICAgICAgPSByZXF1aXJlKCcuLi9jb3JlL05vZGUnKTtcbnZhciBEaWFnb25hbE1vdmVtZW50ID0gcmVxdWlyZSgnLi4vY29yZS9EaWFnb25hbE1vdmVtZW50Jyk7XG5cbi8qKlxuICogSXRlcmF0aXZlIERlZXBpbmcgQSBTdGFyIChJREEqKSBwYXRoLWZpbmRlci5cbiAqXG4gKiBSZWN1cnNpb24gYmFzZWQgb246XG4gKiAgIGh0dHA6Ly93d3cuYXBsLmpodS5lZHUvfmhhbGwvQUktUHJvZ3JhbW1pbmcvSURBLVN0YXIuaHRtbFxuICpcbiAqIFBhdGggcmV0cmFjaW5nIGJhc2VkIG9uOlxuICogIFYuIE5hZ2VzaHdhcmEgUmFvLCBWaXBpbiBLdW1hciBhbmQgSy4gUmFtZXNoXG4gKiAgXCJBIFBhcmFsbGVsIEltcGxlbWVudGF0aW9uIG9mIEl0ZXJhdGl2ZS1EZWVwaW5nLUEqXCIsIEphbnVhcnkgMTk4Ny5cbiAqICBmdHA6Ly9mdHAuY3MudXRleGFzLmVkdS8uc25hcHNob3QvaG91cmx5LjEvcHViL0FJLUxhYi90ZWNoLXJlcG9ydHMvVVQtQUktVFItODctNDYucGRmXG4gKlxuICogQGF1dGhvciBHZXJhcmQgTWVpZXIgKHd3dy5nZXJhcmRtZWllci5jb20pXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdC5hbGxvd0RpYWdvbmFsIFdoZXRoZXIgZGlhZ29uYWwgbW92ZW1lbnQgaXMgYWxsb3dlZC4gRGVwcmVjYXRlZCwgdXNlIGRpYWdvbmFsTW92ZW1lbnQgaW5zdGVhZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0LmRvbnRDcm9zc0Nvcm5lcnMgRGlzYWxsb3cgZGlhZ29uYWwgbW92ZW1lbnQgdG91Y2hpbmcgYmxvY2sgY29ybmVycy4gRGVwcmVjYXRlZCwgdXNlIGRpYWdvbmFsTW92ZW1lbnQgaW5zdGVhZC5cbiAqIEBwYXJhbSB7RGlhZ29uYWxNb3ZlbWVudH0gb3B0LmRpYWdvbmFsTW92ZW1lbnQgQWxsb3dlZCBkaWFnb25hbCBtb3ZlbWVudC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9wdC5oZXVyaXN0aWMgSGV1cmlzdGljIGZ1bmN0aW9uIHRvIGVzdGltYXRlIHRoZSBkaXN0YW5jZVxuICogICAgIChkZWZhdWx0cyB0byBtYW5oYXR0YW4pLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBvcHQud2VpZ2h0IFdlaWdodCB0byBhcHBseSB0byB0aGUgaGV1cmlzdGljIHRvIGFsbG93IGZvciBzdWJvcHRpbWFsIHBhdGhzLFxuICogICAgIGluIG9yZGVyIHRvIHNwZWVkIHVwIHRoZSBzZWFyY2guXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0LnRyYWNrUmVjdXJzaW9uIFdoZXRoZXIgdG8gdHJhY2sgcmVjdXJzaW9uIGZvciBzdGF0aXN0aWNhbCBwdXJwb3Nlcy5cbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHQudGltZUxpbWl0IE1heGltdW0gZXhlY3V0aW9uIHRpbWUuIFVzZSA8PSAwIGZvciBpbmZpbml0ZS5cbiAqL1xuXG5mdW5jdGlvbiBJREFTdGFyRmluZGVyKG9wdCkge1xuICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICB0aGlzLmFsbG93RGlhZ29uYWwgPSBvcHQuYWxsb3dEaWFnb25hbDtcbiAgICB0aGlzLmRvbnRDcm9zc0Nvcm5lcnMgPSBvcHQuZG9udENyb3NzQ29ybmVycztcbiAgICB0aGlzLmRpYWdvbmFsTW92ZW1lbnQgPSBvcHQuZGlhZ29uYWxNb3ZlbWVudDtcbiAgICB0aGlzLmhldXJpc3RpYyA9IG9wdC5oZXVyaXN0aWMgfHwgSGV1cmlzdGljLm1hbmhhdHRhbjtcbiAgICB0aGlzLndlaWdodCA9IG9wdC53ZWlnaHQgfHwgMTtcbiAgICB0aGlzLnRyYWNrUmVjdXJzaW9uID0gb3B0LnRyYWNrUmVjdXJzaW9uIHx8IGZhbHNlO1xuICAgIHRoaXMudGltZUxpbWl0ID0gb3B0LnRpbWVMaW1pdCB8fCBJbmZpbml0eTsgLy8gRGVmYXVsdDogbm8gdGltZSBsaW1pdC5cblxuICAgIGlmICghdGhpcy5kaWFnb25hbE1vdmVtZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5hbGxvd0RpYWdvbmFsKSB7XG4gICAgICAgICAgICB0aGlzLmRpYWdvbmFsTW92ZW1lbnQgPSBEaWFnb25hbE1vdmVtZW50Lk5ldmVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuZG9udENyb3NzQ29ybmVycykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlhZ29uYWxNb3ZlbWVudCA9IERpYWdvbmFsTW92ZW1lbnQuT25seVdoZW5Ob09ic3RhY2xlcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaWFnb25hbE1vdmVtZW50ID0gRGlhZ29uYWxNb3ZlbWVudC5JZkF0TW9zdE9uZU9ic3RhY2xlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy9XaGVuIGRpYWdvbmFsIG1vdmVtZW50IGlzIGFsbG93ZWQgdGhlIG1hbmhhdHRhbiBoZXVyaXN0aWMgaXMgbm90IGFkbWlzc2libGVcbiAgICAvL0l0IHNob3VsZCBiZSBvY3RpbGUgaW5zdGVhZFxuICAgIGlmICh0aGlzLmRpYWdvbmFsTW92ZW1lbnQgPT09IERpYWdvbmFsTW92ZW1lbnQuTmV2ZXIpIHtcbiAgICAgICAgdGhpcy5oZXVyaXN0aWMgPSBvcHQuaGV1cmlzdGljIHx8IEhldXJpc3RpYy5tYW5oYXR0YW47XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oZXVyaXN0aWMgPSBvcHQuaGV1cmlzdGljIHx8IEhldXJpc3RpYy5vY3RpbGU7XG4gICAgfVxufVxuXG4vKipcbiAqIEZpbmQgYW5kIHJldHVybiB0aGUgdGhlIHBhdGguIFdoZW4gYW4gZW1wdHkgYXJyYXkgaXMgcmV0dXJuZWQsIGVpdGhlclxuICogbm8gcGF0aCBpcyBwb3NzaWJsZSwgb3IgdGhlIG1heGltdW0gZXhlY3V0aW9uIHRpbWUgaXMgcmVhY2hlZC5cbiAqXG4gKiBAcmV0dXJuIHtBcnJheS48W251bWJlciwgbnVtYmVyXT59IFRoZSBwYXRoLCBpbmNsdWRpbmcgYm90aCBzdGFydCBhbmRcbiAqICAgICBlbmQgcG9zaXRpb25zLlxuICovXG5JREFTdGFyRmluZGVyLnByb3RvdHlwZS5maW5kUGF0aCA9IGZ1bmN0aW9uKHN0YXJ0WCwgc3RhcnRZLCBlbmRYLCBlbmRZLCBncmlkKSB7XG4gICAgLy8gVXNlZCBmb3Igc3RhdGlzdGljczpcbiAgICB2YXIgbm9kZXNWaXNpdGVkID0gMDtcblxuICAgIC8vIEV4ZWN1dGlvbiB0aW1lIGxpbWl0YXRpb246XG4gICAgdmFyIHN0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gICAgLy8gSGV1cmlzdGljIGhlbHBlcjpcbiAgICB2YXIgaCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGV1cmlzdGljKE1hdGguYWJzKGIueCAtIGEueCksIE1hdGguYWJzKGIueSAtIGEueSkpO1xuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIC8vIFN0ZXAgY29zdCBmcm9tIGEgdG8gYjpcbiAgICB2YXIgY29zdCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIChhLnggPT09IGIueCB8fCBhLnkgPT09IGIueSkgPyAxIDogTWF0aC5TUVJUMjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSURBKiBzZWFyY2ggaW1wbGVtZW50YXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IFRoZSBub2RlIGN1cnJlbnRseSBleHBhbmRpbmcgZnJvbS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gQ29zdCB0byByZWFjaCB0aGUgZ2l2ZW4gbm9kZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gTWF4aW11bSBzZWFyY2ggZGVwdGggKGN1dC1vZmYgdmFsdWUpLlxuICAgICAqIEBwYXJhbSB7e0FycmF5LjxbbnVtYmVyLCBudW1iZXJdPn19IFRoZSBmb3VuZCByb3V0ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gUmVjdXJzaW9uIGRlcHRoLlxuICAgICAqXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBlaXRoZXIgYSBudW1iZXIgd2l0aCB0aGUgbmV3IG9wdGltYWwgY3V0LW9mZiBkZXB0aCxcbiAgICAgKiBvciBhIHZhbGlkIG5vZGUgaW5zdGFuY2UsIGluIHdoaWNoIGNhc2UgYSBwYXRoIHdhcyBmb3VuZC5cbiAgICAgKi9cbiAgICB2YXIgc2VhcmNoID0gZnVuY3Rpb24obm9kZSwgZywgY3V0b2ZmLCByb3V0ZSwgZGVwdGgpIHtcbiAgICAgICAgbm9kZXNWaXNpdGVkKys7XG5cbiAgICAgICAgLy8gRW5mb3JjZSB0aW1lbGltaXQ6XG4gICAgICAgIGlmKHRoaXMudGltZUxpbWl0ID4gMCAmJiBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHN0YXJ0VGltZSA+IHRoaXMudGltZUxpbWl0ICogMTAwMCkge1xuICAgICAgICAgICAgLy8gRW5mb3JjZWQgYXMgXCJwYXRoLW5vdC1mb3VuZFwiLlxuICAgICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGYgPSBnICsgaChub2RlLCBlbmQpICogdGhpcy53ZWlnaHQ7XG5cbiAgICAgICAgLy8gV2UndmUgc2VhcmNoZWQgdG9vIGRlZXAgZm9yIHRoaXMgaXRlcmF0aW9uLlxuICAgICAgICBpZihmID4gY3V0b2ZmKSB7XG4gICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKG5vZGUgPT0gZW5kKSB7XG4gICAgICAgICAgICByb3V0ZVtkZXB0aF0gPSBbbm9kZS54LCBub2RlLnldO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWluLCB0LCBrLCBuZWlnaGJvdXI7XG5cbiAgICAgICAgdmFyIG5laWdoYm91cnMgPSBncmlkLmdldE5laWdoYm9ycyhub2RlLCB0aGlzLmRpYWdvbmFsTW92ZW1lbnQpO1xuXG4gICAgICAgIC8vIFNvcnQgdGhlIG5laWdoYm91cnMsIGdpdmVzIG5pY2VyIHBhdGhzLiBCdXQsIHRoaXMgZGV2aWF0ZXNcbiAgICAgICAgLy8gZnJvbSB0aGUgb3JpZ2luYWwgYWxnb3JpdGhtIC0gc28gSSBsZWZ0IGl0IG91dC5cbiAgICAgICAgLy9uZWlnaGJvdXJzLnNvcnQoZnVuY3Rpb24oYSwgYil7XG4gICAgICAgIC8vICAgIHJldHVybiBoKGEsIGVuZCkgLSBoKGIsIGVuZCk7XG4gICAgICAgIC8vfSk7XG5cbiAgICAgICAgXG4gICAgICAgIC8qanNoaW50IC1XMDg0ICovLy9EaXNhYmxlIHdhcm5pbmc6IEV4cGVjdGVkIGEgY29uZGl0aW9uYWwgZXhwcmVzc2lvbiBhbmQgaW5zdGVhZCBzYXcgYW4gYXNzaWdubWVudFxuICAgICAgICBmb3IoayA9IDAsIG1pbiA9IEluZmluaXR5OyBuZWlnaGJvdXIgPSBuZWlnaGJvdXJzW2tdOyArK2spIHtcbiAgICAgICAgLypqc2hpbnQgK1cwODQgKi8vL0VuYWJsZSB3YXJuaW5nOiBFeHBlY3RlZCBhIGNvbmRpdGlvbmFsIGV4cHJlc3Npb24gYW5kIGluc3RlYWQgc2F3IGFuIGFzc2lnbm1lbnRcbiAgICAgICAgICAgIGlmKHRoaXMudHJhY2tSZWN1cnNpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBSZXRhaW4gYSBjb3B5IGZvciB2aXN1YWxpc2F0aW9uLiBEdWUgdG8gcmVjdXJzaW9uLCB0aGlzXG4gICAgICAgICAgICAgICAgLy8gbm9kZSBtYXkgYmUgcGFydCBvZiBvdGhlciBwYXRocyB0b28uXG4gICAgICAgICAgICAgICAgbmVpZ2hib3VyLnJldGFpbkNvdW50ID0gbmVpZ2hib3VyLnJldGFpbkNvdW50ICsgMSB8fCAxO1xuXG4gICAgICAgICAgICAgICAgaWYobmVpZ2hib3VyLnRlc3RlZCAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBuZWlnaGJvdXIudGVzdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHQgPSBzZWFyY2gobmVpZ2hib3VyLCBnICsgY29zdChub2RlLCBuZWlnaGJvdXIpLCBjdXRvZmYsIHJvdXRlLCBkZXB0aCArIDEpO1xuXG4gICAgICAgICAgICBpZih0IGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgICAgICAgICAgIHJvdXRlW2RlcHRoXSA9IFtub2RlLngsIG5vZGUueV07XG5cbiAgICAgICAgICAgICAgICAvLyBGb3IgYSB0eXBpY2FsIEEqIGxpbmtlZCBsaXN0LCB0aGlzIHdvdWxkIHdvcms6XG4gICAgICAgICAgICAgICAgLy8gbmVpZ2hib3VyLnBhcmVudCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERlY3JlbWVudCBjb3VudCwgdGhlbiBkZXRlcm1pbmUgd2hldGhlciBpdCdzIGFjdHVhbGx5IGNsb3NlZC5cbiAgICAgICAgICAgIGlmKHRoaXMudHJhY2tSZWN1cnNpb24gJiYgKC0tbmVpZ2hib3VyLnJldGFpbkNvdW50KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG5laWdoYm91ci50ZXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYodCA8IG1pbikge1xuICAgICAgICAgICAgICAgIG1pbiA9IHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWluO1xuXG4gICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgLy8gTm9kZSBpbnN0YW5jZSBsb29rdXBzOlxuICAgIHZhciBzdGFydCA9IGdyaWQuZ2V0Tm9kZUF0KHN0YXJ0WCwgc3RhcnRZKTtcbiAgICB2YXIgZW5kICAgPSBncmlkLmdldE5vZGVBdChlbmRYLCBlbmRZKTtcblxuICAgIC8vIEluaXRpYWwgc2VhcmNoIGRlcHRoLCBnaXZlbiB0aGUgdHlwaWNhbCBoZXVyaXN0aWMgY29udHJhaW50cyxcbiAgICAvLyB0aGVyZSBzaG91bGQgYmUgbm8gY2hlYXBlciByb3V0ZSBwb3NzaWJsZS5cbiAgICB2YXIgY3V0T2ZmID0gaChzdGFydCwgZW5kKTtcblxuICAgIHZhciBqLCByb3V0ZSwgdDtcblxuICAgIC8vIFdpdGggYW4gb3ZlcmZsb3cgcHJvdGVjdGlvbi5cbiAgICBmb3IoaiA9IDA7IHRydWU7ICsraikge1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiSXRlcmF0aW9uOiBcIiArIGogKyBcIiwgc2VhcmNoIGN1dC1vZmYgdmFsdWU6IFwiICsgY3V0T2ZmICsgXCIsIG5vZGVzIHZpc2l0ZWQgdGh1cyBmYXI6IFwiICsgbm9kZXNWaXNpdGVkICsgXCIuXCIpO1xuXG4gICAgICAgIHJvdXRlID0gW107XG5cbiAgICAgICAgLy8gU2VhcmNoIHRpbGwgY3V0LW9mZiBkZXB0aDpcbiAgICAgICAgdCA9IHNlYXJjaChzdGFydCwgMCwgY3V0T2ZmLCByb3V0ZSwgMCk7XG5cbiAgICAgICAgLy8gUm91dGUgbm90IHBvc3NpYmxlLCBvciBub3QgZm91bmQgaW4gdGltZSBsaW1pdC5cbiAgICAgICAgaWYodCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHQgaXMgYSBub2RlLCBpdCdzIGFsc28gdGhlIGVuZCBub2RlLiBSb3V0ZSBpcyBub3dcbiAgICAgICAgLy8gcG9wdWxhdGVkIHdpdGggYSB2YWxpZCBwYXRoIHRvIHRoZSBlbmQgbm9kZS5cbiAgICAgICAgaWYodCBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJGaW5pc2hlZCBhdCBpdGVyYXRpb246IFwiICsgaiArIFwiLCBzZWFyY2ggY3V0LW9mZiB2YWx1ZTogXCIgKyBjdXRPZmYgKyBcIiwgbm9kZXMgdmlzaXRlZDogXCIgKyBub2Rlc1Zpc2l0ZWQgKyBcIi5cIik7XG4gICAgICAgICAgICByZXR1cm4gcm91dGU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcnkgYWdhaW4sIHRoaXMgdGltZSB3aXRoIGEgZGVlcGVyIGN1dC1vZmYuIFRoZSB0IHNjb3JlXG4gICAgICAgIC8vIGlzIHRoZSBjbG9zZXN0IHdlIGdvdCB0byB0aGUgZW5kIG5vZGUuXG4gICAgICAgIGN1dE9mZiA9IHQ7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBfc2hvdWxkXyBuZXZlciB0byBiZSByZWFjaGVkLlxuICAgIHJldHVybiBbXTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSURBU3RhckZpbmRlcjtcbiIsIi8qKlxuICogQGF1dGhvciBpbW9yIC8gaHR0cHM6Ly9naXRodWIuY29tL2ltb3JcbiAqL1xudmFyIEp1bXBQb2ludEZpbmRlckJhc2UgPSByZXF1aXJlKCcuL0p1bXBQb2ludEZpbmRlckJhc2UnKTtcbnZhciBEaWFnb25hbE1vdmVtZW50ID0gcmVxdWlyZSgnLi4vY29yZS9EaWFnb25hbE1vdmVtZW50Jyk7XG5cbi8qKlxuICogUGF0aCBmaW5kZXIgdXNpbmcgdGhlIEp1bXAgUG9pbnQgU2VhcmNoIGFsZ29yaXRobSB3aGljaCBhbHdheXMgbW92ZXNcbiAqIGRpYWdvbmFsbHkgaXJyZXNwZWN0aXZlIG9mIHRoZSBudW1iZXIgb2Ygb2JzdGFjbGVzLlxuICovXG5mdW5jdGlvbiBKUEZBbHdheXNNb3ZlRGlhZ29uYWxseShvcHQpIHtcbiAgICBKdW1wUG9pbnRGaW5kZXJCYXNlLmNhbGwodGhpcywgb3B0KTtcbn1cblxuSlBGQWx3YXlzTW92ZURpYWdvbmFsbHkucHJvdG90eXBlID0gbmV3IEp1bXBQb2ludEZpbmRlckJhc2UoKTtcbkpQRkFsd2F5c01vdmVEaWFnb25hbGx5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEpQRkFsd2F5c01vdmVEaWFnb25hbGx5O1xuXG4vKipcbiAqIFNlYXJjaCByZWN1cnNpdmVseSBpbiB0aGUgZGlyZWN0aW9uIChwYXJlbnQgLT4gY2hpbGQpLCBzdG9wcGluZyBvbmx5IHdoZW4gYVxuICoganVtcCBwb2ludCBpcyBmb3VuZC5cbiAqIEBwcm90ZWN0ZWRcbiAqIEByZXR1cm4ge0FycmF5LjxbbnVtYmVyLCBudW1iZXJdPn0gVGhlIHgsIHkgY29vcmRpbmF0ZSBvZiB0aGUganVtcCBwb2ludFxuICogICAgIGZvdW5kLCBvciBudWxsIGlmIG5vdCBmb3VuZFxuICovXG5KUEZBbHdheXNNb3ZlRGlhZ29uYWxseS5wcm90b3R5cGUuX2p1bXAgPSBmdW5jdGlvbih4LCB5LCBweCwgcHkpIHtcbiAgICB2YXIgZ3JpZCA9IHRoaXMuZ3JpZCxcbiAgICAgICAgZHggPSB4IC0gcHgsIGR5ID0geSAtIHB5O1xuXG4gICAgaWYgKCFncmlkLmlzV2Fsa2FibGVBdCh4LCB5KSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZih0aGlzLnRyYWNrSnVtcFJlY3Vyc2lvbiA9PT0gdHJ1ZSkge1xuICAgICAgICBncmlkLmdldE5vZGVBdCh4LCB5KS50ZXN0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChncmlkLmdldE5vZGVBdCh4LCB5KSA9PT0gdGhpcy5lbmROb2RlKSB7XG4gICAgICAgIHJldHVybiBbeCwgeV07XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgZm9yIGZvcmNlZCBuZWlnaGJvcnNcbiAgICAvLyBhbG9uZyB0aGUgZGlhZ29uYWxcbiAgICBpZiAoZHggIT09IDAgJiYgZHkgIT09IDApIHtcbiAgICAgICAgaWYgKChncmlkLmlzV2Fsa2FibGVBdCh4IC0gZHgsIHkgKyBkeSkgJiYgIWdyaWQuaXNXYWxrYWJsZUF0KHggLSBkeCwgeSkpIHx8XG4gICAgICAgICAgICAoZ3JpZC5pc1dhbGthYmxlQXQoeCArIGR4LCB5IC0gZHkpICYmICFncmlkLmlzV2Fsa2FibGVBdCh4LCB5IC0gZHkpKSkge1xuICAgICAgICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICAgICAgfVxuICAgICAgICAvLyB3aGVuIG1vdmluZyBkaWFnb25hbGx5LCBtdXN0IGNoZWNrIGZvciB2ZXJ0aWNhbC9ob3Jpem9udGFsIGp1bXAgcG9pbnRzXG4gICAgICAgIGlmICh0aGlzLl9qdW1wKHggKyBkeCwgeSwgeCwgeSkgfHwgdGhpcy5fanVtcCh4LCB5ICsgZHksIHgsIHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gW3gsIHldO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGhvcml6b250YWxseS92ZXJ0aWNhbGx5XG4gICAgZWxzZSB7XG4gICAgICAgIGlmKCBkeCAhPT0gMCApIHsgLy8gbW92aW5nIGFsb25nIHhcbiAgICAgICAgICAgIGlmKChncmlkLmlzV2Fsa2FibGVBdCh4ICsgZHgsIHkgKyAxKSAmJiAhZ3JpZC5pc1dhbGthYmxlQXQoeCwgeSArIDEpKSB8fFxuICAgICAgICAgICAgICAgKGdyaWQuaXNXYWxrYWJsZUF0KHggKyBkeCwgeSAtIDEpICYmICFncmlkLmlzV2Fsa2FibGVBdCh4LCB5IC0gMSkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmKChncmlkLmlzV2Fsa2FibGVBdCh4ICsgMSwgeSArIGR5KSAmJiAhZ3JpZC5pc1dhbGthYmxlQXQoeCArIDEsIHkpKSB8fFxuICAgICAgICAgICAgICAgKGdyaWQuaXNXYWxrYWJsZUF0KHggLSAxLCB5ICsgZHkpICYmICFncmlkLmlzV2Fsa2FibGVBdCh4IC0gMSwgeSkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9qdW1wKHggKyBkeCwgeSArIGR5LCB4LCB5KTtcbn07XG5cbi8qKlxuICogRmluZCB0aGUgbmVpZ2hib3JzIGZvciB0aGUgZ2l2ZW4gbm9kZS4gSWYgdGhlIG5vZGUgaGFzIGEgcGFyZW50LFxuICogcHJ1bmUgdGhlIG5laWdoYm9ycyBiYXNlZCBvbiB0aGUganVtcCBwb2ludCBzZWFyY2ggYWxnb3JpdGhtLCBvdGhlcndpc2VcbiAqIHJldHVybiBhbGwgYXZhaWxhYmxlIG5laWdoYm9ycy5cbiAqIEByZXR1cm4ge0FycmF5LjxbbnVtYmVyLCBudW1iZXJdPn0gVGhlIG5laWdoYm9ycyBmb3VuZC5cbiAqL1xuSlBGQWx3YXlzTW92ZURpYWdvbmFsbHkucHJvdG90eXBlLl9maW5kTmVpZ2hib3JzID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHZhciBwYXJlbnQgPSBub2RlLnBhcmVudCxcbiAgICAgICAgeCA9IG5vZGUueCwgeSA9IG5vZGUueSxcbiAgICAgICAgZ3JpZCA9IHRoaXMuZ3JpZCxcbiAgICAgICAgcHgsIHB5LCBueCwgbnksIGR4LCBkeSxcbiAgICAgICAgbmVpZ2hib3JzID0gW10sIG5laWdoYm9yTm9kZXMsIG5laWdoYm9yTm9kZSwgaSwgbDtcblxuICAgIC8vIGRpcmVjdGVkIHBydW5pbmc6IGNhbiBpZ25vcmUgbW9zdCBuZWlnaGJvcnMsIHVubGVzcyBmb3JjZWQuXG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgICBweCA9IHBhcmVudC54O1xuICAgICAgICBweSA9IHBhcmVudC55O1xuICAgICAgICAvLyBnZXQgdGhlIG5vcm1hbGl6ZWQgZGlyZWN0aW9uIG9mIHRyYXZlbFxuICAgICAgICBkeCA9ICh4IC0gcHgpIC8gTWF0aC5tYXgoTWF0aC5hYnMoeCAtIHB4KSwgMSk7XG4gICAgICAgIGR5ID0gKHkgLSBweSkgLyBNYXRoLm1heChNYXRoLmFicyh5IC0gcHkpLCAxKTtcblxuICAgICAgICAvLyBzZWFyY2ggZGlhZ29uYWxseVxuICAgICAgICBpZiAoZHggIT09IDAgJiYgZHkgIT09IDApIHtcbiAgICAgICAgICAgIGlmIChncmlkLmlzV2Fsa2FibGVBdCh4LCB5ICsgZHkpKSB7XG4gICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3gsIHkgKyBkeV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyaWQuaXNXYWxrYWJsZUF0KHggKyBkeCwgeSkpIHtcbiAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCArIGR4LCB5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JpZC5pc1dhbGthYmxlQXQoeCArIGR4LCB5ICsgZHkpKSB7XG4gICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3ggKyBkeCwgeSArIGR5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWdyaWQuaXNXYWxrYWJsZUF0KHggLSBkeCwgeSkpIHtcbiAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCAtIGR4LCB5ICsgZHldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZ3JpZC5pc1dhbGthYmxlQXQoeCwgeSAtIGR5KSkge1xuICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKFt4ICsgZHgsIHkgLSBkeV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHNlYXJjaCBob3Jpem9udGFsbHkvdmVydGljYWxseVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmKGR4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdyaWQuaXNXYWxrYWJsZUF0KHgsIHkgKyBkeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3gsIHkgKyBkeV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWdyaWQuaXNXYWxrYWJsZUF0KHggKyAxLCB5KSkge1xuICAgICAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCArIDEsIHkgKyBkeV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWdyaWQuaXNXYWxrYWJsZUF0KHggLSAxLCB5KSkge1xuICAgICAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCAtIDEsIHkgKyBkeV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChncmlkLmlzV2Fsa2FibGVBdCh4ICsgZHgsIHkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKFt4ICsgZHgsIHldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFncmlkLmlzV2Fsa2FibGVBdCh4LCB5ICsgMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3ggKyBkeCwgeSArIDFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFncmlkLmlzV2Fsa2FibGVBdCh4LCB5IC0gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3ggKyBkeCwgeSAtIDFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gcmV0dXJuIGFsbCBuZWlnaGJvcnNcbiAgICBlbHNlIHtcbiAgICAgICAgbmVpZ2hib3JOb2RlcyA9IGdyaWQuZ2V0TmVpZ2hib3JzKG5vZGUsIERpYWdvbmFsTW92ZW1lbnQuQWx3YXlzKTtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IG5laWdoYm9yTm9kZXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBuZWlnaGJvck5vZGUgPSBuZWlnaGJvck5vZGVzW2ldO1xuICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW25laWdoYm9yTm9kZS54LCBuZWlnaGJvck5vZGUueV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5laWdoYm9ycztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSlBGQWx3YXlzTW92ZURpYWdvbmFsbHk7XG4iLCIvKipcbiAqIEBhdXRob3IgaW1vciAvIGh0dHBzOi8vZ2l0aHViLmNvbS9pbW9yXG4gKi9cbnZhciBKdW1wUG9pbnRGaW5kZXJCYXNlID0gcmVxdWlyZSgnLi9KdW1wUG9pbnRGaW5kZXJCYXNlJyk7XG52YXIgRGlhZ29uYWxNb3ZlbWVudCA9IHJlcXVpcmUoJy4uL2NvcmUvRGlhZ29uYWxNb3ZlbWVudCcpO1xuXG4vKipcbiAqIFBhdGggZmluZGVyIHVzaW5nIHRoZSBKdW1wIFBvaW50IFNlYXJjaCBhbGdvcml0aG0gd2hpY2ggbW92ZXNcbiAqIGRpYWdvbmFsbHkgb25seSB3aGVuIHRoZXJlIGlzIGF0IG1vc3Qgb25lIG9ic3RhY2xlLlxuICovXG5mdW5jdGlvbiBKUEZNb3ZlRGlhZ29uYWxseUlmQXRNb3N0T25lT2JzdGFjbGUob3B0KSB7XG4gICAgSnVtcFBvaW50RmluZGVyQmFzZS5jYWxsKHRoaXMsIG9wdCk7XG59XG5cbkpQRk1vdmVEaWFnb25hbGx5SWZBdE1vc3RPbmVPYnN0YWNsZS5wcm90b3R5cGUgPSBuZXcgSnVtcFBvaW50RmluZGVyQmFzZSgpO1xuSlBGTW92ZURpYWdvbmFsbHlJZkF0TW9zdE9uZU9ic3RhY2xlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEpQRk1vdmVEaWFnb25hbGx5SWZBdE1vc3RPbmVPYnN0YWNsZTtcblxuLyoqXG4gKiBTZWFyY2ggcmVjdXJzaXZlbHkgaW4gdGhlIGRpcmVjdGlvbiAocGFyZW50IC0+IGNoaWxkKSwgc3RvcHBpbmcgb25seSB3aGVuIGFcbiAqIGp1bXAgcG9pbnQgaXMgZm91bmQuXG4gKiBAcHJvdGVjdGVkXG4gKiBAcmV0dXJuIHtBcnJheS48W251bWJlciwgbnVtYmVyXT59IFRoZSB4LCB5IGNvb3JkaW5hdGUgb2YgdGhlIGp1bXAgcG9pbnRcbiAqICAgICBmb3VuZCwgb3IgbnVsbCBpZiBub3QgZm91bmRcbiAqL1xuSlBGTW92ZURpYWdvbmFsbHlJZkF0TW9zdE9uZU9ic3RhY2xlLnByb3RvdHlwZS5fanVtcCA9IGZ1bmN0aW9uKHgsIHksIHB4LCBweSkge1xuICAgIHZhciBncmlkID0gdGhpcy5ncmlkLFxuICAgICAgICBkeCA9IHggLSBweCwgZHkgPSB5IC0gcHk7XG5cbiAgICBpZiAoIWdyaWQuaXNXYWxrYWJsZUF0KHgsIHkpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmKHRoaXMudHJhY2tKdW1wUmVjdXJzaW9uID09PSB0cnVlKSB7XG4gICAgICAgIGdyaWQuZ2V0Tm9kZUF0KHgsIHkpLnRlc3RlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGdyaWQuZ2V0Tm9kZUF0KHgsIHkpID09PSB0aGlzLmVuZE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBmb3IgZm9yY2VkIG5laWdoYm9yc1xuICAgIC8vIGFsb25nIHRoZSBkaWFnb25hbFxuICAgIGlmIChkeCAhPT0gMCAmJiBkeSAhPT0gMCkge1xuICAgICAgICBpZiAoKGdyaWQuaXNXYWxrYWJsZUF0KHggLSBkeCwgeSArIGR5KSAmJiAhZ3JpZC5pc1dhbGthYmxlQXQoeCAtIGR4LCB5KSkgfHxcbiAgICAgICAgICAgIChncmlkLmlzV2Fsa2FibGVBdCh4ICsgZHgsIHkgLSBkeSkgJiYgIWdyaWQuaXNXYWxrYWJsZUF0KHgsIHkgLSBkeSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gW3gsIHldO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdoZW4gbW92aW5nIGRpYWdvbmFsbHksIG11c3QgY2hlY2sgZm9yIHZlcnRpY2FsL2hvcml6b250YWwganVtcCBwb2ludHNcbiAgICAgICAgaWYgKHRoaXMuX2p1bXAoeCArIGR4LCB5LCB4LCB5KSB8fCB0aGlzLl9qdW1wKHgsIHkgKyBkeSwgeCwgeSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbeCwgeV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gaG9yaXpvbnRhbGx5L3ZlcnRpY2FsbHlcbiAgICBlbHNlIHtcbiAgICAgICAgaWYoIGR4ICE9PSAwICkgeyAvLyBtb3ZpbmcgYWxvbmcgeFxuICAgICAgICAgICAgaWYoKGdyaWQuaXNXYWxrYWJsZUF0KHggKyBkeCwgeSArIDEpICYmICFncmlkLmlzV2Fsa2FibGVBdCh4LCB5ICsgMSkpIHx8XG4gICAgICAgICAgICAgICAoZ3JpZC5pc1dhbGthYmxlQXQoeCArIGR4LCB5IC0gMSkgJiYgIWdyaWQuaXNXYWxrYWJsZUF0KHgsIHkgLSAxKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3gsIHldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYoKGdyaWQuaXNXYWxrYWJsZUF0KHggKyAxLCB5ICsgZHkpICYmICFncmlkLmlzV2Fsa2FibGVBdCh4ICsgMSwgeSkpIHx8XG4gICAgICAgICAgICAgICAoZ3JpZC5pc1dhbGthYmxlQXQoeCAtIDEsIHkgKyBkeSkgJiYgIWdyaWQuaXNXYWxrYWJsZUF0KHggLSAxLCB5KSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3gsIHldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gbW92aW5nIGRpYWdvbmFsbHksIG11c3QgbWFrZSBzdXJlIG9uZSBvZiB0aGUgdmVydGljYWwvaG9yaXpvbnRhbFxuICAgIC8vIG5laWdoYm9ycyBpcyBvcGVuIHRvIGFsbG93IHRoZSBwYXRoXG4gICAgaWYgKGdyaWQuaXNXYWxrYWJsZUF0KHggKyBkeCwgeSkgfHwgZ3JpZC5pc1dhbGthYmxlQXQoeCwgeSArIGR5KSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fanVtcCh4ICsgZHgsIHkgKyBkeSwgeCwgeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcblxuLyoqXG4gKiBGaW5kIHRoZSBuZWlnaGJvcnMgZm9yIHRoZSBnaXZlbiBub2RlLiBJZiB0aGUgbm9kZSBoYXMgYSBwYXJlbnQsXG4gKiBwcnVuZSB0aGUgbmVpZ2hib3JzIGJhc2VkIG9uIHRoZSBqdW1wIHBvaW50IHNlYXJjaCBhbGdvcml0aG0sIG90aGVyd2lzZVxuICogcmV0dXJuIGFsbCBhdmFpbGFibGUgbmVpZ2hib3JzLlxuICogQHJldHVybiB7QXJyYXkuPFtudW1iZXIsIG51bWJlcl0+fSBUaGUgbmVpZ2hib3JzIGZvdW5kLlxuICovXG5KUEZNb3ZlRGlhZ29uYWxseUlmQXRNb3N0T25lT2JzdGFjbGUucHJvdG90eXBlLl9maW5kTmVpZ2hib3JzID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHZhciBwYXJlbnQgPSBub2RlLnBhcmVudCxcbiAgICAgICAgeCA9IG5vZGUueCwgeSA9IG5vZGUueSxcbiAgICAgICAgZ3JpZCA9IHRoaXMuZ3JpZCxcbiAgICAgICAgcHgsIHB5LCBueCwgbnksIGR4LCBkeSxcbiAgICAgICAgbmVpZ2hib3JzID0gW10sIG5laWdoYm9yTm9kZXMsIG5laWdoYm9yTm9kZSwgaSwgbDtcblxuICAgIC8vIGRpcmVjdGVkIHBydW5pbmc6IGNhbiBpZ25vcmUgbW9zdCBuZWlnaGJvcnMsIHVubGVzcyBmb3JjZWQuXG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgICBweCA9IHBhcmVudC54O1xuICAgICAgICBweSA9IHBhcmVudC55O1xuICAgICAgICAvLyBnZXQgdGhlIG5vcm1hbGl6ZWQgZGlyZWN0aW9uIG9mIHRyYXZlbFxuICAgICAgICBkeCA9ICh4IC0gcHgpIC8gTWF0aC5tYXgoTWF0aC5hYnMoeCAtIHB4KSwgMSk7XG4gICAgICAgIGR5ID0gKHkgLSBweSkgLyBNYXRoLm1heChNYXRoLmFicyh5IC0gcHkpLCAxKTtcblxuICAgICAgICAvLyBzZWFyY2ggZGlhZ29uYWxseVxuICAgICAgICBpZiAoZHggIT09IDAgJiYgZHkgIT09IDApIHtcbiAgICAgICAgICAgIGlmIChncmlkLmlzV2Fsa2FibGVBdCh4LCB5ICsgZHkpKSB7XG4gICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3gsIHkgKyBkeV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyaWQuaXNXYWxrYWJsZUF0KHggKyBkeCwgeSkpIHtcbiAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCArIGR4LCB5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JpZC5pc1dhbGthYmxlQXQoeCwgeSArIGR5KSB8fCBncmlkLmlzV2Fsa2FibGVBdCh4ICsgZHgsIHkpKSB7XG4gICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3ggKyBkeCwgeSArIGR5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWdyaWQuaXNXYWxrYWJsZUF0KHggLSBkeCwgeSkgJiYgZ3JpZC5pc1dhbGthYmxlQXQoeCwgeSArIGR5KSkge1xuICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKFt4IC0gZHgsIHkgKyBkeV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFncmlkLmlzV2Fsa2FibGVBdCh4LCB5IC0gZHkpICYmIGdyaWQuaXNXYWxrYWJsZUF0KHggKyBkeCwgeSkpIHtcbiAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCArIGR4LCB5IC0gZHldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBzZWFyY2ggaG9yaXpvbnRhbGx5L3ZlcnRpY2FsbHlcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZihkeCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChncmlkLmlzV2Fsa2FibGVBdCh4LCB5ICsgZHkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKFt4LCB5ICsgZHldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFncmlkLmlzV2Fsa2FibGVBdCh4ICsgMSwgeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKFt4ICsgMSwgeSArIGR5XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFncmlkLmlzV2Fsa2FibGVBdCh4IC0gMSwgeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKFt4IC0gMSwgeSArIGR5XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZ3JpZC5pc1dhbGthYmxlQXQoeCArIGR4LCB5KSkge1xuICAgICAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCArIGR4LCB5XSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZ3JpZC5pc1dhbGthYmxlQXQoeCwgeSArIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCArIGR4LCB5ICsgMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghZ3JpZC5pc1dhbGthYmxlQXQoeCwgeSAtIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCArIGR4LCB5IC0gMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHJldHVybiBhbGwgbmVpZ2hib3JzXG4gICAgZWxzZSB7XG4gICAgICAgIG5laWdoYm9yTm9kZXMgPSBncmlkLmdldE5laWdoYm9ycyhub2RlLCBEaWFnb25hbE1vdmVtZW50LklmQXRNb3N0T25lT2JzdGFjbGUpO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gbmVpZ2hib3JOb2Rlcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIG5laWdoYm9yTm9kZSA9IG5laWdoYm9yTm9kZXNbaV07XG4gICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbbmVpZ2hib3JOb2RlLngsIG5laWdoYm9yTm9kZS55XSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmVpZ2hib3JzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBKUEZNb3ZlRGlhZ29uYWxseUlmQXRNb3N0T25lT2JzdGFjbGU7XG4iLCIvKipcbiAqIEBhdXRob3IgaW1vciAvIGh0dHBzOi8vZ2l0aHViLmNvbS9pbW9yXG4gKi9cbnZhciBKdW1wUG9pbnRGaW5kZXJCYXNlID0gcmVxdWlyZSgnLi9KdW1wUG9pbnRGaW5kZXJCYXNlJyk7XG52YXIgRGlhZ29uYWxNb3ZlbWVudCA9IHJlcXVpcmUoJy4uL2NvcmUvRGlhZ29uYWxNb3ZlbWVudCcpO1xuXG4vKipcbiAqIFBhdGggZmluZGVyIHVzaW5nIHRoZSBKdW1wIFBvaW50IFNlYXJjaCBhbGdvcml0aG0gd2hpY2ggbW92ZXNcbiAqIGRpYWdvbmFsbHkgb25seSB3aGVuIHRoZXJlIGFyZSBubyBvYnN0YWNsZXMuXG4gKi9cbmZ1bmN0aW9uIEpQRk1vdmVEaWFnb25hbGx5SWZOb09ic3RhY2xlcyhvcHQpIHtcbiAgICBKdW1wUG9pbnRGaW5kZXJCYXNlLmNhbGwodGhpcywgb3B0KTtcbn1cblxuSlBGTW92ZURpYWdvbmFsbHlJZk5vT2JzdGFjbGVzLnByb3RvdHlwZSA9IG5ldyBKdW1wUG9pbnRGaW5kZXJCYXNlKCk7XG5KUEZNb3ZlRGlhZ29uYWxseUlmTm9PYnN0YWNsZXMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSlBGTW92ZURpYWdvbmFsbHlJZk5vT2JzdGFjbGVzO1xuXG4vKipcbiAqIFNlYXJjaCByZWN1cnNpdmVseSBpbiB0aGUgZGlyZWN0aW9uIChwYXJlbnQgLT4gY2hpbGQpLCBzdG9wcGluZyBvbmx5IHdoZW4gYVxuICoganVtcCBwb2ludCBpcyBmb3VuZC5cbiAqIEBwcm90ZWN0ZWRcbiAqIEByZXR1cm4ge0FycmF5LjxbbnVtYmVyLCBudW1iZXJdPn0gVGhlIHgsIHkgY29vcmRpbmF0ZSBvZiB0aGUganVtcCBwb2ludFxuICogICAgIGZvdW5kLCBvciBudWxsIGlmIG5vdCBmb3VuZFxuICovXG5KUEZNb3ZlRGlhZ29uYWxseUlmTm9PYnN0YWNsZXMucHJvdG90eXBlLl9qdW1wID0gZnVuY3Rpb24oeCwgeSwgcHgsIHB5KSB7XG4gICAgdmFyIGdyaWQgPSB0aGlzLmdyaWQsXG4gICAgICAgIGR4ID0geCAtIHB4LCBkeSA9IHkgLSBweTtcblxuICAgIGlmICghZ3JpZC5pc1dhbGthYmxlQXQoeCwgeSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYodGhpcy50cmFja0p1bXBSZWN1cnNpb24gPT09IHRydWUpIHtcbiAgICAgICAgZ3JpZC5nZXROb2RlQXQoeCwgeSkudGVzdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoZ3JpZC5nZXROb2RlQXQoeCwgeSkgPT09IHRoaXMuZW5kTm9kZSkge1xuICAgICAgICByZXR1cm4gW3gsIHldO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGZvciBmb3JjZWQgbmVpZ2hib3JzXG4gICAgLy8gYWxvbmcgdGhlIGRpYWdvbmFsXG4gICAgaWYgKGR4ICE9PSAwICYmIGR5ICE9PSAwKSB7XG4gICAgICAgIC8vIGlmICgoZ3JpZC5pc1dhbGthYmxlQXQoeCAtIGR4LCB5ICsgZHkpICYmICFncmlkLmlzV2Fsa2FibGVBdCh4IC0gZHgsIHkpKSB8fFxuICAgICAgICAgICAgLy8gKGdyaWQuaXNXYWxrYWJsZUF0KHggKyBkeCwgeSAtIGR5KSAmJiAhZ3JpZC5pc1dhbGthYmxlQXQoeCwgeSAtIGR5KSkpIHtcbiAgICAgICAgICAgIC8vIHJldHVybiBbeCwgeV07XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gd2hlbiBtb3ZpbmcgZGlhZ29uYWxseSwgbXVzdCBjaGVjayBmb3IgdmVydGljYWwvaG9yaXpvbnRhbCBqdW1wIHBvaW50c1xuICAgICAgICBpZiAodGhpcy5fanVtcCh4ICsgZHgsIHksIHgsIHkpIHx8IHRoaXMuX2p1bXAoeCwgeSArIGR5LCB4LCB5KSkge1xuICAgICAgICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBob3Jpem9udGFsbHkvdmVydGljYWxseVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoZHggIT09IDApIHtcbiAgICAgICAgICAgIGlmICgoZ3JpZC5pc1dhbGthYmxlQXQoeCwgeSAtIDEpICYmICFncmlkLmlzV2Fsa2FibGVBdCh4IC0gZHgsIHkgLSAxKSkgfHxcbiAgICAgICAgICAgICAgICAoZ3JpZC5pc1dhbGthYmxlQXQoeCwgeSArIDEpICYmICFncmlkLmlzV2Fsa2FibGVBdCh4IC0gZHgsIHkgKyAxKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3gsIHldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGR5ICE9PSAwKSB7XG4gICAgICAgICAgICBpZiAoKGdyaWQuaXNXYWxrYWJsZUF0KHggLSAxLCB5KSAmJiAhZ3JpZC5pc1dhbGthYmxlQXQoeCAtIDEsIHkgLSBkeSkpIHx8XG4gICAgICAgICAgICAgICAgKGdyaWQuaXNXYWxrYWJsZUF0KHggKyAxLCB5KSAmJiAhZ3JpZC5pc1dhbGthYmxlQXQoeCArIDEsIHkgLSBkeSkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdoZW4gbW92aW5nIHZlcnRpY2FsbHksIG11c3QgY2hlY2sgZm9yIGhvcml6b250YWwganVtcCBwb2ludHNcbiAgICAgICAgICAgIC8vIGlmICh0aGlzLl9qdW1wKHggKyAxLCB5LCB4LCB5KSB8fCB0aGlzLl9qdW1wKHggLSAxLCB5LCB4LCB5KSkge1xuICAgICAgICAgICAgICAgIC8vIHJldHVybiBbeCwgeV07XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBtb3ZpbmcgZGlhZ29uYWxseSwgbXVzdCBtYWtlIHN1cmUgb25lIG9mIHRoZSB2ZXJ0aWNhbC9ob3Jpem9udGFsXG4gICAgLy8gbmVpZ2hib3JzIGlzIG9wZW4gdG8gYWxsb3cgdGhlIHBhdGhcbiAgICBpZiAoZ3JpZC5pc1dhbGthYmxlQXQoeCArIGR4LCB5KSAmJiBncmlkLmlzV2Fsa2FibGVBdCh4LCB5ICsgZHkpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9qdW1wKHggKyBkeCwgeSArIGR5LCB4LCB5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuXG4vKipcbiAqIEZpbmQgdGhlIG5laWdoYm9ycyBmb3IgdGhlIGdpdmVuIG5vZGUuIElmIHRoZSBub2RlIGhhcyBhIHBhcmVudCxcbiAqIHBydW5lIHRoZSBuZWlnaGJvcnMgYmFzZWQgb24gdGhlIGp1bXAgcG9pbnQgc2VhcmNoIGFsZ29yaXRobSwgb3RoZXJ3aXNlXG4gKiByZXR1cm4gYWxsIGF2YWlsYWJsZSBuZWlnaGJvcnMuXG4gKiBAcmV0dXJuIHtBcnJheS48W251bWJlciwgbnVtYmVyXT59IFRoZSBuZWlnaGJvcnMgZm91bmQuXG4gKi9cbkpQRk1vdmVEaWFnb25hbGx5SWZOb09ic3RhY2xlcy5wcm90b3R5cGUuX2ZpbmROZWlnaGJvcnMgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50LFxuICAgICAgICB4ID0gbm9kZS54LCB5ID0gbm9kZS55LFxuICAgICAgICBncmlkID0gdGhpcy5ncmlkLFxuICAgICAgICBweCwgcHksIG54LCBueSwgZHgsIGR5LFxuICAgICAgICBuZWlnaGJvcnMgPSBbXSwgbmVpZ2hib3JOb2RlcywgbmVpZ2hib3JOb2RlLCBpLCBsO1xuXG4gICAgLy8gZGlyZWN0ZWQgcHJ1bmluZzogY2FuIGlnbm9yZSBtb3N0IG5laWdoYm9ycywgdW5sZXNzIGZvcmNlZC5cbiAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIHB4ID0gcGFyZW50Lng7XG4gICAgICAgIHB5ID0gcGFyZW50Lnk7XG4gICAgICAgIC8vIGdldCB0aGUgbm9ybWFsaXplZCBkaXJlY3Rpb24gb2YgdHJhdmVsXG4gICAgICAgIGR4ID0gKHggLSBweCkgLyBNYXRoLm1heChNYXRoLmFicyh4IC0gcHgpLCAxKTtcbiAgICAgICAgZHkgPSAoeSAtIHB5KSAvIE1hdGgubWF4KE1hdGguYWJzKHkgLSBweSksIDEpO1xuXG4gICAgICAgIC8vIHNlYXJjaCBkaWFnb25hbGx5XG4gICAgICAgIGlmIChkeCAhPT0gMCAmJiBkeSAhPT0gMCkge1xuICAgICAgICAgICAgaWYgKGdyaWQuaXNXYWxrYWJsZUF0KHgsIHkgKyBkeSkpIHtcbiAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCwgeSArIGR5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JpZC5pc1dhbGthYmxlQXQoeCArIGR4LCB5KSkge1xuICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKFt4ICsgZHgsIHldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncmlkLmlzV2Fsa2FibGVBdCh4LCB5ICsgZHkpICYmIGdyaWQuaXNXYWxrYWJsZUF0KHggKyBkeCwgeSkpIHtcbiAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCArIGR4LCB5ICsgZHldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBzZWFyY2ggaG9yaXpvbnRhbGx5L3ZlcnRpY2FsbHlcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgaXNOZXh0V2Fsa2FibGU7XG4gICAgICAgICAgICBpZiAoZHggIT09IDApIHtcbiAgICAgICAgICAgICAgICBpc05leHRXYWxrYWJsZSA9IGdyaWQuaXNXYWxrYWJsZUF0KHggKyBkeCwgeSk7XG4gICAgICAgICAgICAgICAgdmFyIGlzVG9wV2Fsa2FibGUgPSBncmlkLmlzV2Fsa2FibGVBdCh4LCB5ICsgMSk7XG4gICAgICAgICAgICAgICAgdmFyIGlzQm90dG9tV2Fsa2FibGUgPSBncmlkLmlzV2Fsa2FibGVBdCh4LCB5IC0gMSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNOZXh0V2Fsa2FibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3ggKyBkeCwgeV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNUb3BXYWxrYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3ggKyBkeCwgeSArIDFdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNCb3R0b21XYWxrYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3ggKyBkeCwgeSAtIDFdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNUb3BXYWxrYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCwgeSArIDFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzQm90dG9tV2Fsa2FibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3gsIHkgLSAxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZHkgIT09IDApIHtcbiAgICAgICAgICAgICAgICBpc05leHRXYWxrYWJsZSA9IGdyaWQuaXNXYWxrYWJsZUF0KHgsIHkgKyBkeSk7XG4gICAgICAgICAgICAgICAgdmFyIGlzUmlnaHRXYWxrYWJsZSA9IGdyaWQuaXNXYWxrYWJsZUF0KHggKyAxLCB5KTtcbiAgICAgICAgICAgICAgICB2YXIgaXNMZWZ0V2Fsa2FibGUgPSBncmlkLmlzV2Fsa2FibGVBdCh4IC0gMSwgeSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNOZXh0V2Fsa2FibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3gsIHkgKyBkeV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNSaWdodFdhbGthYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCArIDEsIHkgKyBkeV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0xlZnRXYWxrYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3ggLSAxLCB5ICsgZHldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNSaWdodFdhbGthYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKFt4ICsgMSwgeV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNMZWZ0V2Fsa2FibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3ggLSAxLCB5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHJldHVybiBhbGwgbmVpZ2hib3JzXG4gICAgZWxzZSB7XG4gICAgICAgIG5laWdoYm9yTm9kZXMgPSBncmlkLmdldE5laWdoYm9ycyhub2RlLCBEaWFnb25hbE1vdmVtZW50Lk9ubHlXaGVuTm9PYnN0YWNsZXMpO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gbmVpZ2hib3JOb2Rlcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIG5laWdoYm9yTm9kZSA9IG5laWdoYm9yTm9kZXNbaV07XG4gICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbbmVpZ2hib3JOb2RlLngsIG5laWdoYm9yTm9kZS55XSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmVpZ2hib3JzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBKUEZNb3ZlRGlhZ29uYWxseUlmTm9PYnN0YWNsZXM7XG4iLCIvKipcbiAqIEBhdXRob3IgaW1vciAvIGh0dHBzOi8vZ2l0aHViLmNvbS9pbW9yXG4gKi9cbnZhciBKdW1wUG9pbnRGaW5kZXJCYXNlID0gcmVxdWlyZSgnLi9KdW1wUG9pbnRGaW5kZXJCYXNlJyk7XG52YXIgRGlhZ29uYWxNb3ZlbWVudCA9IHJlcXVpcmUoJy4uL2NvcmUvRGlhZ29uYWxNb3ZlbWVudCcpO1xuXG4vKipcbiAqIFBhdGggZmluZGVyIHVzaW5nIHRoZSBKdW1wIFBvaW50IFNlYXJjaCBhbGdvcml0aG0gYWxsb3dpbmcgb25seSBob3Jpem9udGFsXG4gKiBvciB2ZXJ0aWNhbCBtb3ZlbWVudHMuXG4gKi9cbmZ1bmN0aW9uIEpQRk5ldmVyTW92ZURpYWdvbmFsbHkob3B0KSB7XG4gICAgSnVtcFBvaW50RmluZGVyQmFzZS5jYWxsKHRoaXMsIG9wdCk7XG59XG5cbkpQRk5ldmVyTW92ZURpYWdvbmFsbHkucHJvdG90eXBlID0gbmV3IEp1bXBQb2ludEZpbmRlckJhc2UoKTtcbkpQRk5ldmVyTW92ZURpYWdvbmFsbHkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSlBGTmV2ZXJNb3ZlRGlhZ29uYWxseTtcblxuLyoqXG4gKiBTZWFyY2ggcmVjdXJzaXZlbHkgaW4gdGhlIGRpcmVjdGlvbiAocGFyZW50IC0+IGNoaWxkKSwgc3RvcHBpbmcgb25seSB3aGVuIGFcbiAqIGp1bXAgcG9pbnQgaXMgZm91bmQuXG4gKiBAcHJvdGVjdGVkXG4gKiBAcmV0dXJuIHtBcnJheS48W251bWJlciwgbnVtYmVyXT59IFRoZSB4LCB5IGNvb3JkaW5hdGUgb2YgdGhlIGp1bXAgcG9pbnRcbiAqICAgICBmb3VuZCwgb3IgbnVsbCBpZiBub3QgZm91bmRcbiAqL1xuSlBGTmV2ZXJNb3ZlRGlhZ29uYWxseS5wcm90b3R5cGUuX2p1bXAgPSBmdW5jdGlvbih4LCB5LCBweCwgcHkpIHtcbiAgICB2YXIgZ3JpZCA9IHRoaXMuZ3JpZCxcbiAgICAgICAgZHggPSB4IC0gcHgsIGR5ID0geSAtIHB5O1xuXG4gICAgaWYgKCFncmlkLmlzV2Fsa2FibGVBdCh4LCB5KSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZih0aGlzLnRyYWNrSnVtcFJlY3Vyc2lvbiA9PT0gdHJ1ZSkge1xuICAgICAgICBncmlkLmdldE5vZGVBdCh4LCB5KS50ZXN0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChncmlkLmdldE5vZGVBdCh4LCB5KSA9PT0gdGhpcy5lbmROb2RlKSB7XG4gICAgICAgIHJldHVybiBbeCwgeV07XG4gICAgfVxuXG4gICAgaWYgKGR4ICE9PSAwKSB7XG4gICAgICAgIGlmICgoZ3JpZC5pc1dhbGthYmxlQXQoeCwgeSAtIDEpICYmICFncmlkLmlzV2Fsa2FibGVBdCh4IC0gZHgsIHkgLSAxKSkgfHxcbiAgICAgICAgICAgIChncmlkLmlzV2Fsa2FibGVBdCh4LCB5ICsgMSkgJiYgIWdyaWQuaXNXYWxrYWJsZUF0KHggLSBkeCwgeSArIDEpKSkge1xuICAgICAgICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChkeSAhPT0gMCkge1xuICAgICAgICBpZiAoKGdyaWQuaXNXYWxrYWJsZUF0KHggLSAxLCB5KSAmJiAhZ3JpZC5pc1dhbGthYmxlQXQoeCAtIDEsIHkgLSBkeSkpIHx8XG4gICAgICAgICAgICAoZ3JpZC5pc1dhbGthYmxlQXQoeCArIDEsIHkpICYmICFncmlkLmlzV2Fsa2FibGVBdCh4ICsgMSwgeSAtIGR5KSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbeCwgeV07XG4gICAgICAgIH1cbiAgICAgICAgLy9XaGVuIG1vdmluZyB2ZXJ0aWNhbGx5LCBtdXN0IGNoZWNrIGZvciBob3Jpem9udGFsIGp1bXAgcG9pbnRzXG4gICAgICAgIGlmICh0aGlzLl9qdW1wKHggKyAxLCB5LCB4LCB5KSB8fCB0aGlzLl9qdW1wKHggLSAxLCB5LCB4LCB5KSkge1xuICAgICAgICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT25seSBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBtb3ZlbWVudHMgYXJlIGFsbG93ZWRcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2p1bXAoeCArIGR4LCB5ICsgZHksIHgsIHkpO1xufTtcblxuLyoqXG4gKiBGaW5kIHRoZSBuZWlnaGJvcnMgZm9yIHRoZSBnaXZlbiBub2RlLiBJZiB0aGUgbm9kZSBoYXMgYSBwYXJlbnQsXG4gKiBwcnVuZSB0aGUgbmVpZ2hib3JzIGJhc2VkIG9uIHRoZSBqdW1wIHBvaW50IHNlYXJjaCBhbGdvcml0aG0sIG90aGVyd2lzZVxuICogcmV0dXJuIGFsbCBhdmFpbGFibGUgbmVpZ2hib3JzLlxuICogQHJldHVybiB7QXJyYXkuPFtudW1iZXIsIG51bWJlcl0+fSBUaGUgbmVpZ2hib3JzIGZvdW5kLlxuICovXG5KUEZOZXZlck1vdmVEaWFnb25hbGx5LnByb3RvdHlwZS5fZmluZE5laWdoYm9ycyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnQsXG4gICAgICAgIHggPSBub2RlLngsIHkgPSBub2RlLnksXG4gICAgICAgIGdyaWQgPSB0aGlzLmdyaWQsXG4gICAgICAgIHB4LCBweSwgbngsIG55LCBkeCwgZHksXG4gICAgICAgIG5laWdoYm9ycyA9IFtdLCBuZWlnaGJvck5vZGVzLCBuZWlnaGJvck5vZGUsIGksIGw7XG5cbiAgICAvLyBkaXJlY3RlZCBwcnVuaW5nOiBjYW4gaWdub3JlIG1vc3QgbmVpZ2hib3JzLCB1bmxlc3MgZm9yY2VkLlxuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgcHggPSBwYXJlbnQueDtcbiAgICAgICAgcHkgPSBwYXJlbnQueTtcbiAgICAgICAgLy8gZ2V0IHRoZSBub3JtYWxpemVkIGRpcmVjdGlvbiBvZiB0cmF2ZWxcbiAgICAgICAgZHggPSAoeCAtIHB4KSAvIE1hdGgubWF4KE1hdGguYWJzKHggLSBweCksIDEpO1xuICAgICAgICBkeSA9ICh5IC0gcHkpIC8gTWF0aC5tYXgoTWF0aC5hYnMoeSAtIHB5KSwgMSk7XG5cbiAgICAgICAgaWYgKGR4ICE9PSAwKSB7XG4gICAgICAgICAgICBpZiAoZ3JpZC5pc1dhbGthYmxlQXQoeCwgeSAtIDEpKSB7XG4gICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3gsIHkgLSAxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JpZC5pc1dhbGthYmxlQXQoeCwgeSArIDEpKSB7XG4gICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goW3gsIHkgKyAxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JpZC5pc1dhbGthYmxlQXQoeCArIGR4LCB5KSkge1xuICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKFt4ICsgZHgsIHldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkeSAhPT0gMCkge1xuICAgICAgICAgICAgaWYgKGdyaWQuaXNXYWxrYWJsZUF0KHggLSAxLCB5KSkge1xuICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKFt4IC0gMSwgeV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyaWQuaXNXYWxrYWJsZUF0KHggKyAxLCB5KSkge1xuICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKFt4ICsgMSwgeV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyaWQuaXNXYWxrYWJsZUF0KHgsIHkgKyBkeSkpIHtcbiAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbeCwgeSArIGR5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gcmV0dXJuIGFsbCBuZWlnaGJvcnNcbiAgICBlbHNlIHtcbiAgICAgICAgbmVpZ2hib3JOb2RlcyA9IGdyaWQuZ2V0TmVpZ2hib3JzKG5vZGUsIERpYWdvbmFsTW92ZW1lbnQuTmV2ZXIpO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gbmVpZ2hib3JOb2Rlcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIG5laWdoYm9yTm9kZSA9IG5laWdoYm9yTm9kZXNbaV07XG4gICAgICAgICAgICBuZWlnaGJvcnMucHVzaChbbmVpZ2hib3JOb2RlLngsIG5laWdoYm9yTm9kZS55XSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmVpZ2hib3JzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBKUEZOZXZlck1vdmVEaWFnb25hbGx5O1xuIiwiLyoqXG4gKiBAYXV0aG9yIGFuaWVybyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmllcm9cbiAqL1xudmFyIERpYWdvbmFsTW92ZW1lbnQgPSByZXF1aXJlKCcuLi9jb3JlL0RpYWdvbmFsTW92ZW1lbnQnKTtcbnZhciBKUEZOZXZlck1vdmVEaWFnb25hbGx5ID0gcmVxdWlyZSgnLi9KUEZOZXZlck1vdmVEaWFnb25hbGx5Jyk7XG52YXIgSlBGQWx3YXlzTW92ZURpYWdvbmFsbHkgPSByZXF1aXJlKCcuL0pQRkFsd2F5c01vdmVEaWFnb25hbGx5Jyk7XG52YXIgSlBGTW92ZURpYWdvbmFsbHlJZk5vT2JzdGFjbGVzID0gcmVxdWlyZSgnLi9KUEZNb3ZlRGlhZ29uYWxseUlmTm9PYnN0YWNsZXMnKTtcbnZhciBKUEZNb3ZlRGlhZ29uYWxseUlmQXRNb3N0T25lT2JzdGFjbGUgPSByZXF1aXJlKCcuL0pQRk1vdmVEaWFnb25hbGx5SWZBdE1vc3RPbmVPYnN0YWNsZScpO1xuXG4vKipcbiAqIFBhdGggZmluZGVyIHVzaW5nIHRoZSBKdW1wIFBvaW50IFNlYXJjaCBhbGdvcml0aG1cbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9wdC5oZXVyaXN0aWMgSGV1cmlzdGljIGZ1bmN0aW9uIHRvIGVzdGltYXRlIHRoZSBkaXN0YW5jZVxuICogICAgIChkZWZhdWx0cyB0byBtYW5oYXR0YW4pLlxuICogQHBhcmFtIHtEaWFnb25hbE1vdmVtZW50fSBvcHQuZGlhZ29uYWxNb3ZlbWVudCBDb25kaXRpb24gdW5kZXIgd2hpY2ggZGlhZ29uYWxcbiAqICAgICAgbW92ZW1lbnQgd2lsbCBiZSBhbGxvd2VkLlxuICovXG5mdW5jdGlvbiBKdW1wUG9pbnRGaW5kZXIob3B0KSB7XG4gICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgIGlmIChvcHQuZGlhZ29uYWxNb3ZlbWVudCA9PT0gRGlhZ29uYWxNb3ZlbWVudC5OZXZlcikge1xuICAgICAgICByZXR1cm4gbmV3IEpQRk5ldmVyTW92ZURpYWdvbmFsbHkob3B0KTtcbiAgICB9IGVsc2UgaWYgKG9wdC5kaWFnb25hbE1vdmVtZW50ID09PSBEaWFnb25hbE1vdmVtZW50LkFsd2F5cykge1xuICAgICAgICByZXR1cm4gbmV3IEpQRkFsd2F5c01vdmVEaWFnb25hbGx5KG9wdCk7XG4gICAgfSBlbHNlIGlmIChvcHQuZGlhZ29uYWxNb3ZlbWVudCA9PT0gRGlhZ29uYWxNb3ZlbWVudC5Pbmx5V2hlbk5vT2JzdGFjbGVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgSlBGTW92ZURpYWdvbmFsbHlJZk5vT2JzdGFjbGVzKG9wdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBKUEZNb3ZlRGlhZ29uYWxseUlmQXRNb3N0T25lT2JzdGFjbGUob3B0KTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gSnVtcFBvaW50RmluZGVyO1xuIiwiLyoqXG4gKiBAYXV0aG9yIGltb3IgLyBodHRwczovL2dpdGh1Yi5jb20vaW1vclxuICovXG52YXIgSGVhcCAgICAgICA9IHJlcXVpcmUoJ2hlYXAnKTtcbnZhciBVdGlsICAgICAgID0gcmVxdWlyZSgnLi4vY29yZS9VdGlsJyk7XG52YXIgSGV1cmlzdGljICA9IHJlcXVpcmUoJy4uL2NvcmUvSGV1cmlzdGljJyk7XG52YXIgRGlhZ29uYWxNb3ZlbWVudCA9IHJlcXVpcmUoJy4uL2NvcmUvRGlhZ29uYWxNb3ZlbWVudCcpO1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIHRoZSBKdW1wIFBvaW50IFNlYXJjaCBhbGdvcml0aG1cbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9wdC5oZXVyaXN0aWMgSGV1cmlzdGljIGZ1bmN0aW9uIHRvIGVzdGltYXRlIHRoZSBkaXN0YW5jZVxuICogICAgIChkZWZhdWx0cyB0byBtYW5oYXR0YW4pLlxuICovXG5mdW5jdGlvbiBKdW1wUG9pbnRGaW5kZXJCYXNlKG9wdCkge1xuICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICB0aGlzLmhldXJpc3RpYyA9IG9wdC5oZXVyaXN0aWMgfHwgSGV1cmlzdGljLm1hbmhhdHRhbjtcbiAgICB0aGlzLnRyYWNrSnVtcFJlY3Vyc2lvbiA9IG9wdC50cmFja0p1bXBSZWN1cnNpb24gfHwgZmFsc2U7XG59XG5cbi8qKlxuICogRmluZCBhbmQgcmV0dXJuIHRoZSBwYXRoLlxuICogQHJldHVybiB7QXJyYXkuPFtudW1iZXIsIG51bWJlcl0+fSBUaGUgcGF0aCwgaW5jbHVkaW5nIGJvdGggc3RhcnQgYW5kXG4gKiAgICAgZW5kIHBvc2l0aW9ucy5cbiAqL1xuSnVtcFBvaW50RmluZGVyQmFzZS5wcm90b3R5cGUuZmluZFBhdGggPSBmdW5jdGlvbihzdGFydFgsIHN0YXJ0WSwgZW5kWCwgZW5kWSwgZ3JpZCkge1xuICAgIHZhciBvcGVuTGlzdCA9IHRoaXMub3Blbkxpc3QgPSBuZXcgSGVhcChmdW5jdGlvbihub2RlQSwgbm9kZUIpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlQS5mIC0gbm9kZUIuZjtcbiAgICAgICAgfSksXG4gICAgICAgIHN0YXJ0Tm9kZSA9IHRoaXMuc3RhcnROb2RlID0gZ3JpZC5nZXROb2RlQXQoc3RhcnRYLCBzdGFydFkpLFxuICAgICAgICBlbmROb2RlID0gdGhpcy5lbmROb2RlID0gZ3JpZC5nZXROb2RlQXQoZW5kWCwgZW5kWSksIG5vZGU7XG5cbiAgICB0aGlzLmdyaWQgPSBncmlkO1xuXG5cbiAgICAvLyBzZXQgdGhlIGBnYCBhbmQgYGZgIHZhbHVlIG9mIHRoZSBzdGFydCBub2RlIHRvIGJlIDBcbiAgICBzdGFydE5vZGUuZyA9IDA7XG4gICAgc3RhcnROb2RlLmYgPSAwO1xuXG4gICAgLy8gcHVzaCB0aGUgc3RhcnQgbm9kZSBpbnRvIHRoZSBvcGVuIGxpc3RcbiAgICBvcGVuTGlzdC5wdXNoKHN0YXJ0Tm9kZSk7XG4gICAgc3RhcnROb2RlLm9wZW5lZCA9IHRydWU7XG5cbiAgICAvLyB3aGlsZSB0aGUgb3BlbiBsaXN0IGlzIG5vdCBlbXB0eVxuICAgIHdoaWxlICghb3Blbkxpc3QuZW1wdHkoKSkge1xuICAgICAgICAvLyBwb3AgdGhlIHBvc2l0aW9uIG9mIG5vZGUgd2hpY2ggaGFzIHRoZSBtaW5pbXVtIGBmYCB2YWx1ZS5cbiAgICAgICAgbm9kZSA9IG9wZW5MaXN0LnBvcCgpO1xuICAgICAgICBub2RlLmNsb3NlZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKG5vZGUgPT09IGVuZE5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBVdGlsLmV4cGFuZFBhdGgoVXRpbC5iYWNrdHJhY2UoZW5kTm9kZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faWRlbnRpZnlTdWNjZXNzb3JzKG5vZGUpO1xuICAgIH1cblxuICAgIC8vIGZhaWwgdG8gZmluZCB0aGUgcGF0aFxuICAgIHJldHVybiBbXTtcbn07XG5cbi8qKlxuICogSWRlbnRpZnkgc3VjY2Vzc29ycyBmb3IgdGhlIGdpdmVuIG5vZGUuIFJ1bnMgYSBqdW1wIHBvaW50IHNlYXJjaCBpbiB0aGVcbiAqIGRpcmVjdGlvbiBvZiBlYWNoIGF2YWlsYWJsZSBuZWlnaGJvciwgYWRkaW5nIGFueSBwb2ludHMgZm91bmQgdG8gdGhlIG9wZW5cbiAqIGxpc3QuXG4gKiBAcHJvdGVjdGVkXG4gKi9cbkp1bXBQb2ludEZpbmRlckJhc2UucHJvdG90eXBlLl9pZGVudGlmeVN1Y2Nlc3NvcnMgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdmFyIGdyaWQgPSB0aGlzLmdyaWQsXG4gICAgICAgIGhldXJpc3RpYyA9IHRoaXMuaGV1cmlzdGljLFxuICAgICAgICBvcGVuTGlzdCA9IHRoaXMub3Blbkxpc3QsXG4gICAgICAgIGVuZFggPSB0aGlzLmVuZE5vZGUueCxcbiAgICAgICAgZW5kWSA9IHRoaXMuZW5kTm9kZS55LFxuICAgICAgICBuZWlnaGJvcnMsIG5laWdoYm9yLFxuICAgICAgICBqdW1wUG9pbnQsIGksIGwsXG4gICAgICAgIHggPSBub2RlLngsIHkgPSBub2RlLnksXG4gICAgICAgIGp4LCBqeSwgZHgsIGR5LCBkLCBuZywganVtcE5vZGUsXG4gICAgICAgIGFicyA9IE1hdGguYWJzLCBtYXggPSBNYXRoLm1heDtcblxuICAgIG5laWdoYm9ycyA9IHRoaXMuX2ZpbmROZWlnaGJvcnMobm9kZSk7XG4gICAgZm9yKGkgPSAwLCBsID0gbmVpZ2hib3JzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICBuZWlnaGJvciA9IG5laWdoYm9yc1tpXTtcbiAgICAgICAganVtcFBvaW50ID0gdGhpcy5fanVtcChuZWlnaGJvclswXSwgbmVpZ2hib3JbMV0sIHgsIHkpO1xuICAgICAgICBpZiAoanVtcFBvaW50KSB7XG5cbiAgICAgICAgICAgIGp4ID0ganVtcFBvaW50WzBdO1xuICAgICAgICAgICAgankgPSBqdW1wUG9pbnRbMV07XG4gICAgICAgICAgICBqdW1wTm9kZSA9IGdyaWQuZ2V0Tm9kZUF0KGp4LCBqeSk7XG5cbiAgICAgICAgICAgIGlmIChqdW1wTm9kZS5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaW5jbHVkZSBkaXN0YW5jZSwgYXMgcGFyZW50IG1heSBub3QgYmUgaW1tZWRpYXRlbHkgYWRqYWNlbnQ6XG4gICAgICAgICAgICBkID0gSGV1cmlzdGljLm9jdGlsZShhYnMoanggLSB4KSwgYWJzKGp5IC0geSkpO1xuICAgICAgICAgICAgbmcgPSBub2RlLmcgKyBkOyAvLyBuZXh0IGBnYCB2YWx1ZVxuXG4gICAgICAgICAgICBpZiAoIWp1bXBOb2RlLm9wZW5lZCB8fCBuZyA8IGp1bXBOb2RlLmcpIHtcbiAgICAgICAgICAgICAgICBqdW1wTm9kZS5nID0gbmc7XG4gICAgICAgICAgICAgICAganVtcE5vZGUuaCA9IGp1bXBOb2RlLmggfHwgaGV1cmlzdGljKGFicyhqeCAtIGVuZFgpLCBhYnMoankgLSBlbmRZKSk7XG4gICAgICAgICAgICAgICAganVtcE5vZGUuZiA9IGp1bXBOb2RlLmcgKyBqdW1wTm9kZS5oO1xuICAgICAgICAgICAgICAgIGp1bXBOb2RlLnBhcmVudCA9IG5vZGU7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWp1bXBOb2RlLm9wZW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBvcGVuTGlzdC5wdXNoKGp1bXBOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAganVtcE5vZGUub3BlbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvcGVuTGlzdC51cGRhdGVJdGVtKGp1bXBOb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEp1bXBQb2ludEZpbmRlckJhc2U7XG4iXX0="}